<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yihang (Ian) Ding">


    <meta name="subtitle" content="Glad you reach here.">




<title>Archives: 2020/1 | Yihang&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,700|Noto+Serif+KR:300,700|Source+Code+Pro:400,400i,700,700i&display=swap" rel="stylesheet">



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
            <a href="/">楽しんでね。| Yihang&#39;s Nest</a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">Résumé</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">楽しんでね。| Yihang&#39;s Nest</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">Résumé</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="post-wrap archive">
	<br>
	<h1> ✏ | Posts </h1>
	<br>
</div>
<div class="post-wrap archive">
    
    
        

        
            <h1>2020</h1>
        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/01/18/hello-world/">Hello World</a>
            <span class="archive-item-date">Jan 18, 2020</span>
            <!-- <span style=> <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/01/14/shaoniandeni/">《少年的你》：太爱前几分钟的质感和镜头了</a>
            <span class="archive-item-date">Jan 14, 2020</span>
            <!-- <span style=> <p>实在是太爱前几分钟的镜头和质感了。像极了日本同题材电影《告白》。</p>
<p><img src="1.jpg" alt="image"></p>
<p>有一句话印象很深刻。</p>
<blockquote>
<p>“从来没有一节课教会我们如何变成大人。”</p>
</blockquote>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/01/10/markdown/">Markdown Display Test</a>
            <span class="archive-item-date">Jan 10, 2020</span>
            <!-- <span style=> <h1 id="Markdown-Syntax"><a href="#Markdown-Syntax" class="headerlink" title="Markdown: Syntax"></a>Markdown: Syntax</h1><p>I want to test <code>size</code> should be okay!</p>
<pre><code>and the code block
should be okay as well!</code></pre><h1 id="This-is-code"><a href="#This-is-code" class="headerlink" title="This is code"></a>This is <code>code</code></h1><h2 id="This-is-code-1"><a href="#This-is-code-1" class="headerlink" title="This is code"></a>This is <code>code</code></h2><h3 id="This-is-code-2"><a href="#This-is-code-2" class="headerlink" title="This is code"></a>This is <code>code</code></h3><h4 id="This-is-code-3"><a href="#This-is-code-3" class="headerlink" title="This is code"></a>This is <code>code</code></h4><h5 id="This-is-code-4"><a href="#This-is-code-4" class="headerlink" title="This is code"></a>This is <code>code</code></h5><ul>
<li>this is <code>code</code></li>
</ul>
<p>Test mathjax:</p>
<p>$$f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}$$</p>
<p>$$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$$</p>
<p>$$\left[<br>\begin{matrix}<br>V_A \\<br>V_B \\<br>V_C \\<br>\end{matrix}<br>\right] =<br>\left[<br>\begin{matrix}<br>1 &amp; 0 &amp; L \\<br>-cosψ &amp; sinψ &amp; L \\<br>-cosψ &amp; -sinψ &amp; L<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>V_x \\<br>V_y \\<br>W \\<br>\end{matrix}<br>\right] $$</p>
<h1 id="中文标题"><a href="#中文标题" class="headerlink" title="中文标题"></a>中文标题</h1><p>Can you test ‘??’ and “??”.</p>
<p><em>你好</em><br><em>hello</em><br><strong>hello</strong><br><strong>你好</strong><br><strong>这句话应该被加粗。</strong><br>他姐说，“你这样有意思吗”？我濡染布置但怎！么办……好被。<br>“How can you do this?”</p>
<p><strong><em>OK, I’m okay!</em></strong><br><strong><em>我一点都不好！</em></strong></p>
<ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#philosophy">Philosophy</a></li>
<li><a href="#html">Inline HTML</a></li>
<li><a href="#autoescape">Automatic Escaping for Special Characters</a></li>
</ul>
</li>
<li><a href="#block">Block Elements</a><ul>
<li><a href="#p">Paragraphs and Line Breaks</a></li>
<li><a href="#header">Headers</a></li>
<li><a href="#blockquote">Blockquotes</a></li>
<li><a href="#list">Lists</a></li>
<li><a href="#precode">Code Blocks</a></li>
<li><a href="#hr">Horizontal Rules</a></li>
</ul>
</li>
<li><a href="#span">Span Elements</a><ul>
<li><a href="#link">Links</a></li>
<li><a href="#em">Emphasis</a></li>
<li><a href="#code">Code</a></li>
<li><a href="#img">Images</a></li>
</ul>
</li>
<li><a href="#misc">Miscellaneous</a><ul>
<li><a href="#backslash">Backslash Escapes</a></li>
<li><a href="#autolink">Automatic Links</a></li>
</ul>
</li>
</ul>
<p><strong>Note:</strong> This document is itself written using Markdown; you<br>can <a href="/projects/markdown/syntax.text">see the source for it by adding ‘.text’ to the URL</a>.</p>
<hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Philosophy"><a href="#Philosophy" class="headerlink" title="Philosophy"></a>Philosophy</h3><p>Markdown is intended to be as easy-to-read and easy-to-write as is feasible.</p>
<p>Readability, however, is emphasized above all else. A Markdown-formatted document should be publishable as-is, as plain text, without looking<br>like it’s been marked up with tags or formatting instructions. While<br>Markdown’s syntax has been influenced by several existing text-to-HTML<br>filters – including <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>, <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>, <a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>, <a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>,<br><a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a>, and <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a> – the single biggest source of<br>inspiration for Markdown’s syntax is the format of plain text email.</p>
<h2 id="Block-Elements"><a href="#Block-Elements" class="headerlink" title="Block Elements"></a>Block Elements</h2><h3 id="Paragraphs-and-Line-Breaks"><a href="#Paragraphs-and-Line-Breaks" class="headerlink" title="Paragraphs and Line Breaks"></a>Paragraphs and Line Breaks</h3><p>A paragraph is simply one or more consecutive lines of text, separated<br>by one or more blank lines. (A blank line is any line that looks like a<br>blank line – a line containing nothing but spaces or tabs is considered<br>blank.) Normal paragraphs should not be indented with spaces or tabs.</p>
<p>The implication of the “one or more consecutive lines of text” rule is<br>that Markdown supports “hard-wrapped” text paragraphs. This differs<br>significantly from most other text-to-HTML formatters (including Movable<br>Type’s “Convert Line Breaks” option) which translate every line break<br>character in a paragraph into a <code>&lt;br /&gt;</code> tag.</p>
<p>When you <em>do</em> want to insert a <code>&lt;br /&gt;</code> break tag using Markdown, you<br>end a line with two or more spaces, then type return.</p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Markdown supports two styles of headers, [Setext] [1] and [atx] [2].</p>
<p>Optionally, you may “close” atx-style headers. This is purely<br>cosmetic – you can use this if you think it looks better. The<br>closing hashes don’t even need to match the number of hashes<br>used to open the header. (The number of opening hashes<br>determines the header level.)</p>
<h3 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h3><p>Markdown uses email-style <code>&gt;</code> characters for blockquoting. If you’re<br>familiar with quoting passages of text in an email message, then you<br>know how to create a blockquote in Markdown. It looks best if you hard<br>wrap the text and put a <code>&gt;</code> before every line:</p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<p>Markdown allows you to be lazy and only put the <code>&gt;</code> before the first<br>line of a hard-wrapped paragraph:</p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<p>Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by<br>adding additional levels of <code>&gt;</code>:</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<p>Blockquotes can contain other Markdown elements, including headers, lists,<br>and code blocks:</p>
<blockquote>
<h2 id="This-is-a-header"><a href="#This-is-a-header" class="headerlink" title="This is a header."></a>This is a header.</h2><ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here’s some example code:</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote>
<p>Any decent text editor should make email-style quoting easy. For<br>example, with BBEdit, you can make a selection and choose Increase<br>Quote Level from the Text menu.</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>Markdown supports ordered (numbered) and unordered (bulleted) lists.</p>
<p>Unordered lists use asterisks, pluses, and hyphens – interchangably<br>– as list markers:</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>is equivalent to:</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>and:</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>Ordered lists use numbers followed by periods:</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>It’s important to note that the actual numbers you use to mark the<br>list have no effect on the HTML output Markdown produces. The HTML<br>Markdown produces from the above list is:</p>
<p>If you instead wrote the list in Markdown like this:</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>or even:</p>
<ol start="3">
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
<p>you’d get the exact same HTML output. The point is, if you want to,<br>you can use ordinal numbers in your ordered Markdown lists, so that<br>the numbers in your source match the numbers in your published HTML.<br>But if you want to be lazy, you don’t have to.</p>
<p>To make lists look nice, you can wrap items with hanging indents:</p>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
<p>But if you want to be lazy, you don’t have to:</p>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,<br>viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.<br>Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
<p>List items may consist of multiple paragraphs. Each subsequent<br>paragraph in a list item must be indented by either 4 spaces<br>or one tab:</p>
<ol>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>
</li>
<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</li>
</ol>
<p>It looks nice if you indent every line of the subsequent<br>paragraphs, but here again, Markdown will allow you to be<br>lazy:</p>
<ul>
<li><p>This is a list item with two paragraphs.</p>
<p>This is the second paragraph in the list item. You’re<br>only required to indent the first line. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit.</p>
</li>
<li><p>Another item in the same list.</p>
</li>
</ul>
<p>To put a blockquote within a list item, the blockquote’s <code>&gt;</code><br>delimiters need to be indented:</p>
<ul>
<li><p>A list item with a blockquote:</p>
<blockquote>
<p>This is a blockquote<br>inside a list item.</p>
</blockquote>
</li>
</ul>
<p>To put a code block within a list item, the code block needs<br>to be indented <em>twice</em> – 8 spaces or two tabs:</p>
<ul>
<li><p>A list item with a code block:</p>
<pre><code>&lt;code goes here&gt;</code></pre></li>
</ul>
<h3 id="Code-Blocks"><a href="#Code-Blocks" class="headerlink" title="Code Blocks"></a>Code Blocks</h3><p>Pre-formatted code blocks are used for writing about programming or<br>markup source code. Rather than forming normal paragraphs, the lines<br>of a code block are interpreted literally. Markdown wraps a code block<br>in both <code>&lt;pre&gt;</code> and <code>&lt;code&gt;</code> tags.</p>
<p>To produce a code block in Markdown, simply indent every line of the<br>block by at least 4 spaces or 1 tab.</p>
<p>This is a normal paragraph:</p>
<pre><code>This is a code block.</code></pre><p>Here is an example of AppleScript:</p>
<pre><code>tell application &quot;Foo&quot;
    beep
end tell</code></pre><p>A code block continues until it reaches a line that is not indented<br>(or the end of the article).</p>
<p>Within a code block, ampersands (<code>&amp;</code>) and angle brackets (<code>&lt;</code> and <code>&gt;</code>)<br>are automatically converted into HTML entities. This makes it very<br>easy to include example HTML source code using Markdown – just paste<br>it and indent it, and Markdown will handle the hassle of encoding the<br>ampersands and angle brackets. For example, this:</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;</code></pre><p>Regular Markdown syntax is not processed within code blocks. E.g.,<br>asterisks are just literal asterisks within a code block. This means<br>it’s also easy to use Markdown to write about Markdown’s own syntax.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br></pre></td></tr></table></figure>

<h2 id="Span-Elements"><a href="#Span-Elements" class="headerlink" title="Span Elements"></a>Span Elements</h2><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><p>Markdown supports two style of links: <em>inline</em> and <em>reference</em>.</p>
<p>In both styles, the link text is delimited by [square brackets].</p>
<p>To create an inline link, use a set of regular parentheses immediately<br>after the link text’s closing square bracket. Inside the parentheses,<br>put the URL where you want the link to point, along with an <em>optional</em><br>title for the link, surrounded in quotes. For example:</p>
<p>This is <a href="http://example.com/" target="_blank" rel="noopener">an example</a> inline link.</p>
<p><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p>
<h3 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h3><p>Markdown treats asterisks (<code>*</code>) and underscores (<code>_</code>) as indicators of<br>emphasis. Text wrapped with one <code>*</code> or <code>_</code> will be wrapped with an<br>HTML <code>&lt;em&gt;</code> tag; double <code>*</code>‘s or <code>_</code>‘s will be wrapped with an HTML<br><code>&lt;strong&gt;</code> tag. E.g., this input:</p>
<p><em>single asterisks</em></p>
<p><em>single underscores</em></p>
<p><strong>double asterisks</strong></p>
<p><strong>double underscores</strong></p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>To indicate a span of code, wrap it with backtick quotes (<code>`</code>).<br>Unlike a pre-formatted code block, a code span indicates code within a<br>normal paragraph. For example:</p>
<p>Use the <code>printf()</code> function.</p>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/01/10/DFS-notes/">DFS总结2</a>
            <span class="archive-item-date">Jan 10, 2020</span>
            <!-- <span style=> <h2 id="DFS-大全2"><a href="#DFS-大全2" class="headerlink" title="DFS 大全2"></a>DFS 大全2</h2><p>在此写一个dfs的相关题目总结。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><font color=green><strong>Easy</strong></font><br><font color=orange><strong>Medium</strong></font><br><font color=red><strong>Hard</strong></font></p>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Notes</th>
<th>自评</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#694"><strong>694</strong></a> <font color=orange><strong>Medium</strong></font> Number of Distinct Islands</td>
<td>Typical DFS but could be tricky!</td>
<td><font color=orange><strong>Medium</strong></font> Very smart and think about it carefully.</td>
</tr>
<tr>
<td><a href="#126"><strong>126</strong></a> <font color=red><strong>Hard</strong></font> word ladder II</td>
<td>New BFS problems, the element in queue in a path!</td>
<td><font color=red><strong>Hard</strong></font> It is easy to find shortest path with BFS, but how about finding multiple paths?</td>
</tr>
<tr>
<td><a href="#351"><strong>351</strong></a> <font color=orange><strong>Medium</strong></font> Android Unlock Patterns</td>
<td>A very interesting problem but not so hard.</td>
<td><font color=red><strong>Medium</strong></font> Some solutions are symmetric so you do not have to do DFS on every entry.</td>
</tr>
<tr>
<td><a href="#139"><strong>139</strong></a> <font color=orange><strong>Medium</strong></font> Word Break</td>
<td>In fact it is a typical DFS problem with memo.</td>
<td><font color=orange><strong>Medium</strong></font> You have to deeply REMEMBER this solution.</td>
</tr>
<tr>
<td><a href="#140"><strong>140</strong></a> <font color=red><strong>Hard</strong></font> Word Break II</td>
<td>This is the follow-up from the last one.</td>
<td><font color=orange><strong>Medium</strong></font> This is still dfs+memo. You have to know how to use memo in this case!</td>
</tr>
<tr>
<td><a href="#505"><strong>505</strong></a> <font color=orange><strong>Medium</strong></font> The Maze II</td>
<td>You can do it with a standard DFS or BFS. But either solution may visit a node more than once. This is a typical shortest path solution, and either BFS or DFS is an instance of the generic solution to SP. The BFS solution would be modified into Dijkstra’s algorithm.</td>
<td><font color=orange><strong>Medium</strong></font> It is not a normally DFS/BFS solution as one node might be visited for more than once.</td>
</tr>
</tbody></table>
<h3 id="694-Number-of-Distinct-Islands"><a href="#694-Number-of-Distinct-Islands" class="headerlink" title="694 Number of Distinct Islands"></a><a id="694">694 Number of Distinct Islands</a></h3><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.</p>
<p><strong>Example</strong>:</p>
<pre><code>11011
10000
00001
11011</code></pre><p>The output is 2.</p>
<p>这个题目不难，典型的dfs，先看一个解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we could still use dfs to solve this problem</span></span><br><span class="line">        <span class="comment">// we may record the "direction" of dfs to identify the shape of an island</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">// origin</span></span><br><span class="line">                dfs(i, j, grid, sb, <span class="string">'o'</span>); <span class="comment">// origin</span></span><br><span class="line">                set.add(sb.toString());</span><br><span class="line">                System.out.println(sb);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, StringBuilder sb, <span class="keyword">char</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        sb.append(direction);</span><br><span class="line"></span><br><span class="line">        dfs(i-<span class="number">1</span>, j, grid, sb, <span class="string">'u'</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>, j, grid, sb, <span class="string">'d'</span>);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>, grid, sb, <span class="string">'l'</span>);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>, grid, sb, <span class="string">'r'</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">'b'</span>); <span class="comment">// This is amazing!!!!!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在dfs做完之后加一个”b”呢？假如没有的话，请考虑一下这种情况：</p>
<pre><code>1 1 0
0 1 1
0 0 0
1 1 1
0 1 0</code></pre><p>这次做完两个大的dfs之后，会发现两个字符串均为<code>ordr</code>，也就是说这种方法还是无法区分某些不同的island。在后面在一个<code>b</code>等于mark了一个dfs的结束，这样，两个island要完全相同，才能保证这两个对应的字符串是一样的。</p>
<h3 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title=" 126 Word Ladder II "></a><a id="126"> 126 Word Ladder II </a></h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p>
<ul>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li>
</ul>
<p>In BFS, it is easy to find the shortest path, but how can you find all possible shortest paths?</p>
<p>There are several points you need to pay attention to:</p>
<ul>
<li>How can you save the paths? One good way is to use the path as the element of the queue;</li>
<li>How can you make sure that some nodes could be visited twice? The solution is here is really interesting: <strong>we only mark the nodes as visited only after we have done this level</strong>. This can ensure two different paths can both visit this node if they reach it at the same level. It also make sure this node is not visited by the higher level;</li>
<li><code>minLevel</code> is used to avoid unnecessary BFS.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minLevel = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="comment">// just like finding all possible paths?</span></span><br><span class="line">        <span class="comment">// maybe bfs?</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[beginWord] = findNeighbor(beginWord, wordList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; word: wordList) <span class="built_in">map</span>[word] = findNeighbor(word, wordList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// I think one problem with BFS is</span></span><br><span class="line">        <span class="comment">// how can you make sure that some elements can be visited more than once?</span></span><br><span class="line">        <span class="comment">//basic idea, we mark the node is visited only after the level is done</span></span><br><span class="line">        <span class="comment">// thus, two different paths which reaching a node at same level can both</span></span><br><span class="line">        <span class="comment">// visit this node</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;beginWord&#125;);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; str: wordList) wordSet.insert(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curPath = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curPath.size() &gt; level) &#123;</span><br><span class="line">                <span class="comment">// enter new level</span></span><br><span class="line">                <span class="keyword">if</span> (curPath.size() &gt; minLevel) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    level = curPath.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// add visited node</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">string</span> str: visited) wordSet.erase(str);</span><br><span class="line">                visited.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> lastWord = curPath.back();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i: <span class="built_in">map</span>[lastWord]) &#123;</span><br><span class="line">                <span class="built_in">string</span>&amp; newWord = wordList[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// is visited?</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.find(newWord) == wordSet.end()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                visited.insert(newWord);</span><br><span class="line">                <span class="comment">// prepare a new path</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = curPath;</span><br><span class="line">                path.push_back(newWord);</span><br><span class="line">                <span class="keyword">if</span> (newWord == endWord) &#123;</span><br><span class="line">                    res.push_back(path);</span><br><span class="line">                    minLevel = level;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.push(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNeighbor(<span class="built_in">string</span>&amp; word, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="comment">// given a word, find neighbor</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = words[i];</span><br><span class="line">            <span class="keyword">if</span> (s.size() != word.size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size() ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] != word[j]) diff ++;</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff == <span class="number">1</span>) vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Share another java solution: we may firstly use BFS solution to get the distance of all nodes, and then use DFS to get the results.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs + dfs</span></span><br><span class="line">    <span class="comment">// bfs is responsible for find nodes and distance by level traversal</span></span><br><span class="line">    <span class="comment">// dfs is to find all results</span></span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; neighbors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bfs(beginWord, endWord, set, distance, neighbors);</span><br><span class="line">        <span class="comment">// System.out.println(neighbors);</span></span><br><span class="line">        <span class="comment">// System.out.println(distance);</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, distance, neighbors, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String startWord, String endWord, Set&lt;String&gt; allWords, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Map&lt;String, Set&lt;String&gt;&gt; neighbors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assume we have put start word in the start set</span></span><br><span class="line">        distance.put(startWord, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startWord);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">boolean</span> shouldEnd = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                String cur = queue.poll();</span><br><span class="line">                List&lt;String&gt; nexts = getNeighbors(cur, allWords);</span><br><span class="line">                neighbors.put(cur, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                <span class="keyword">for</span> (String next: nexts) &#123;</span><br><span class="line">                    neighbors.get(cur).add(next);</span><br><span class="line">                    <span class="keyword">if</span> (!distance.containsKey(next)) &#123;</span><br><span class="line">                        distance.put(next, level + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (next.equals(endWord)) &#123;</span><br><span class="line">                            shouldEnd = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue.offer(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldEnd) <span class="keyword">break</span>;</span><br><span class="line">            level ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String startWord, String endWord, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Map&lt;String, Set&lt;String&gt;&gt; neighbors, List&lt;String&gt; curList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startWord.equals(endWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(curList));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; nexts = neighbors.get(startWord);</span><br><span class="line">        <span class="keyword">if</span> (nexts == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (String next: nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance.get(next) != distance.get(startWord) +  <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            curList.add(next);</span><br><span class="line">            dfs(next, endWord, distance, neighbors, curList);</span><br><span class="line">            curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">                chs[i] = ch;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = old_ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="315-Android-Unlock-Patterns"><a href="#315-Android-Unlock-Patterns" class="headerlink" title=" 315 Android Unlock Patterns "></a><a id="315"> 315 Android Unlock Patterns </a></h3><p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.</p>
<p>This is a very interesting problem, and guess what, it must come form Google! So this problem is not hard to solve. As for the work flow and logic, you can use DFS and back-tracing; the hard part is to find all possible next integer for a specific integer. But it is still trivial, as there is only 9 grid in total. Also note that we do not have to do dfs for every entry in the 2D array as the array is symmetric.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// OMG this question in sl interesting!</span></span><br><span class="line">        <span class="comment">// the basic work flow: recursion (backtracing)</span></span><br><span class="line">        <span class="comment">// how can you determine if two number can be connected?</span></span><br><span class="line">        <span class="keyword">boolean</span> visited[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; 3; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         dfs(i, j, m, n, visited);</span></span><br><span class="line">        <span class="comment">//         // System.out.println();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="number">4</span> * dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, visited);</span><br><span class="line">        ans += <span class="number">4</span> * dfs(<span class="number">0</span>, <span class="number">1</span>, m, n, visited);</span><br><span class="line">        ans += dfs(<span class="number">1</span>, <span class="number">1</span>, m, n, visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (i &lt; 0 || i&gt;= 3 || j &lt; 0 || j &gt;= 3) return ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> new_min = Math.max(<span class="number">0</span>, min - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> new_max = max - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_min == <span class="number">0</span>) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_max == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span>[] middle = getMiddle(i, j, x, y);</span><br><span class="line">                <span class="keyword">if</span> (middle == <span class="keyword">null</span> || visited[middle[<span class="number">0</span>]][middle[<span class="number">1</span>]]) &#123;</span><br><span class="line">                    res += dfs(x, y, new_min, new_max, visited);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getMiddle(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = x0 + y0 + x1 + y1;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> diffx = Math.abs(x0-x1), diffy = Math.abs(y0-y1);</span><br><span class="line">        <span class="keyword">if</span> (diffx == <span class="number">1</span> &amp;&amp; diffy == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;(x1+x0)/<span class="number">2</span>, (y0+y1)/<span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title=" 139 Word Break "></a><a id="139"> 139 Word Break </a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>This is a typical DFS + memo problem. It is not hard to write down, but it is very basic.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// the recursion situation is like O(n!)</span></span><br><span class="line">        <span class="comment">// use dp</span></span><br><span class="line">        <span class="comment">// Time complexity: O(s.length() * wordDict.size()) in worst case</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">// dp[i] =&gt; substring(i)</span></span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> visit(s, <span class="number">0</span>, wordDict, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(String s, <span class="keyword">int</span> index, List&lt;String&gt; words, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[index] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[index] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if dp[index] == -1 -&gt; not visited</span></span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(word, index)) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex = index + word.length();</span><br><span class="line">                <span class="keyword">if</span> (visit(s, nextIndex, words, dp)) dp[index] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[index] == -<span class="number">1</span>) dp[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In fact, we do need to make it too complicated. A simple pass through DP is enough.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code is self-explanatory.</p>
<h3 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title=" 140 Word Break II "></a><a id="140"> 140 Word Break II </a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>In this case, the common solution is still DFS. But how can you save the results? Use the map.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> visit(s, wordDict, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">visit</span><span class="params">(String s, List&lt;String&gt; wordDict, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) <span class="keyword">return</span> map.get(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str: wordDict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(str)) &#123;</span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; tmp = visit(s.substring(str.length()), wordDict, map);</span><br><span class="line">                <span class="keyword">for</span> (String suffix: tmp) &#123;</span><br><span class="line">                    list.add(str + (suffix.length() &gt; <span class="number">0</span>? <span class="string">" "</span>: <span class="string">""</span>) + suffix);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(s, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="505-The-Maze-II"><a href="#505-The-Maze-II" class="headerlink" title=" 505 The Maze II "></a><a id="505"> 505 The Maze II </a></h3><p>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>This is a typical shortest path problem. For this problem, we have a generic solution:</p>
<p>Define “relax” an edge in the following code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e: G.adj(v)) &#123;</span><br><span class="line">         <span class="keyword">int</span> w = e.to(); <span class="comment">// w is another vertex connected by e</span></span><br><span class="line">         <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">            distTo[w] = distTo[v] + e.weight();</span><br><span class="line">            edgeTo[w] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we have a generic solution for shortest path: Initialize <code>distTo[s]</code> (<code>s</code> is the source/start of the graph) to 0 and all other <code>distTo[]</code> values to infinity, and proceed as follows: Relax any edge in this graph, continuing until no edges is eligible. For all vertices <code>w</code> reachable from <code>s</code>, the value of <code>distTo[w]</code> after this computation is the length of a shortest path from <code>s</code> to <code>w</code>.</p>
<p>We now have two solutions, DFS and BFS.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] m;</span><br><span class="line">    <span class="keyword">int</span>[] s;</span><br><span class="line">    <span class="keyword">int</span>[] d;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dfs + memo</span></span><br><span class="line">        m = maze;</span><br><span class="line">        s = start;</span><br><span class="line">        d = destination;</span><br><span class="line">        <span class="keyword">int</span> row = m.length, col = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[s[<span class="number">0</span>]][s[<span class="number">1</span>]] = <span class="number">1</span>; <span class="comment">// 0 is unvisited</span></span><br><span class="line">        dfs(s[<span class="number">0</span>], s[<span class="number">1</span>], dp);</span><br><span class="line">        <span class="keyword">return</span> dp[d[<span class="number">0</span>]][d[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we start from the start end, and visit all possible nodes in the current call</span></span><br><span class="line">        <span class="comment">// then update the dp matrix. We always choose the min distance</span></span><br><span class="line">        <span class="keyword">if</span> (i == d[<span class="number">0</span>] &amp;&amp; j == d[<span class="number">1</span>]) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diffx = dirs[p], diffy = dirs[p+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = i, y = j;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x + diffx &gt;= <span class="number">0</span> &amp;&amp; x + diffx &lt; m.length &amp;&amp; y + diffy &gt;= <span class="number">0</span> &amp;&amp; y + diffy &lt; m[<span class="number">0</span>].length</span><br><span class="line">                   &amp;&amp; m[x+diffx][y+diffy] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += diffx; y += diffy;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> newLength = dp[i][j] + len;</span><br><span class="line">            <span class="keyword">if</span> (dp[x][y] &gt; <span class="number">0</span> &amp;&amp; newLength &gt;= dp[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[x][y] = newLength;</span><br><span class="line">            dfs(x, y, dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we use the bfs to try!</span></span><br><span class="line">        <span class="comment">// If a node is updated, then put it in the queue again</span></span><br><span class="line">        <span class="comment">// This soluton could be modified to Dijkstra's algorithm!</span></span><br><span class="line">        <span class="comment">// we still have to use a distance matrix 2D</span></span><br><span class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d: distance) Arrays.fill(d, Integer.MAX_VALUE);</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start[<span class="number">0</span>], start[<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = cur[<span class="number">0</span>], j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] dirs = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> diffx = dirs[p], diffy = dirs[p+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x = i, y = j;</span><br><span class="line">                <span class="keyword">int</span> len = cur[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">while</span> (x + diffx &gt;= <span class="number">0</span> &amp;&amp; x + diffx &lt; maze.length &amp;&amp; y + diffy &gt;= <span class="number">0</span> &amp;&amp; y + diffy &lt; maze[<span class="number">0</span>].length</span><br><span class="line">                       &amp;&amp; maze[x+diffx][y+diffy] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x += diffx; y += diffy;</span><br><span class="line">                    len ++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This is a way to reduce extra operation</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distance[x][y] != <span class="number">0</span> &amp;&amp; distance[x][y] &gt; len) &#123;</span><br><span class="line">                    distance[x][y] = len;</span><br><span class="line">                    <span class="keyword">if</span> (x != destination[<span class="number">0</span>] || y != destination[<span class="number">1</span>]) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y, len&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE? -<span class="number">1</span>: res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Either solution is an instance of the generic solution to SP problem. BFS could be modified into Dijkstra’s algorithm then.</p>
</span> -->
        </article>
    
    

</div>


        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yihang (Ian) Ding | Powered by <i><a href="https://hexo.io" target="_blank">Hexo</a></i> & <i><a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></i></span>
    </div>
</footer>

    </div>
</body>
</html>
