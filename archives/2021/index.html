<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yihang (Ian) Ding">


    <meta name="subtitle" content="Glad you reach here.">




<title>Archives: 2021 | Yihang&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,700|Noto+Serif+KR:300,700|Source+Code+Pro:400,400i,700,700i&display=swap" rel="stylesheet">



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
            <a href="/">楽しんでね。| Yihang&#39;s Nest</a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">楽しんでね。| Yihang&#39;s Nest</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="post-wrap archive">
	<h1> ✐ | Post </h1>
</div>
<div class="post-wrap archive">
    
    
        

        
            <h1>2021</h1>
        

        <article class="archive-item">
            <a class="archive-item-link" href="/2021/03/13/How-to-design-a-delayed-scheduler-in-Java/">How to design a delayed scheduler in Java?</a>
            <span class="archive-item-date">Mar 13, 2021</span>
            <!-- <span style=> <p>Designing a delayed scheduler could be very interesting but challenging. Though in Java there are many built-in tools under the concurrency section, studying them on the code level is a really good practice.</p>
<p>The question here is to design a delayed scheduler that can accept a <code>Runnable</code> task with a delay. The task should be executed after the delay time.</p>
<p>At this moment, let’s forget a large scale scheduler on a distributed system. The scope right now is to implement such a class and an API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unit of delayTime is milliseconds</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">scheduler</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-1-PriorityQueue-polling"><a href="#Approach-1-PriorityQueue-polling" class="headerlink" title="Approach 1: PriorityQueue + polling"></a>Approach 1: <code>PriorityQueue</code> + polling</h3><p>A simple and intuitive solution is to maintain a priority queue which contains all tasks to be executed. The most urgent task will be at the peek of this queue. We then will have a thread which iteratively and periodically checking the peek task in the priority queue; then pop and run the task if needed. This is called <strong><em>polling</em></strong>.</p>
<p>A big issue with this approach is, how can we decide the period of polling?</p>
<ul>
<li>If the interval is too small, it will be a huge workload for the CPU;</li>
<li>If the interval is too large, the real execution time of a task might not be accurate (it will be delayed).</li>
</ul>
<h3 id="Approach-2-PriorityQueue-timer"><a href="#Approach-2-PriorityQueue-timer" class="headerlink" title="Approach 2: PriorityQueue + timer"></a>Approach 2: <code>PriorityQueue</code> + timer</h3><p>Instead of polling periodically, what we can do is: get the delay time of the current peek task, set a timer with the time, check again when the timer is up.</p>
<p>However, <strong>this is even worse compared with the approach 1</strong>. Why? Consider such a situation: now the peek element in the queue will be executed one hour later, so the timer will be up after 1 hour. However, after that a new task comes into the queue, and this task’s delay time is 30 minutes. Apparently, we are not able to execute this task after 30 minutes later as the thread blocks due to the timer.</p>
<h3 id="Approach-3-Let’s-look-into-DelayQueue-now"><a href="#Approach-3-Let’s-look-into-DelayQueue-now" class="headerlink" title="Approach 3: Let’s look into DelayQueue now!"></a>Approach 3: Let’s look into <code>DelayQueue</code> now!</h3><p>In Java we have a built-in queue called <code>DelayQueue</code>. This is exactly what we want! We will look into how it works by analyzing the source code, but firstly, let’s implement the delay scheduler with this class.</p>
<p>Let’s write a wrapper for the <code>Runnable</code> task.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);  <span class="comment">// null is the return value for the runnable tasks</span></span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.startTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.compare(<span class="keyword">this</span>.getDelay(), ((DelayTask) o).getDelay());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we need to implement <code>getDelay</code> and <code>compareTo</code> functions, as <code>Delayed</code> is in fact only an interface, which also implements <code>Comparable</code> interface.</p>
<p>Now, let’s implement the scheduler class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DelayQueue&lt;DelayTask&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.startExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        DelayTask newTask = <span class="keyword">new</span> DelayTask(task, delayTime);</span><br><span class="line">        <span class="keyword">this</span>.queue.offer(newTask);</span><br><span class="line">        <span class="keyword">return</span> newTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable execute = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    DelayTask task = <span class="keyword">this</span>.queue.take();</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTree();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(execute, <span class="string">"Executor"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code is really concise and self-explanatory, thanks to the good capsulation of this class. The source code of <code>DelayQueue</code> is not complicated but very delicate!</p>
<p>Below is the implementation of some core functions of this class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread designated to wait for the element at the head of</span></span><br><span class="line"><span class="comment">     * the queue.  This variant of the Leader-Follower pattern</span></span><br><span class="line"><span class="comment">     * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to</span></span><br><span class="line"><span class="comment">     * minimize unnecessary timed waiting.  When a thread becomes</span></span><br><span class="line"><span class="comment">     * the leader, it waits only for the next delay to elapse, but</span></span><br><span class="line"><span class="comment">     * other threads await indefinitely.  The leader thread must</span></span><br><span class="line"><span class="comment">     * signal some other thread before returning from take() or</span></span><br><span class="line"><span class="comment">     * poll(...), unless some other thread becomes leader in the</span></span><br><span class="line"><span class="comment">     * interim.  Whenever the head of the queue is replaced with</span></span><br><span class="line"><span class="comment">     * an element with an earlier expiration time, the leader</span></span><br><span class="line"><span class="comment">     * field is invalidated by being reset to null, and some</span></span><br><span class="line"><span class="comment">     * waiting thread, but not necessarily the current leader, is</span></span><br><span class="line"><span class="comment">     * signalled.  So waiting threads must be prepared to acquire</span></span><br><span class="line"><span class="comment">     * and lose leadership while waiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition signalled when a newer element becomes available</span></span><br><span class="line"><span class="comment">     * at the head of the queue or a new thread may need to</span></span><br><span class="line"><span class="comment">     * become leader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                E first = q.peek();</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> q.poll();</span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, we still use a priority queue to manage all tasks and the peek is the one with the shortest delay time. Instead of using polling or timer, we use the wait/notify(signal) to handle the concurrency problems. If there are many threading that blocks on <code>take()</code> functions (i.e., they are all waiting to get an element from the queue), we use a <strong><em>leader/follower</em></strong> pattern to efficiently minimize unnecessary timed waiting. The leader will only wait for the delay time of the peek element in the queue, while other threads need to wait until signaled.</p>
<p>Here are many design tricks that are deserved to be noticed.</p>
<blockquote>
<p>Q: In <code>offer()</code> function, why we need to check the peek with the element we just added?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.offer(e);</span><br><span class="line"><span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">    leader = <span class="keyword">null</span>;</span><br><span class="line">    available.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once we’ve added the element, if the peek element becomes the one we just added, it means the element will be earliest one to come out of the queue (this is exactly the issue that approach 2 cannot handle!). If we ignore it, no thread will be aware of it and the leader will still wait for the previous peek element!</p>
<p>To figure out how exactly it works, let’s go through one example. Suppose now the peek element’s name is A, and its delay is 1 hour. In addition, we have one or more thread blocking on <code>take()</code> because element A cannot be out until 1 hour later. The leader thread, say thread-1, blocks on <code>awaitNanos()</code> (or say, it is waiting for A to become available) and other threads (if any) are waiting until signal as either of them is not the leader:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br></pre></td></tr></table></figure>

<p>Now, a new element B comes in, and its delay time is only 10 minutes. According to the code, it will set <code>leader</code> to <code>null</code> and notify one of the waiting thread.</p>
<ol>
<li>If there is only one waiting thread, which is thread-1, then it will stop waiting (line 65), enter the while loop again, get the peek element again (<strong>now the peek element will be B</strong>), and finally starts waiting for B;</li>
<li>If there are more than one thread, which means we have followers, then the thread signaled is not necessarily thread-1!<ul>
<li>if thread-1 get signaled, then it is same with 1;</li>
<li>otherwise (<strong>here comes the tricky part</strong>), another thread, say thread-2, wakes up! Since <code>offer()</code> function also sets <code>leader</code> to <code>null</code>, so thread-2 will re-enter the loop in <code>take()</code> and becomes the leader, and it will also start to wait for B. As for thread-1, it will wake up once the timeout happens (1 hour) or signaled by other operations.</li>
</ul>
</li>
</ol>
<blockquote>
<p>Q: After one thread takes an element, why do we need to signal?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">        available.signal();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is in fact apparent: all follower threads are actually waiting infinitely, we must notify one of the threads if there is <strong>no leader</strong> but <strong>the queue has elements inside it</strong>. Generally, you can find that <code>available.signal()</code> is in fact to <strong>make sure there is a new when a newer element becomes available at the head of the queue or a new thread may need to become leader</strong> (this is the comment in the source code :P).</p>
<blockquote>
<p>Q: Why we need to do this: <code>first = null</code>?</p>
</blockquote>
<p>According to the Doug Lea’s comment after this line, we know this is to avoid memory leakage. If a thread (thread-1) is not the leader but it is still holding <code>first</code> in its thread, then after <code>first</code> is taken by the leader, it cannot be collected by Java GC (though it should be) as long as thread-1 keeps waiting.</p>
<blockquote>
<p>Q: When a thread start to waiting in the <code>take()</code> method, does it keep holding the lock?</p>
</blockquote>
<p>No, it will not. Note, <code>availability</code> is associated with the current lock!</p>
<p>The doc says:</p>
<blockquote>
<p><code>void await()
     throws InterruptedException</code><br>Causes the current thread to wait until it is signalled or interrupted.</p>
<p>The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</p>
<ul>
<li>Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</li>
<li>Some other thread invokes the signalAll() method for this Condition; or</li>
<li>Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</li>
<li>A “spurious wakeup” occurs.</li>
</ul>
<p>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock.</p>
</blockquote>
<h3 id="Approach-4-implement-a-delay-queue-by-ourselves"><a href="#Approach-4-implement-a-delay-queue-by-ourselves" class="headerlink" title="Approach 4: implement a delay queue by ourselves!"></a>Approach 4: implement a delay queue by ourselves!</h3><p>Okay, as we get clear with the mechanism of this class, we can totally implement the scheduler without <code>DelayQueue</code>. Some part of the codes will remain the same.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;DelayTask&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> PriorityBlockingQueue();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.available = <span class="keyword">this</span>.lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.startExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        DelayTask newTask = <span class="keyword">new</span> DelayTask(task, delayTime);</span><br><span class="line">        <span class="keyword">this</span>.offer(newTask);</span><br><span class="line">        <span class="keyword">return</span> newTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable execute = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    DelayTask task = <span class="keyword">this</span>.take();</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTree();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(execute, <span class="string">"Executor"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(DelayTask task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.offer(task);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queue.peek() == task) &#123;</span><br><span class="line">                <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DelayTask <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayTask peek = <span class="keyword">this</span>.queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (peek == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// no element at all, just wait!</span></span><br><span class="line">                    available.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = peek.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// not the leader, need to waits</span></span><br><span class="line">                        <span class="keyword">this</span>.available.await();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread curThread = Thread.currentThread();</span><br><span class="line">                        <span class="keyword">this</span>.leader = curThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (curThread == <span class="keyword">this</span>.leader) <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, this is still kind of overkilled. Why? Because we will not have multiple thread calling <code>take()</code> at the same time! Thus, we might not need to use the leader/follower pattern here, and we can simplify the code further.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedSchedulerSelfDev</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;DelayedTask&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(DelayedTask task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.offer(task);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">this</span>.queue.peek()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.available.signal();   <span class="comment">// wake up one thread (not all!)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DelayedTask <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayedTask peekTask = <span class="keyword">this</span>.queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (peekTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// no elemnets; wait!</span></span><br><span class="line">                    available.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = peekTask.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                    available.awaitNanos(delay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, you don’t need to maintain a <code>leader</code> thread now. The logic for <code>take()</code> is also much simpler: the thread either waits forever if there is no element (until signaled) or waits until the first element becomes available.</p>
<h3 id="Distributed-Scheduler"><a href="#Distributed-Scheduler" class="headerlink" title="Distributed Scheduler"></a>Distributed Scheduler</h3><p>Let’s talk about it in another post if we have time!</p>
</span> -->
        </article>
    
    

</div>


        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yihang (Ian) Ding | Powered by <i><a href="https://hexo.io" target="_blank">Hexo</a></i> & <i><a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></i></span>
    </div>
</footer>

    </div>
</body>
</html>
