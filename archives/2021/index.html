<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yihang (Ian) Ding">


    <meta name="subtitle" content="Glad you reach here.">




<title>Archives: 2021 | Yihang&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">


<link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,700|Noto+Sans+JP:300,700|Noto+Sans+KR:300,700|Source+Code+Pro:400,400i,700,700i|IBM+Plex+Mono:400,400i,600,600i&display=swap" rel="stylesheet">



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
            <a href="/">楽しんでね。| Yihang&#39;s Blog</a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">楽しんでね。| Yihang&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            <div class="post-wrap archive">
	<h1> ✐ | Post </h1>
</div>
<div class="post-wrap archive">
    
    
        

        
            <h1>2021</h1>
        

        <article class="archive-item">
            <a class="archive-item-link" href="/2021/12/06/liearizable/">What is &#34;linearizability&#34; in distributed systems?</a>
            <span class="archive-item-date">Dec 6, 2021</span>
            <!-- <span style=> <p>(This post is still in progress)</p>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2021/08/20/A-Closer-Look-to-a-Key-Value-Storage-Engine/">A Closer Look to a Key-Value Storage Engine</a>
            <span class="archive-item-date">Aug 20, 2021</span>
            <!-- <span style=> <p>“Please design a key-value storage engine”. You might hear this during a system design interview. While this question in fact is pretty, designing a storage engine is not easy. In this post, I want to start with some simple designs and principles and gradually approach a solution of a relatively complete key-value storage engine.</p>
<p>Please note that, though we mainly talk about key-value storage, many ideas and principles are widely used in many other database designs.</p>
<h1 id="Key-Value-in-Memory"><a href="#Key-Value-in-Memory" class="headerlink" title="Key-Value in Memory"></a>Key-Value in Memory</h1><p>Have you ever encountered any key-value storages in memory? Sure. <code>HashMap</code> and <code>TreeMap</code> in Java are two data structures for key-value storages only in memory. There are also a lot of other data structures to implement a in-memory key-value storage, such as AVL tree, skip list, etc.</p>
<h1 id="How-About-Data-on-Disk"><a href="#How-About-Data-on-Disk" class="headerlink" title="How About Data on Disk?"></a>How About Data on Disk?</h1><p>Here is a question: since we already some in-memory data structures for key-value storages, can we also use it for storage on disk?</p>
<h2 id="HashMap-Append-only-Log"><a href="#HashMap-Append-only-Log" class="headerlink" title="HashMap + Append-only Log"></a>HashMap + Append-only Log</h2><p>Let’s take the <code>HashMap</code> as one example. <code>HashMap</code> uses hash value of the key to index the data. Assume we are always appending data to a file on the disk, what we can do here is to maintain a in-memory hash map where every key is mapped to a byte offset in the data file, which is the location at which the value can be found. Whenever you append a new key-value pair to the file, you also update the hash map by adding or updating the offset.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key     offset</span><br><span class="line">123     0</span><br><span class="line">456     64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Though this method is pretty simple, some of its ideas are still pretty impressive, one of which is using append-only log to improve write.</p>
<p>Compared with in-memory key-value storage, the most important feature of an actual data storage is: it needs to be persistent. This is why we need to always write to the disk. For writes, <strong><em>it’s hard to beat the performance of simply appending to a file, as this is the simplest possible write operation</em></strong>. What is counterintuitive is, random write to memory is even <em>slower</em> than sequential read to disk, not to mention random write to disk. So, if you need to write to the disk with high performance, <strong>always use append-only write</strong>.</p>
<p>However, in terms of scalability, it is not hard to spot some downsides of this method:</p>
<ol>
<li>Append-only operation will grow the data size forever, so it is possible run out of the disk space, right?</li>
<li>If the number of keys of the hash map keeps growing, the data structure may not fit in the memory one day.</li>
</ol>
<p>Another downside of this approach is on range query. As the key is usually unordered, performance of range query might be pretty bad.</p>
<h2 id="Compaction-amp-Merging"><a href="#Compaction-amp-Merging" class="headerlink" title="Compaction &amp; Merging"></a>Compaction &amp; Merging</h2><p>How do we avoid eventually running out of disk space? A good solution is to break the log into segments of a certain size: if the log size reaches a limit, we close the current file (a segment) and all subsequent writes will go to a new file (a new segment). What we can do next is to perform <em>compaction</em> on these segment, which normally removes duplicate keys in the log and only keeps the most recent update for the key. As the size of a segment will be smaller after compaction, what we usually do is to also <em>merge</em> several segments at the same time as performing the compaction.</p>
<img src="Diagram-merge-compaction.svg" alt="compaction and merging" width="250"/>

<p>As shown in the picture above, segment 2 is newer than segment 1, so in the merging process, the data in segment 2 might also overwrite data in segment 1 (e.g., key “beef”).</p>
<p>For each of the segment, it may have its own in-memory hash map, mapping the keys to file offsets. If we want to look up a key, we can start with the most recent segment and its hash map; if the key is not present, we then check the second-most-recent, and so on. For write, we always write to the most recent segment and update its hash map.</p>
<p>To make this idea work in practice, some design details are also important in an actual implementation. For example:</p>
<blockquote>
<p>What is the file format for the log?</p>
</blockquote>
<p>Many formats are candidates, but probably it is better just to use a binary format, e.g., one encoding the length of a string in bytes, followed by the raw string. This format will remove all whitespaces.</p>
<blockquote>
<p>How can we delete a key/record?</p>
</blockquote>
<p>Similar to a simple write operation, when deleting a key, we may just need to append a special deletion record to the data file (usually called <strong><em>tombstone</em></strong>). In compaction and merging, all previous values of the deleted key before the tombstone should be discarded.</p>
<blockquote>
<p>What if crash happens or the machine is restarted, all in-memory hash maps (indices) will be lost. How can we recover them?</p>
</blockquote>
<p>We can also reconstruct the in-memory hash maps with the in-disk data, but it might take a long time if the segment files are large. A better method might be storing a snapshot of each segment’s hash map on disk. This may speed up recovery.</p>
<p>We still have a lot of designs or features to talk about (e.g., concurrency control) but will stop here. Coming back to the design itself, we still left some problem unsolved: the hash tables must fit in memory and it will be a problem if the has maps are large. Also, range querying have low efficiency.</p>
<h2 id="SSTables-and-LSM-Tree"><a href="#SSTables-and-LSM-Tree" class="headerlink" title="SSTables and LSM-Tree"></a>SSTables and LSM-Tree</h2><p>In this chapter, we will discuss some ideas brought by LevelDB, an open-source database engine by <a href="https://github.com/google/leveldb" target="_blank" rel="noopener">Google</a>. The basic idea is still to use append-log segment files (we will call them <strong><em>log structured storage segment</em></strong> from now) and to construct an in-memory index, but we have many other actions to resolve the scalability and range query issues.</p>
<p>Let’s start with a simple change to the format of our segment files: we require that the sequence of key-value pairs is <em>sorted by key</em>. Wait, won’t it break our ability to use sequential writes? No worry, let’s get to that in a moment.</p>
<p>This kind of format is simple called <em>Sorted String Table</em>, or just <em>SSTable</em>. Another requirement we want to put here is: in each segment file, one key will only appear once. The compaction and merging (or say, compression) process already ensures that. You might some exceptions in some cases (such as in LevelDB) but let’s assume it is always true now.</p>
<p>There are several benefits of doing this:</p>
<ol>
<li>While range query becomes more possible, merging segment is also simple and efficient. The approach is really similar to the one used in the <em>merge sort</em> algorithm. If we find a key exists in multiple segments during merging, we should always keep the key-value pair from the most recent segment and abandon those from older segments.</li>
<li>As keys are sorted, you don’t need to keep an index of all keys in memory. Instead, a sparse index could be used. For example, if you want to look up the key <code>bike</code>, you probably cannot determine the offset of this key just by looking up the hash map below, but you do know the key is between <code>bee</code> and <code>bored</code> (by a simple binary search), so you can jump to the offset for <code>bee</code> and scan from there until you find the key (you might not find it, and it is easy to know).</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key           byte offset</span><br><span class="line">...           ...</span><br><span class="line">b             100491</span><br><span class="line">bee           102134</span><br><span class="line">bored         104667</span><br><span class="line">bury          106812</span><br><span class="line">...           ...</span><br></pre></td></tr></table></figure>

<p>With this assumption, let’s consider how can we maintain SSTables while writes can occur in any order.</p>
<p>As we know, maintaining a sorted structure on disk is hard (though it is still possible, such as B-Tree), but it is easy to do it in memory (we already discussed this), such as AVL tree and read-black tree. We can do the following (also see the picture below):</p>
<ol>
<li>When a write comes in, add it to the in-memory sorted hash map. This hash map is called <strong><em>memtable</em></strong>.</li>
<li>The memtable might grow larger gradually. When the size of the hash map reaches a limit, it will become an immutable memtable. While we can create a new empty memtable for new incoming writes, we will also write out the immutable memtable to disk as an SSTable file. This is easy, as the in-memory data structure already maintains the order of all keys. The new SSTable will become the most recent SSTable.</li>
<li>For read requests, we will first find it in the memtable (this could be pretty fast). If not present, we start with the most recent SST file, and the second-most-recent SST file, and so on. Each SST file could have a in-memory index in memory to help up find a key, but we also have other better ways to help look-up (will talk about it later).</li>
</ol>
<img src="Diagram-LevelDB.svg" alt="compaction and merging"/>

<p>We also need to compress SSTable files regularly. In <a href="https://github.com/google/leveldb/blob/master/doc/impl.md" target="_blank" rel="noopener">Google’s LevelDB</a>, it uses a level-structured architecture to manage all SSTable files. By saying that, when writing the immutable memtable to the disk, we will write it to <strong>level 0</strong> (or called young level). On young level, SST files may contain overlapping keys (as they are directly from memtable), but we make sure on level 1 and higher, SST files on each level have distinct non-overlapping key ranges. This is achieved by the compaction process described below:</p>
<blockquote>
<p>When the size of level L exceeds its limit, we compact it in a background thread. The compaction picks a file from level <strong>L and all overlapping files from the next level L+1</strong>. Note that if a level-L file overlaps only part of a level-(L+1) file, the entire file at level-(L+1) is used as an input to the compaction and will be discarded after the compaction. Aside: because level-0 is special (files in it may overlap each other), we treat compactions from level-0 to level-1 specially: a level-0 compaction may pick more than one level-0 file in case some of these files overlap each other.<br><br>A compaction merges the contents of the picked files to produce a sequence of level-(L+1) files. We switch to producing a new level-(L+1) file after the current output file has reached the target file size (2MB). We also switch to a new output file when the key range of the current output file has grown enough to overlap more than ten level-(L+2) files. This last rule ensures that a later compaction of a level-(L+1) file will not pick up too much data from level-(L+2).<br><br>The old files are discarded and the new files are added to the serving state.<br><br>Compactions for a particular level rotate through the key space. In more detail, for each level L, we remember the ending key of the last compaction at level L. The next compaction for level L will pick the first file that starts after this key (wrapping around to the beginning of the key space if there is no such file).<br><br>Compactions drop overwritten values. They also drop deletion markers if there are no higher numbered levels that contain a file whose range overlaps the current key.</p>
</blockquote>
<p>You may also notice that, what if the machine crashes and all in-memory data gets lost? In this case, we will use write-ahead-log (WAL) to protect the data. <strong>We will append a log to the log file on disk before we make any updates to the memtable</strong>. Thus, even the machine crashes unexpectedly, we can still recover the memtable with the log file. The log file is also an append-only file so writing to it could be fast. Please note that, when we write the memtable into a SSTable file on disk, the corresponding log file will also be discarded. A new log file will be initialized along with the new memtable.</p>
<p>This algorithm and some similar storage engines are used in Cassandra and HBase, both of which were inspired by Google’s Bigtable paper (this paper introduces the idea of <em>memtable</em> and <em>SSTable</em>). The indexing structure is also called <strong><em>Log-Structured Merge-Tree</em></strong> (or just LSM-Tree). Storage engines that are based on this principle of merging and compacting sorted files are often called LSM storage engines.</p>
<h1 id="Other-Design-Details"><a href="#Other-Design-Details" class="headerlink" title="Other Design Details"></a>Other Design Details</h1><p>Coming back to LevelDB, there are many other design details we need to have a look, as it also affects the performance of the database system.</p>
<h2 id="Manifest-file"><a href="#Manifest-file" class="headerlink" title="Manifest file"></a>Manifest file</h2><p>For all SSTable files, there is a manifest file that lists the set of sorted SSTables on each level. It records some important metadata of each SSTable, such as the file’s name and the key range.</p>
<p>Manifest fils might be useful when we look up a key among all SSTable files. When a key is not present in the memtable and we need to find it in SSTable files, manifest file can improve this process:</p>
<ul>
<li>Manifest file might contain the key range of each SSTable. If the key is not within that range, we can quickly know that we can skip this SSTable file and go ahead with the next one.</li>
<li>Starting from level 1, all SSTables on a single level will not have overlapping key range. Thus, <strong>there will only be one SSTable file that might have the key</strong>. A simple binary search might determine which SSTable we should look into for this key.</li>
</ul>
<h2 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h2><p>It is apparent that the write performance is good in LevelDB, thanks to the LSM-tree, but read performance might be bad, as we might need to check more than one SSTable to find a key’s value. Bloom filter is a way to improve read operations.</p>
<p>A bloom filter is a memory-efficient data structure for <strong><em>approximately</em></strong> the contents of a set. Basically,</p>
<ul>
<li>if it says “the key doesn’t exist”, then they key must not exist in the database;</li>
<li>if it says “the key exists”, then the key <strong><em>may</em></strong> exist in the database, and we need to go to the memtable or SSTables to find out the truth.</li>
</ul>
<p>In fact, the implementation of a bloom filter could be really easy. Another similar data structure is <em>count-min sketch</em>, though they are suitable in different use cases (we will not dive deep here). The most important benefit of a bloom filter is, if a key does not exist, it can avoid all unnecessary lookups and return the result immediately.</p>
<h2 id="Other-improvements"><a href="#Other-improvements" class="headerlink" title="Other improvements"></a>Other improvements</h2><p>There are some other ways to improve the performance:</p>
<ol>
<li>Cache. It’s possible to cache some SSTables in memory;</li>
<li>Sparse index or full index of each SSTables can be stored in the memory for fast lookup.</li>
</ol>
<h1 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h1><p>While the LSM-tree is the main focus in this post, the most popular indexing data structure is, however, B-tree. We mentioned B-tree earlier in this post, and it is always instructive to compare B-tree and LSM-tree.</p>
<p><strong>B-tree is almost the standard index implementation in almost all relational databases</strong>, and some non-relational database systems. B-tree also keeps key-value pair sorted by key, but the mechanism is pretty different from LSM-tree. Briefly speaking, B-tree is able to maintain a on-disk tree structure to index the data. To find a key and its value, we normally start with the root <em>page</em> and go all the way to a leaf node (of the key) or a position which indicates the absence of the key. If we want to write a key and its value, we will use the similar method to find the key, change the value in that page, and write back to disk. If a new key is added, the tree structure might be adjusted (split, merge, …).</p>
<h2 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h2><p>In contrast to LSM-tree, when writing to a key in a B-tree, we usually change <strong><em>in place</em></strong>, which it is just an appending operation in LSM-tree. In B-tree, you need to find the page that contains the key and then overwrite the page with the new value. The tree’s structure normally will not be changed and all references to the modified page will not be changed either.</p>
<p>However, a write operation, in some cases, might involve some additional work (this is always called write amplification/multiplication). For example, if the key is absent and you insert it, you might need to split the page to two new ones if the page becomes too big. If it happens, you also need to update the references in their parent pages, which, however, could be dangerous: what if the database crashes after the whole process get completed?</p>
<p>A widely used solution for this problem is write-ahead log (WAL). Another possible issue is concurrency. For this problem, applying some latches (lightweight locks) might work.</p>
<p>As a whole, you will find that, in this regard, LSM-tree is much better: appending to log is simpler than writing in place; the background compaction process can be greatly isolated from the incoming queries.</p>
<h2 id="B-tree-VS-LSM-tree"><a href="#B-tree-VS-LSM-tree" class="headerlink" title="B-tree VS LSM-tree"></a>B-tree VS LSM-tree</h2><p>The most intuitive performance difference between these two data structures is: B-tree is good for read operation while LSM-tree is generally faster for write operations. Of course, benchmarking always varies as the actual performance is sensitive to implementation details and workload. Let’s see something that you might be interested when measuring the performance of a storage engine.</p>
<h3 id="Advantages-of-LSM-trees"><a href="#Advantages-of-LSM-trees" class="headerlink" title="Advantages of LSM-trees"></a>Advantages of LSM-trees</h3><p>Typically, a LST-tree is able to sustain higher write throughput then a B-tree, <em>partly</em> because it normally involves lower write amplification. Note that LSM-tree also has write amplification, such as compaction/merging process, but this can always be in the background and incoming writes will not be affected: this promises high write throughput.</p>
<p>A LSM-tree also compressed better, and it always produce smaller files on disk than a B-tree. In a B-tree, some space in a page might be unused so fragmentation is more serious.</p>
<h3 id="Downsides-of-LSM-trees"><a href="#Downsides-of-LSM-trees" class="headerlink" title="Downsides of LSM-trees"></a>Downsides of LSM-trees</h3><p>The most serious downside of a LSM-tree is that the write bandwidth has to be shared the initial write and the compaction threads running in the background. It could be pretty bad when the write throughout gets high: the compaction might not be able to keep up with the rate of the incoming writes. It even gets worse later: the number of unmerged segments (SSTable files) on disk keeps growing and you will run out of the disk space finally. The performance will also get worse as there are now more segments to check in order to find the key.</p>
<p>Another concern arises when a transaction happens, where there are multiple operations in a single transaction. In a B-tree, a key will only exactly exist in one place, but might be copied several times in a LSM-tree. Transaction isolation can be easily implemented using locks on a B-tree, which could be hard on a LSM-tree.</p>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2021/03/13/How-to-design-a-delayed-scheduler-in-Java/">How to design a delayed scheduler in Java?</a>
            <span class="archive-item-date">Mar 13, 2021</span>
            <!-- <span style=> <p>Designing a delayed scheduler could be very interesting but challenging. Though in Java there are many built-in tools under the concurrency section, studying them on the code level is a really good practice.</p>
<p>The question here is to design a delayed scheduler that can accept a <code>Runnable</code> task with a delay. The task should be executed after the delay time.</p>
<p>At this moment, let’s forget a large scale scheduler on a distributed system. The scope right now is to implement such a class and an API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unit of delayTime is milliseconds</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">scheduler</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-1-PriorityQueue-polling"><a href="#Approach-1-PriorityQueue-polling" class="headerlink" title="Approach 1: PriorityQueue + polling"></a>Approach 1: <code>PriorityQueue</code> + polling</h3><p>A simple and intuitive solution is to maintain a priority queue which contains all tasks to be executed. The most urgent task will be at the peek of this queue. We then will have a thread which iteratively and periodically checking the peek task in the priority queue; then pop and run the task if needed. This is called <strong><em>polling</em></strong>.</p>
<p>A big issue with this approach is, how can we decide the period of polling?</p>
<ul>
<li>If the interval is too small, it will be a huge workload for the CPU;</li>
<li>If the interval is too large, the real execution time of a task might not be accurate (it will be delayed).</li>
</ul>
<h3 id="Approach-2-PriorityQueue-timer"><a href="#Approach-2-PriorityQueue-timer" class="headerlink" title="Approach 2: PriorityQueue + timer"></a>Approach 2: <code>PriorityQueue</code> + timer</h3><p>Instead of polling periodically, what we can do is: get the delay time of the current peek task, set a timer with the time, check again when the timer is up.</p>
<p>However, <strong>this is even worse compared with the approach 1</strong>. Why? Consider such a situation: now the peek element in the queue will be executed one hour later, so the timer will be up after 1 hour. However, after that a new task comes into the queue, and this task’s delay time is 30 minutes. Apparently, we are not able to execute this task after 30 minutes later as the thread blocks due to the timer.</p>
<h3 id="Approach-3-Let’s-look-into-DelayQueue-now"><a href="#Approach-3-Let’s-look-into-DelayQueue-now" class="headerlink" title="Approach 3: Let’s look into DelayQueue now!"></a>Approach 3: Let’s look into <code>DelayQueue</code> now!</h3><p>In Java we have a built-in queue called <code>DelayQueue</code>. This is exactly what we want! We will look into how it works by analyzing the source code, but firstly, let’s implement the delay scheduler with this class.</p>
<p>Let’s write a wrapper for the <code>Runnable</code> task.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelayTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable task;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayTask</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);  <span class="comment">// null is the return value for the runnable tasks</span></span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.startTime = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.startTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> unit.convert(diff, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.compare(<span class="keyword">this</span>.getDelay(), ((DelayTask) o).getDelay());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we need to implement <code>getDelay</code> and <code>compareTo</code> functions, as <code>Delayed</code> is in fact only an interface, which also implements <code>Comparable</code> interface.</p>
<p>Now, let’s implement the scheduler class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DelayQueue&lt;DelayTask&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.startExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        DelayTask newTask = <span class="keyword">new</span> DelayTask(task, delayTime);</span><br><span class="line">        <span class="keyword">this</span>.queue.offer(newTask);</span><br><span class="line">        <span class="keyword">return</span> newTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable execute = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    DelayTask task = <span class="keyword">this</span>.queue.take();</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTree();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(execute, <span class="string">"Executor"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code is really concise and self-explanatory, thanks to the good capsulation of this class. The source code of <code>DelayQueue</code> is not complicated but very delicate!</p>
<p>Below is the implementation of some core functions of this class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread designated to wait for the element at the head of</span></span><br><span class="line"><span class="comment">     * the queue.  This variant of the Leader-Follower pattern</span></span><br><span class="line"><span class="comment">     * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to</span></span><br><span class="line"><span class="comment">     * minimize unnecessary timed waiting.  When a thread becomes</span></span><br><span class="line"><span class="comment">     * the leader, it waits only for the next delay to elapse, but</span></span><br><span class="line"><span class="comment">     * other threads await indefinitely.  The leader thread must</span></span><br><span class="line"><span class="comment">     * signal some other thread before returning from take() or</span></span><br><span class="line"><span class="comment">     * poll(...), unless some other thread becomes leader in the</span></span><br><span class="line"><span class="comment">     * interim.  Whenever the head of the queue is replaced with</span></span><br><span class="line"><span class="comment">     * an element with an earlier expiration time, the leader</span></span><br><span class="line"><span class="comment">     * field is invalidated by being reset to null, and some</span></span><br><span class="line"><span class="comment">     * waiting thread, but not necessarily the current leader, is</span></span><br><span class="line"><span class="comment">     * signalled.  So waiting threads must be prepared to acquire</span></span><br><span class="line"><span class="comment">     * and lose leadership while waiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition signalled when a newer element becomes available</span></span><br><span class="line"><span class="comment">     * at the head of the queue or a new thread may need to</span></span><br><span class="line"><span class="comment">     * become leader.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            q.offer(e);</span><br><span class="line">            <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">                leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                E first = q.peek();</span><br><span class="line">                <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> q.poll();</span><br><span class="line">                    first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                        available.await();</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                                leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">                available.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, we still use a priority queue to manage all tasks and the peek is the one with the shortest delay time. Instead of using polling or timer, we use the wait/notify(signal) to handle the concurrency problems. If there are many threading that blocks on <code>take()</code> functions (i.e., they are all waiting to get an element from the queue), we use a <strong><em>leader/follower</em></strong> pattern to efficiently minimize unnecessary timed waiting. The leader will only wait for the delay time of the peek element in the queue, while other threads need to wait until signaled.</p>
<p>Here are many design tricks that are deserved to be noticed.</p>
<blockquote>
<p>Q: In <code>offer()</code> function, why we need to check the peek with the element we just added?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">q.offer(e);</span><br><span class="line"><span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">    leader = <span class="keyword">null</span>;</span><br><span class="line">    available.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Once we’ve added the element, if the peek element becomes the one we just added, it means the element will be earliest one to come out of the queue (this is exactly the issue that approach 2 cannot handle!). If we ignore it, no thread will be aware of it and the leader will still wait for the previous peek element!</p>
<p>To figure out how exactly it works, let’s go through one example. Suppose now the peek element’s name is A, and its delay is 1 hour. In addition, we have one or more thread blocking on <code>take()</code> because element A cannot be out until 1 hour later. The leader thread, say thread-1, blocks on <code>awaitNanos()</code> (or say, it is waiting for A to become available) and other threads (if any) are waiting until signal as either of them is not the leader:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">    available.await();</span><br></pre></td></tr></table></figure>

<p>Now, a new element B comes in, and its delay time is only 10 minutes. According to the code, it will set <code>leader</code> to <code>null</code> and notify one of the waiting thread.</p>
<ol>
<li>If there is only one waiting thread, which is thread-1, then it will stop waiting (line 65), enter the while loop again, get the peek element again (<strong>now the peek element will be B</strong>), and finally starts waiting for B;</li>
<li>If there are more than one thread, which means we have followers, then the thread signaled is not necessarily thread-1!<ul>
<li>if thread-1 get signaled, then it is same with 1;</li>
<li>otherwise (<strong>here comes the tricky part</strong>), another thread, say thread-2, wakes up! Since <code>offer()</code> function also sets <code>leader</code> to <code>null</code>, so thread-2 will re-enter the loop in <code>take()</code> and becomes the leader, and it will also start to wait for B. As for thread-1, it will wake up once the timeout happens (1 hour) or signaled by other operations.</li>
</ul>
</li>
</ol>
<blockquote>
<p>Q: After one thread takes an element, why do we need to signal?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">        available.signal();</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is in fact apparent: all follower threads are actually waiting infinitely, we must notify one of the threads if there is <strong>no leader</strong> but <strong>the queue has elements inside it</strong>. Generally, you can find that <code>available.signal()</code> is in fact to <strong>make sure there is a new when a newer element becomes available at the head of the queue or a new thread may need to become leader</strong> (this is the comment in the source code :P).</p>
<blockquote>
<p>Q: Why we need to do this: <code>first = null</code>?</p>
</blockquote>
<p>According to the Doug Lea’s comment after this line, we know this is to avoid memory leakage. If a thread (thread-1) is not the leader but it is still holding <code>first</code> in its thread, then after <code>first</code> is taken by the leader, it cannot be collected by Java GC (though it should be) as long as thread-1 keeps waiting.</p>
<blockquote>
<p>Q: When a thread start to waiting in the <code>take()</code> method, does it keep holding the lock?</p>
</blockquote>
<p>No, it will not. Note, <code>availability</code> is associated with the current lock!</p>
<p>The doc says:</p>
<blockquote>
<p><code>void await()
     throws InterruptedException</code><br>Causes the current thread to wait until it is signalled or interrupted.</p>
<p>The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</p>
<ul>
<li>Some other thread invokes the signal() method for this Condition and the current thread happens to be chosen as the thread to be awakened; or</li>
<li>Some other thread invokes the signalAll() method for this Condition; or</li>
<li>Some other thread interrupts the current thread, and interruption of thread suspension is supported; or</li>
<li>A “spurious wakeup” occurs.</li>
</ul>
<p>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock.</p>
</blockquote>
<h3 id="Approach-4-implement-a-delay-queue-by-ourselves"><a href="#Approach-4-implement-a-delay-queue-by-ourselves" class="headerlink" title="Approach 4: implement a delay queue by ourselves!"></a>Approach 4: implement a delay queue by ourselves!</h3><p>Okay, as we get clear with the mechanism of this class, we can totally implement the scheduler without <code>DelayQueue</code>. Some part of the codes will remain the same.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;DelayTask&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> Thread leader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> PriorityBlockingQueue();</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">this</span>.available = <span class="keyword">this</span>.lock.newCondition();</span><br><span class="line">        <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.startExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delayTime)</span> </span>&#123;</span><br><span class="line">        DelayTask newTask = <span class="keyword">new</span> DelayTask(task, delayTime);</span><br><span class="line">        <span class="keyword">this</span>.offer(newTask);</span><br><span class="line">        <span class="keyword">return</span> newTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable execute = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    DelayTask task = <span class="keyword">this</span>.take();</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTree();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(execute, <span class="string">"Executor"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(DelayTask task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.offer(task);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.queue.peek() == task) &#123;</span><br><span class="line">                <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DelayTask <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayTask peek = <span class="keyword">this</span>.queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (peek == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// no element at all, just wait!</span></span><br><span class="line">                    available.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = peek.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// not the leader, need to waits</span></span><br><span class="line">                        <span class="keyword">this</span>.available.await();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread curThread = Thread.currentThread();</span><br><span class="line">                        <span class="keyword">this</span>.leader = curThread;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (curThread == <span class="keyword">this</span>.leader) <span class="keyword">this</span>.leader = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, this is still kind of overkilled. Why? Because we will not have multiple thread calling <code>take()</code> at the same time! Thus, we might not need to use the leader/follower pattern here, and we can simplify the code further.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedSchedulerSelfDev</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;DelayedTask&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(DelayedTask task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.queue.offer(task);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">this</span>.queue.peek()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.available.signal();   <span class="comment">// wake up one thread (not all!)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DelayedTask <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayedTask peekTask = <span class="keyword">this</span>.queue.peek();</span><br><span class="line">                <span class="keyword">if</span> (peekTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// no elemnets; wait!</span></span><br><span class="line">                    available.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> delay = peekTask.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.queue.poll();</span><br><span class="line">                    available.awaitNanos(delay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see, you don’t need to maintain a <code>leader</code> thread now. The logic for <code>take()</code> is also much simpler: the thread either waits forever if there is no element (until signaled) or waits until the first element becomes available.</p>
<h3 id="Distributed-Scheduler"><a href="#Distributed-Scheduler" class="headerlink" title="Distributed Scheduler"></a>Distributed Scheduler</h3><p>Let’s talk about it in another post if we have time!</p>
</span> -->
        </article>
    
    

</div>


        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yihang (Ian) Ding | Powered by <i><a href="https://hexo.io" target="_blank">Hexo</a></i> & <i><a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></i></span>
    </div>
</footer>

    </div>
</body>
</html>
