# 315 Merge Sort 一个很典型的应用

### 315 Count of Smaller Numbers After Self

You are given an integer array `nums` and you have to return a new counts array. The counts array has the property where `counts[i]` is the number of smaller elements to the right of `nums[i]`.
    
    Input: [5,2,6,1]
    Output: [2,1,1,0] 
    Explanation:
    To the right of 5 there are 2 smaller elements (2 and 1).
    To the right of 2 there is only 1 smaller element (1).
    To the right of 6 there is 1 smaller element (1).
    To the right of 1 there is 0 smaller element.

这是一个很典型的merge sort的应用。先看解法。

```java
class Solution {
    
    // use to record the result
    private int[] count;
    
    public List<Integer> countSmaller(int[] nums) {
        // This a very clever solution using merge sort!!!
        // please refer to your own markdown note for this problem
        List<Integer> res = new ArrayList<>();
        int n = nums.length;
        count = new int[n];
        int[] index = new int[n];
        
        // record the initial index of the array and
        // WE ONLY SORT THIS ARRAY!
        for (int i = 0; i < n; i++) index[i] = i;  
        mergeSort(nums, index, 0, n-1);
        
        for (int i = 0; i < n; i ++) res.add(count[i]);
        
        return res;
        
    }
    
    private void mergeSort(int[] nums, int [] index, int start, int end) {
        if (start < end) {
            int mid = (end + start) / 2;
            mergeSort(nums, index, start, mid);
            mergeSort(nums, index, mid+1, end);
            merge(nums, index, start, end);
        }
    }
    
    private void merge(int[] nums, int[] index, int start, int end) {
        int mid = (end+start)/2;
        int l = start, r = mid+1; // the starting index of every array;
        int countInt = 0;
        int p = 0; // the index pointer of newIndex
        int[] newIndex = new int[end - start + 1];  // the temp array for sorted index
        
        while (l <= mid && r <= end) { // 
            if (nums[index[r]] < nums[index[l]]) { // get an entry from the right array
                newIndex[p] = index[r];
                countInt ++;
                r ++;
            } else { // get an entry for the left array
                newIndex[p] = index[l];
                count[index[l]] += countInt;
                l++;
            }
            p ++; 
        }
        
        while (l <= mid) {
            newIndex[p++] = index[l];
            count[index[l++]] += countInt;
        }
        
        while (r <= end) {
            newIndex[p++] = index[r++];
        }
        
        for (int i = 0; i < newIndex.length; i ++) {
            index[start + i] = newIndex[i];
        }
    }
}
```    

注意一下几点:

#### 只对`index`排序？

为了操作方便，这里不对`nums`本身排序，而只对index这个排序。因为并不要求利用排序的结果，并且，只对`index`排序就已经足够了。

#### 在merge的时候只会右边的子数组计数？

这个问题，可以看这样的一个例子。

假设在最后一次merge的时候数组是（假设`nums`也被排序了）：

    [5,9,15,16,2,3,7,13]
    
按照merge的规则，先取到的是`2`和`3`，`count = 2`。下一个取出的就是`5`,而且已经知道的是，之前从右边取出来的肯定是比自己小的，所以，这里就可以赋值了。这就是这个算法的核心思想。

那么为什么右边的元素不管呢？很简单，比如说这个2，在原始数据中的index只可能是4-7（按照divide and conquer的原则），所以0-3的元素不会对其有影响。其他的右边数组中的元素也一样。当然了，2还是对应的`count`中的值还是可能不为0的，但是满足“在其右边比其小的数”，只可能在原始index为4-7的位置，**在最后一次的merge开始的时候，这个计数已经完成了**。

这其实是conquer and divide的一个过程，在把小问题转变成大问题的时候，需要考虑两个小问题的解之间会不会有影响。在这里，就是右边问题的解会影响左边，但是反过来则不会。

-

### 315 Count of Smaller Numbers After Self

Given an integer array `nums`, return the number of range sums that lie in `[lower, upper]` inclusive.
Range sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` (`i` ≤ `j`), inclusive.
    
    Input: nums = [-2,5,-1], lower = -2, upper = 2,
    Output: 3 
    Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.

这个题目其实和上面是非常相似的，只不过，在merge的时候，上面是要在merge的时候找计数，而这里相对要复杂一点。

```java
class Solution {
    public int countRangeSum(int[] nums, int lower, int upper) {
        // 同类题：315 count of smaller numbers after self
        // merge sort 的另一个典型应用
        int n = nums.length;
        long[] sums = new long[n+1];
        for (int i = 1; i <= n; i++) {
            sums[i] = sums[i-1] + nums[i-1];
        }
        
        return merge(sums, 0, n, lower, upper);
    }
    
    private int merge(long sums[], int start, int end, int lower, int upper) {
        
        if (start >= end) return 0;
        int mid = start + (end - start) / 2;
        int count = merge(sums, start, mid, lower, upper) + merge(sums, mid+1, end, lower, upper);
        long[] cache = new long[end - start + 1];
        int r = 0; // r is the entry for cache
        int m = mid + 1, n = mid + 1, p = mid + 1; // mid + 1 is the starting entry of the right half
        for (int i= start; i <= mid; i++) {
            while (m <= end && sums[m] - sums[i] < lower) m++;
            while (n <= end && sums[n] - sums[i] <= upper) n++;
            
            // merge
            while (p <= end && sums[p] < sums[i]) {
                cache[r++] = sums[p++];
            }
            cache[r++] = sums[i];
            count += n - m;
        }
        System.arraycopy(cache, 0, sums, start, p - start);
        
        return count;
    }
}
```