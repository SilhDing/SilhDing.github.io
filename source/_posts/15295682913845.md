## Union find 总结

这是一个用的还算很多的算法。专题探讨一下。

[TOC]

### 动态链接 Dynamic connectivity

定义一个概念：**连接**。通常我们说`p`和`q`是相连的话，那么反过来也是成立的，要是`q`和`r`也是相连的，那么`p`和`r`也是相连的。要是有很多的对象，connectivity会把这些对象氛围很多类。

术语：sites, connections, connected components (components)

如果用一个网络图表示connectivity，那么还是能够用肉眼看到一个信息的，但是对于程序而言，只有site的名字和connections，也没有几何图形， 该怎么判断两个sites是不是connected的呢？

先定义API：

    Public class UF
        UF(int N) // constructor where N is the name(number) of site
        void union(int p, int q) // add connection
        int find(int p) / component identifier for p (0 ~ N-1)
        boolean connected (int p, int q) // return true if they are connected (in the same component)
        int count() // number of components (not the number of sites)
        
注意`find`函数的作用是找到一个给定的site的component identifier。对于`count`而言，我们从`N`开始，每当两个来自不同components的site连接后，`count`数目减1。

现在就要实现数据结构和算法了。

#### 基本实现结构

```java
public class UF {
    private int[] id;
    private int count;

    public UF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    private int find(int p) {}
    // fill here 
    
    public void union(int p, int q) {}
    // fill here
}
```

那么接下来只需要实现`find()`和`unoin()`就可以了。


### Implementations

先看集中不同的实现方法，都基于`id[]`这个序列，来检测两个site是不是在一个components之内。

#### Quick-find

**基本的想法是，一个component内的所有的sits都有相同的`id[]`值。**这样的话，查找的速度其实很快，因为只要简单return一下`id[]`的值就可以了。而在connect操作的时候，需要把两个site坐在的component所有的sites都设置为同样的`id[]`。


```java
private int find(int p) {
    return id[p];
}
    
public void union(int p, int q) {
    // here we use the id of q 
    // as the new id for all sites in the combined component
    int pID = id[p];
    int qID = id[q];

    if (pID == qID) return ;

    for (int i = 0; i < id.length; i++) {
        if (id[i] == pID) id[i] = qID;
    }

    count --; 
}
```

分析这个算法：

1. `find()`很快没有任何疑问，因为只会访问`id[]`一次。但是`union()`会非常耗时，因为每次都要扫描。**命题：**这个算法每次会访问数组一次完成`find()`操作，但是完成`union()`操作需要访问数组`N + 3`到`2 * N + 1`次。因为要执行`union()`的话，首先要访问数组两次，然后要测试数组中的`N`和元素，其中有`1 ~ N-1`个元素的值可能会被改变。

2. 假如现在的目的是最后只有一个component，那么也就是说union的操作有N-1次，那么最后可能时间时O(n^2)的。也就是说，要是最后存的component是很少的，那总时间是会很大的。


#### Quick-union

**基本的想法是：**还是用上面的`id[]`来操作，但是`id[]`的内容会有不同的含义。现在，**每个`id[]`里面存放的是其parent site的名字（也可以是其本身），就好像一个链表一样**。现在，在执行`find()`的时候，就按照链表的方式一直上寻找parent，直到到达所谓的“root”位置。而在执行`union()`的时候，我们把`p`在`id[]`中值设置为`q`即可。这样的话，就好像生成了很多的链表结构。而对于满足`p = id[p]`的site来说，就是链表的尽头（如果在初期还没有任何的connection，那么每个site的上一级就是其本身）。 

```java
private int find(int p) {
    while (p != id[p]) p = id[p];
    return p;
}

public void union(int p, int q) {
    int pRoot = find(p);
    int qRoot = find(q);
    if (pRoot == qRoot) return;
    
    id[pRoot] = qRoot;
    count -- ;
}
```

这个关系其实就很像树结构。因此一般来说可以按照树的结构来表示每个site之间的关系，叫做**forests-of-trees representation**。一般来说，如有多个class，则会有很多树同时存在。参见教材225页的图示。

分析这个算法：

1. 看起来这个算法比之前的那个要快一些，因为我们不必再去遍历整个`id[]`，但是能快多少呢？

2. 实际上，分析起来很困难，因为实际的cost依赖于输入是什么，以及树的结构。在最优的情况下，`find()`只需要一次访问就到根；但在最坏的情况下，需要2N+1次访问，就好像树退化到了一个单链表的情况（这里2N+1是有争议的，如果是2N+1那是把`p != id[p]`也算成了一次访问）。所以，dynamic connectivity的时间有时线性但是有时可以是平方的。
3. 在这里，基本可以认为quick-union比quick-find有所改善，因为后者在union的时候一直都是线性的，但是qiuck-union不一定。不过，quick-union还是有很多改善的地方。
4. **事实上，`find()`操作要访问索引的次数等于1加上该site的深度的两倍，`union()`和`connected()`则是两个`find()`的访问次数之和**（要是不连通则对`union()`来说再加1）。


和树一样，树的查找及相关的功能和树的结构有着非常大的关系，而且越平衡的树查找的时间越短。所以，在这里也一样，在一些极端情况下，比如需要connect的pair依次为0-1，0-2，0-3等时，最终的结构会退化成一个链表。这样对结构的性能是不利的。


#### Weighted quick-union

为了表面上面这个极端情况的发生，其实是可以有办法的。想想看，我们在每次union`p`和`q`的时候，都是默认把`p`的root编程`q`的root。我们可以改变这个默认的做法，来防止极端情况的发生。

在整个的实现中，我们**会同时记录树的大小，在union两个树的时候，总是把较小的树设置为较大树的子树。**这么做的话，我们需要多一些代码了。


```java
public class WeightedQuickUnionUF {
    private int[] id;
    private int[] sz;
    private int count;

    public WeightedQuickUnionUF(int N) {
        count = N;
        id = new int[N];
        sz = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
            sz[i] = i;
        }
    }

    public int count() {
        return count;
    }

    public boolean connect(int p, int q) {
        return find(p) == find(q);
    }

    private int find(int p) {
        while (p != id[p]) p = id[p];
        return p;
    }

    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        if (i == j) return ;

        // malker smaller root point to larger one
        if (size[i] < size[j]) {id[i] = j; sz[j] += sz[i];}
        else                   {id[j] = i; sz[i] += sz[j];}
        count --;
    }
}
```

分析这个算法：

1. 看最坏的情况：每次union或者说merge两棵树的时候，两者的size都是一样的。这个时候的tree的特点是，若节点为2<sup>n</sup>时，树的高度为n，所以要是融合两个节点数都是2<sup>n</sup>的树，高度变成n+1，所以这个算法的性能是对数级的。
2. **结论：**在树里面的每一个节点深度都最多为`log(N)`。其中`N`为site的总数。可以用归纳法证明一个更强的结论：在一个size为`k`的树里面，每一个site的深度最多为`log(k)`。证明：两个树，size分别是`i`和`j`并且`i <= j, i + j = k`。那现在融合后，较大树中所有的节点深度都不会变，较小树的每一个site深度增加1，也就是：

        1 + lgi = lg(i+i) <= lg(i+j) = lgk
    
3. 根据上面的结论，在最坏情况下，`find()`/`union()`/`connected()`的时间代价都是`logN`。


#### Weighted quick-union with path compression

现在对数的已经实现了，那能不能实现一个常数时间的呢？实际上，我们在寻找一个路径的时候，有没有想过这个路径可以压缩呢？换句话说，假如这个树的深度是1，即树是完全扁平的，那查找性能会非常好！这就要求，site需要直接连接到root。其实不难，那在哪里操作比较好？

其实方法有很多，下面是一种在`find()`中的方法。在find的过程中，可以把`p`的父节点设置为爷爷节点，这样就有了一个comporess的过程。

```java
private int find(int p) {
    while (p != id[p]) {
        id[p] = id[id[p]];
        p = id[p];
    }
    return p;
}
```

### 总结

Algorithm | Constructor | Union | Find
----- | ----- | ----- | -----
Quick-find | N | N | 1
Quick-union | N | tree height | tree height 
weighted quick-union | N | lg N | lg N
weighted quick-union with path compression | N | close to 1 | close to 1






