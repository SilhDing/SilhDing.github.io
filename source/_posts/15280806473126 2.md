## 123 188 309 714 dp 股票问题


### 总结与提纲

- **<a href="#123">123</a> 最多两次；<a href="#188">188</a> 最多K次**
    - 采用顺序传递的方法，先弄懂两次的情况：第一个交易记录最大值，传递给第二个交易；
    - K次的：第一个交易记录最大值，传递给第二个交易；第二个交易记录前两次最大值，传递给第三个交易；以此类推。

- **<a href="#309">309</a> 在sell后有cooldown的限制；<a href="#714">714</a> 在sell时有费用支出**
    - 画状态图！
    - `sell, buy, rest`三种状态
    - `sell, buy`两种状态（买股票第二题可以这么做，但是第二题太简单不用这么折腾）
    - （可以优化空间，暂时没有做）

- 补充：买股票第一题121和第二题122很简单，但是都有启发意义
    - 121 其实就是上面中`K=1`的情况
    - 122 其实就是309 714中不加任何限制的情况

-

### <a id="123">123. Best Time to Buy and Sell Stock III</a>

Say you have an array for which the i-th element is the price of a given stock on day `i`.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

就是那个股票的卖出问题，但是，这里的限制条件是，最多完成两次交易。先post一个解法：

```java
class Solution {
    public int maxProfit(int[] prices) {
    
        int firstBuy = Integer.MIN_VALUE, firstSell = 0;
        int secondBuy = Integer.MIN_VALUE, secondSell = 0;

        for (int curPrice : prices) {
            firstBuy = Math.max(firstBuy, 0 - curPrice); 
            firstSell = Math.max(firstSell, firstBuy + curPrice);
            secondBuy = Math.max(secondBuy,  firstSell- curPrice); 
            secondSell = Math.max(secondSell, secondBuy + curPrice);
        }
        
        return secondSell;
    }
}
```

虽然是一个难题，但是标准答案的解答很简洁。

大部分的解释里面都这么解释这四个变量

    buy1: 第一次买入的时候，剩下的尽可能多的钱
    sell1: 第一次卖出去的时候，剩下的尽可能多的钱
    buy2: 第二次买入的时候，剩下的尽可能多的钱
    sell2: 第二次卖出的时候，剩下的尽可能多的钱
    
实际上这么解释并不好，因为，这么解释并不能说明怎么取得最大两次利润的。那么怎么解释这四个变量？

1. `buy1`永远保持所出现`price`中的**最低价**，负数形式存储；
2. `sell1`会保持**之前所有情况中的单次最大利润**，而并非第一次或者最后一次。比如：
    - 当循环到`[2,3,4,1]`时，`buy1`是`-1`，`sell1`是`2`；
    - 当循环到`[2，3，4，1，6]`时，`buy1`是`-1`，`sell1`是`5`，很明显，这是取最后两个的情况；
3. 可以发现，到这里的话，其实`sell1`的值就是[Best Time to Buy and Sell Stock I](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)中的结果了。换句话说，`buy1`和`sell1`是用来**找利润最大的单次交易**的。
4. `buy2`和`sell2`的情况基本是一样的，唯一的区别是，这一次购买，启动基金将不一样，并且，这个启动基金是之前完成**所有单次交易中的最大利润**，也就是`sell1`。`sell2`则会始终记录着**两次利润最大的单次交易利润之和**。

我们用几个例子来说明会更好：

1. `[1,3,4,7]`

    - 假如完全是递增的，这个时候，两个交易是一样的。这是因为，对于第一次交易来说，每到下一个数字，那就更新一次`sell1`，而紧接着，`buy2`因为有`firstSell- curPrice`的动作，相当于在这天又买进了，等于没有卖。所以两次的buy其实是完全一样的。

    - 假如递增的情况断了，比如上面的`7`改成`2`，那么这个时候对`buy1`和`sell1`没有影响，但是`buy2`在前一天以4的价格卖出后，今天可以以`2`的价格买入，肯定比第一次买入后所剩的钱要多（即比自己的上一个状态要好），所以这个时候，两次交易实际上并不一样的。

2. `[2,3,5,3,5,1,7]`  
    - 很明显最后的交易数据应该是`[2,5],[1,7]`；
    - 首先只看`[2,3,5]`。这完全是一个递增的，在刚进入`2`时，我们可以认为，这个时候对于`buy2`和`sell2`来说，基金为0，即之前所有单次交易的最大利润是`0`。`sell2`仍可以看成两次利润最大的单次交易利润之和，只不过一个是`0`；
    - 当进来`[3,5]`时，这个时候，我们先不管`buy1`和`sell1`。`buy2`和`sell2`会带着之前的最高利润作为基金，即`3`进行运算，结果是`[-2,3,0,5]`
    - 当进来`[1,7]`时，会怎么更新呢？可以这么对第二次购买描述：**启动基金是当前可拿到的最大的单次交易利润，比较的基准是最大的两次单次交易利润和，假如我的启动基金和新来的交易是可以有更大利润和的，`sell2`则会更新**。
    
3. `[2,3,5,1,7,3,5]`  
    - 最后的数据应该是`[2,5],[1,7]`，和上面一样；
    - 当循环完`[2,3,5,1,7]`后，没有问题，结果应该是`[-1,6,2,9]`，这个时候进来了`[3,5]`，这个对最终结果是不影响的，How?
    - 这个时候，`buy1`和`sell1`是明显不受影响的；
    - 对于`buy2`和`sell2`来说，once again，他会带着前面所有最好的一次利润走，在这里也就是`6`，但是走完会发现，我如果采用了最后一个交易，也就是实际交易为`[1,7],[3,5]`，这个结果还不如之前得到的结果大，所以，抛弃。
    
换句话说：
`sell1`和`sell2`永远保持最大的单次利润、最大的两个单次利润和

**补充的解释** ------------------------------------------------------------------
上面的解释还有有一点问题的，实际上，严格来说，`buy1`和`sell1`是指假如整个过程就一个交易所对应的情况，相应的`buy2`和`sell2`是两次交易。

比如，输入要是为`[2,3,4,3,6]`那么最后的结果会是`[-2,4,-1,5]`。这和上面的例子稍微有一点的出入。

那么，在这种情况下，可能上面的例子就有点解释不通了。因为循环完后，`sell1`实际上是要在最后卖出，这样的话第二次交易怎么来的呢？

这就好像在中间再按顺序嵌入一个`sell`和`buy`，也就是嵌在`4`和`3`上。这么理解：`2`和`6`选定之后，这4块钱肯定是赚了的，那么我们要做的是增加适当的交易，再多赚一点。

实际上上面的解释对算法的理解并没有什么帮助。我们还是可以按照之前的方法来分析这个情况下的算法过程。在进行到第二个3的时候，一样地，第二次交易会拿着之前最好的利润，也就是`2`，作为启动基金。因为此时的价格`3`比上一天的价格`4`小，而且自己又有了启动基金，那么肯定`buy2`会更新，也即代表第二次的买入操作发生，但是此时`sell2`并没变化，因为并没碰到卖出的机会；而`6`进来后，代表卖出可以进行，则完成。

这四个变量的变化过程：
    
    -2 0 -2 0
    -2 1 -2 1
    -2 2 -2 2
    -2 2 -1 2
    -2 4 -1 5

### <a id="188">188. Best Time to Buy and Sell Stock IV</a>

现在，怎么generalize这个情况呢？也即假如规定最大交易次数为`k`时呢？先post解法。

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        
        //考虑这么一个情况，k非常大，远远超出prices中可以完成的交易次数n/2，
        //这个时候，问题就变成了II的情况。
        if (k >= prices.length/2) {
            int res = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] > prices[i-1]) res += prices[i] - prices[i-1];
            }
            return res;
        }
        
        // 和两次交易的情况是一样的，这里用一个array来存
        int[] buy = new int[k + 1];
        int[] sell = new int[k + 1];
        
        
        for (int i = 1;i <= k; i ++) {
            buy[i] = Integer.MIN_VALUE;
        }
        
        for (int price: prices) {
            for (int j = 1; j <= k; j ++) {
                buy[j] = Math.max(buy[j], sell[j-1] - price); 
                sell[j] = Math.max(sell[j], buy[j] + price); 
            }
        }
        return sell[k];
    }
}
```

在这里，`sell[i]`中存的是**第`i`次交易完成后总利润的最大值**。实际上思路和上面几乎是一样的。当然，在前面还做了一个判断，这个判断能够把一些case转化成一个很简单的情况，从而减少需要使用的内存。

再来看一个变形，这里仍然使用dp来做，但是，比较抽象，值得考虑一下。

-

### <a id="309">309. Best Time to Buy and Sell Stock with Cooldown</a>

现在的要求是，在卖出后，要休息一天才能买入新的。怎么做？

先这么考虑这个问题，首先，在一个固定的一点，股市收盘后，会有几种状态呢？（不考虑当天买入并卖出的情况，这等于是什么的都没做）

    1. 当天买入，after buy
    2. 当天卖出，after sell
    3. 当天休息，after rest

为什么要专门给rest单独弄一个，这是因为rest有特殊的功能: after sell + rest才能再buy。三者之间的状态转化也可以轻易得到：

![Picture1-w400](media/15280806473126/Picture1.png)

在这里，还是用array`sell[i]`和`buy[i]`还有`rest[i]`来做DP，分别代表上面的三个状态。那么这三个的含义是什么呢？比如说，**`sell[i]`代表的是在第`i`天时，以sell结尾的序列能获取的最大利润**，其他两个同理。那么，现在考虑单独的一天`i`：

- **要生成`buy[i]`的情况**，从状态图可以，要么在前一天rest的基础上买入，，`buy[i] = rest[i-1] - prices[i]`；要么在前一天buy的基础上，什么都不做，即：`buy[i] = buy[i -1]`；
- **要生成`sell[i]`的情况**，那么等于要在前一天buy的基础上卖出，就是说`sell[i] = buy[i-1] + prices[i]`，只有这一种方法；
- **要生成`rest[i]`的情况**，那么可以在前一天rest的基础上再休息，`rest[i] = res[i-1]`；后者在前一天sell的基础上，休息，`rest[i] = sell[i-1]`。

因此：

```java
rest[i] = max(rest[i - 1], sell[i - 1]); 
buy[i] = max(buy[i - 1], rest[i - 1] - prices[i]); 
sell[i] = buy[i - 1] + prices[i]; 
```
并做好初始化：

```
rest[0] = 0
buy[0] = -prices[0]
sell[0] = 0
```
代码：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        int[] rest = new int[n];
        
        buy[0] = -prices[0];
        sell[0] = 0;
        rest[0] = 0;
        
        for (int i = 1; i < n; i++) {
            rest[i] = Math.max(rest[i - 1], sell[i - 1]); 
            buy[i] = Math.max(buy[i - 1], rest[i - 1] - prices[i]); 
            sell[i] = buy[i - 1] + prices[i]; 
        }
        
        return Math.max(sell[n-1],rest[n-1]);
    }
}
```
是不是觉得很简单？哈哈哈哈哈哈哈哈哈哈哈哈。这里面最难理解的，就是`sell[i]`和`buy[i]`还有`rest[i]`到底代表的是什么含义，这么理解吧：**这代表了在`i`这一天结束后，我来看我的所有操作，发现最后一个操作是sell/buy/rest时的最大利润。其中，这最后一个操作可以是当天进行的**。

还有一个问题，在buy之后rest，为什么状态还是buy呢？这是因为，我们要进行sell操作时，必须保证上一个非空的操作是buy，假如buy之后rest变成了rest，那么我们实际上并不知道上一个非空的操作是不是buy，毕竟在sell之后的rest也是rest，所以这一点一定注意。

实际上，我们不用rest这个东西也是可以做的，看下面的状态图！

请注意，这里的含义稍有不同，这里的`buy`和`sell`表示的是操作序列中，最后一个操作（rest不算是一个操作）。 
![Picture4-w200](media/15280806473126/Picture4.png)

代码：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0 || n == 1) return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        
        buy[0] = -prices[0];
        buy[1] = Math.max(buy[0], -prices[1]); 
        // 第一天买，第二天什么都不做；第一天什么都不做，第二天买，
        sell[0] = 0;
        sell[1] = Math.max(sell[0], buy[0] + prices[1]); 
        
        for (int i = 2; i < n; i++) {
            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]); 
            sell[i] = Math.max(sell[i-1], buy[i - 1] + prices[i]); 
        }
        
        return sell[n-1];
    }
}
```

这里可能还有一个疑问，

```java
buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]); 
```

在这里，`sell[i-1]`也可能代表最后一天是休息，那似乎`sell[i - 1] - prices[i]`也是可以的呀？

这么做的原因是：上述的考虑是对的，但是请想想，`sell[i-1]`如果代表最后一天是休息，那就是`sell[i-1] = sell[i-2]`呀！所以这么写是肯定对的；另一方面，`sell[i-1]`还可能代表`i-1`天的最后操作是卖出，这样一来的话就无法区分，cooldown就不好用了。所以，虽然用`sell[i - 2] - prices[i]`有点费解，但是实际上这才是正确的。

上面还可以简化到内存只有O(1)的情况，这里不赘述。

在看一个例子！

-

### <a id="714">714. Best Time to Buy and Sell Stock with Transaction Fee</a>

这里的变化是，不在有cooldown的限制，同时，每次sell后要交手续费。其实很简单，我们稍微改一改状态图就好：

![Picture2-w400](media/15280806473126/Picture2.png)

上图就去了cooldown的限制啦，那么只要在`buy[i]`中再加一项，sell中减去fee就可以了。代码：

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        int[] rest = new int[n];
        
        buy[0] = -prices[0];
        sell[0] = 0;
        rest[0] = 0;
        
        for (int i = 1; i < n; i++) {
            rest[i] = Math.max(rest[i - 1], sell[i - 1]); 
            buy[i] = Math.max(Math.max(buy[i - 1], rest[i - 1] - prices[i]), sell[i - 1] - prices[i]); 
            sell[i] = buy[i - 1] + prices[i] - fee; 
        }
        
        return Math.max(sell[n-1],rest[n-1]);
    }
}
```
但是实际上，根本不用这么麻烦！在这里，我们不需要把rest当成一个单独的状态了，可以简化很多：

![Picture3-w200](media/15280806473126/Picture3.png)

代码也会简单很多：

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[] buy = new int[n];
        int[] sell = new int[n];
        
        buy[0] = -prices[0];
        sell[0] = 0;
        
        for (int i = 1; i < n; i++) {
            buy[i] = Math.max(buy[i-1], sell[i-1]-prices[i]); 
            sell[i] = Math.max(sell[i-1],buy[i-1]+prices[i]-fee) ;
        }
        
        return sell[n-1];
    }
}
```
上面还可以简化到内存只有O(1)的情况，这里不赘述。






