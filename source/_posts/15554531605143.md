# DP 2

-

### 目录

<font color=green>**Easy**</font> 
<font color=orange>**Medium**</font> 
<font color=red>**Hard**</font>

Problem | Briefs | Notes
------------ | ------------- |-------
<a href="#698">**698**</a> <font color=orange>**Medium**</font> Partition to K Equal Sum Subsets| A typical back-tracing problem | <font color=orange>**Medium**</font> Typical problem, but you need to think some key points here; otherwise takes too long to finish.
<a href="#97">**97**</a> <font color=red>**Hard**</font> Interleaving String | Typical dp! | <font color=orange>**Medium**</font> I try with dfs or back-tracing, but OOM. DP is another way for back-tracing, in fact!
<a href="#410">**410**</a> <font color=red>**Hard**</font> Split Array Largest Sum | The way to think DP is very original. | <font color=orange>**Medium**</font> The DP solution might not be so fast, but is a good example for DP.
<a href="#403">**403**</a> <font color=red>**Hard**</font> Frog Jump | I would call it a multi-state DP. In this case, we would use map for dp.  | <font color=orange>**Medium**</font> This is also a dfs with memorization.
<a href="#837">**837**</a> <font color=orange>**Medium**</font> New 21 Game | The most tricky part is to understand the rule of this game. | <font color=red>**Hard**</font> You are possible to get messed up.
<a href="#1000">**1000**</a> <font color=red>**Hard**</font> Minimum Cost to Merge Stones | This is a hard problem. | <font color=red>**Hard**</font> The key is the thinking process.
<a href="#516">**516**</a> <font color=orange>**Medium**</font> Longest Palindromic Subsequence | Not so hard. Code itself is self-explanatory. But get clear the transition! | <font color=orange>**Medium**</font> Thinking process is the key.
<a href="#198">**198**</a> <font color=green>**Easy**</font> House Robber | A easy problem and you should solve it fast. Then improve it into constant space | <font color=green>**Easy**</font> Practice!
<a href="#1066">**1066**</a> <font color=orange>**Medium**</font> Campus Bikes II | DFS -> DFS + 2D memo -> DFS + 1D memo | <font color=orange>**Medium**</font> This is a good problem to practice. You have to learn that why we can modify it to 1D memo!
<a href="#983">**983**</a> <font color=orange>**Medium**</font> Minimum Cost For Tickets | It is kinda hard to come up with the DP idea, but dp code is really clean! | <font color=orange>**Medium**</font> Interesting problem, and you have 100% get it!


### <a id="698">698 Partition to K Equal Sum Subsets</a>

Given an array of integers `nums` and a positive integer `k`, find whether it's possible to divide this array into `k` non-empty subsets whose sums are all equal.

    Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
    Output: True
    Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
    
-

This is a typical back-tracing or DFS problem. See the code below:

```java
class Solution {
    
    // backtracing
    // note: all postive here!
    
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int runningSum = 0;
        for (int num: nums) runningSum += num;
        
        if (runningSum % k != 0) return false;
        
        int target = runningSum / k;
        boolean[] visited = new boolean[nums.length];
        
        return helper(nums, target, 0, visited, k, 0);
    }
    
    private boolean helper(int[] nums, int target, int cur, boolean[] visited, int k, int index) {
        // base cases
        // why we have to keep index here?
        // if not, cannot converge
        if (k == 0) return true;
        if (cur == target) return helper(nums, target, 0, visited, k-1, 0);
        if (cur > target) return false;
        
        for (int i = index; i < nums.length; i++) {
            if (visited[i]) continue;
            
            visited[i] = true;
            if (helper(nums, target, cur+nums[i], visited, k, i+1)) return true;
            visited[i] = false;
        }
        
        return false;
    }
}
```

The basic idea is to make the problem smaller by recursively calling the method, which is not hard to understand. However, some interesting facts:

- One parameter is `index`. It means you have to start the loop after the loop in the function that calls the current one. You may draw a single picture to demonstrate why we need to do this: avoid unnecessary operation. If not, the time would be really long. 
- Think about why when we find `cur == target` and decrease `k` by 1, `index` is set to 0. Think about why (should be trivial).

### <a id="97">97 Interleaving String</a>

Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:

    Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
    Output: true
    
The solution is self-explanatory.


```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        // I tried with backtracing but out of memory
        int num1 = s1.size(), num2 = s2.size();
        if (num1+num2 != s3.size()) return false;
        
        bool dp[num1+1][num2+1];
        
        for (int i = 0; i < num1 + 1; i++) {
            for (int j = 0; j < num2 + 1; j++) {
                if (i == 0 && j == 0) dp[i][j] = true;
                else if (i == 0) {
                    dp[i][j] = dp[i][j-1] && (s2[j-1] == s3[i+j-1]);
                } else if (j == 0) {
                    dp[i][j] = dp[i-1][j] && (s1[i-1] == s3[i+j-1]);
                } else {
                    dp[i][j] = (dp[i-1][j] && (s1[i-1] == s3[i+j-1])) || (dp[i][j-1] && (s2[j-1] == s3[i+j-1]));
                }
            }
        }
        return dp[num1][num2];
    }
};
```

### <a id="410">410 Split Array Largest Sum</a>

Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.

Note:
If n is the length of array, assume the following constraints are satisfied:

- 1 ≤ n ≤ 1000
- 1 ≤ m ≤ min(50, n)

The best solution is binary search. However, using binary search is not always intuitive. Here we provide a DP solution that might be easy to understand.

**Rule:** `dp[i][j]` is the solution that if you divide `A[i]` ~ `A[L-1]` into `j` pieces.

Then, what is the transition relationship? And what is the base case?

We then do DP from the right. To determine `dp[i-1][j]`, which means we add a new entry `A[i-1]` in front of `dp[i][j]`, we could combine some (or 0) front entries from the array (`A[i]`, `A[i+1]`, ...)  and make a new split, then combine it with `dp[i-m][j-1]`, where `m` is determined by the number of entries used.

In fact it is a DFS, and we use DP array for memorization.

Thus, the code is easy to implement.

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        // consider this dp solution
        // it is very good!
        // dp[i][j] is the solution if you divide A[i] ~ A[L-1] into j pieces
        int len = nums.length;
        int[][] dp = new int[len][m+1];

        int[] sum = new int[len];
        for (int i = sum.length - 1; i >= 0; i--) {
            if (i == sum.length - 1) sum[i] = nums[i];
            else sum[i] = sum[i+1] + nums[i];
        }

        return dfs(nums, 0, m, dp, sum);
        
    }

    //dp[start][m]
    private int dfs(int[] nums, int start, int m, int[][] dp, int[] sum) {
        if (m == 1) return sum[start];

        if (dp[start][m] != 0) return dp[start][m];

        int runningSum = 0, min = Integer.MAX_VALUE;
        for (int i = start; i <= nums.length - m; i++) {
            runningSum += nums[i];
            min = Math.min(min, Math.max(runningSum, dfs(nums, i+1, m-1, dp, sum)));
        }
        dp[start][m] = min;
        return min;
    }

}
```

### <a id="403">403 Frog Jump</a>

A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.

If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.

Note:

- The number of stones is ≥ 2 and is < 1,100.
- Each stone's position will be a non-negative integer < 231.
- The first stone's position is always 0.

Example:

    [0,1,3,5,6,8,12,17]
        
    There are a total of 8 stones.
    The first stone at the 0th unit, second stone at the 1st unit,
    third stone at the 3rd unit, and so on...
    The last stone at the 17th unit.
        
    Return true. The frog can jump to the last stone by jumping 
    1 unit to the 2nd stone, then 2 units to the 3rd stone, then 
    2 units to the 4th stone, then 3 units to the 6th stone, 
    4 units to the 7th stone, and 5 units to the 8th stone.
    

这是一个很有参考意义的dfs+dp题目。 和其他的题目一样，dfs在这里的作用也是存储已经计算完成的结果。但是每一个状态除了当前的index之外，还有一个步数，其实也就是函数的输入参数。把这些参数做成一个key存进map就行了。

```java
class Solution {
    public boolean canCross(int[] stones) {
        // record min jump and max jump?
        if ( stones[1] - stones[0] != 1 )
            return false;
        for (int i = 3; i < stones.length; i++) {
            if (stones[i] > 2 * stones[i - 1]) {
                return false;
            }
        }
        Map<String, Boolean> map = new HashMap<>();
        return helper(stones, 0, 0, map);
    }
    
    private boolean helper(int[] stones, int index, int jump, Map<String, Boolean> map) {
        if (index == stones.length - 1) return true;
        String key = index+ "," + jump;
        
        if (map.containsKey(key)) return map.get(key);
        
        for (int i = index + 1;i < stones.length; i++) {
            int gap = stones[i] - stones[index];
            if (gap < jump - 1) continue;
            else if (gap > jump + 1) break;
            
            if (helper(stones, i, gap, map)) {
                map.put(key, true);
                return true;
            }
        }
        map.put(key, false);
        return false;
    }
}
```

### <a id="837">837 New 21 Game</a>

Alice plays the following game, loosely based on the card game "21".

Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.

Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?

**Example 1**:

    Input: N = 10, K = 1, W = 10
    Output: 1.00000
    Explanation:  Alice gets a single card, then stops.

**Example 2**:
    
    Input: N = 6, K = 1, W = 10
    Output: 0.60000
    Explanation:  Alice gets a single card, then stops.
    In 6 out of W = 10 possibilities, she is at or below N = 6 points.
    
The trickiest part of this problem is to understand the logic of this game. Note the following rules:

`W`: define the range of number of each step;
`K`: termination number (stop when you gave K or more points);
`N`: number we focus on (probability that she has N or less points).

This is a dp problem. We use `dp[i]` to present the probability of getting `i` points in the game. (**Note**: `i` is not the probability of getting this point after this game! It is the probability that we see this point during the game).

It is easy get that the max point we will see during this game is `W + K - 1`.

We now could use a simple dp.

```java
public double new21Game2(int N, int K, int W) {
    // This is the first solution
    // simple dp, dp[i] is the probability of getting points i in the game
    if (K == 0) return 1;
    int max = K + W - 1; // max point we will see during the game
    double[] dp = new double[max+1];
    dp[0] = 1;
    for (int i = 1; i <= max; i++) {
        for (int j = 1; j <= W; j++) {
            int last = i - j;
            // we have to limit last smaller than K:
            // because if we have K points, we have already stopeed.
            if (last >= 0 && last < K) dp[i] += dp[last]/W;
        }
    }
    
    double res = 0;
    for (int i = K; i <= N; i++) {
        res += dp[i];
    }
    return res;
}
```

You may find that we have do a loop for each entry of dp. We can further optimize this solution:

```java
public double new21Game(int N, int K, int W) {
    // now change the dp way
    // dp[i] is the sum of p(i), p(i-1), ... p(0) where p(i) is the probability of getting points i in the game
    // p(i) = dp[i] - dp[i-1]
    // transition: dp[i] = dp[i-1] + p(i) = dp[i-1] + (p(i-1) + p(i-2) + ...p(i-W))/W
    //                                    = dp[i-1] + (dp[i-1] - dp[i-W-1])/W
    if (K == 0) return 1;
    int max = K + W - 1; // max point we will see during the game
    double[] dp = new double[max+1];
    dp[0] = 1;
    
    for (int i = 1; i <= max; i++) {
        dp[i] = dp[i-1];
        if (i - W > 0) {
            dp[i] += (dp[i-1] - dp[i-W-1])/W;
        } else {
            dp[i] += dp[i-1]/W;
        }
        
        // if i > K now, we have to remove some part:
        // p(i-1) + p(i-2) + ... +p(K) = dp[i-1] - dp[K-1]
        if (i > K) dp[i] -= (dp[i-1] - dp[K-1])/W;
    }
    return dp[N] -dp[K-1];
}
```


### <a id="1000">1000 Minimum Cost to Merge Stones</a>

There are `N` piles of stones arranged in a row.  The i-th pile has `stones[i]` stones.

A move consists of merging exactly `K` consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these `K` piles.

Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return `-1`.

Example:

    Input: stones = [3,2,4,1], K = 2
    Output: 20
    Explanation: 
    We start with [3, 2, 4, 1].
    We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].
    We merge [4, 1] for a cost of 5, and we are left with [5, 5].
    We merge [5, 5] for a cost of 10, and we are left with [10].
    The total cost was 20, and this is the minimum possible.
    
This is indeed a problem, and I do not even know how I should solve this problem manually, which, however, indicates that we may solve this problem by dynamic programming.

Then the key problem is how to use DP: we use `dp[i][j][k]` to represent the min cost to merge `i`~`j` stones to `k` piles.

Thus, for `dp[i][j][k]`, we know that we wish to have `k` piles finally, and now let's split all stones from `i` to `j` into two parts: left part and right part. There is only one pile in the left part and `k-1` piles in the right. The left pile could be generated by merging piles from most left 1 or 2 or ... piles. So, we could have the relations for dp:

`dp[i][j][k] = min(dp[i][t][1] + dp[t+1][j][k-1])` and
`dp[i][j][1] = dp[i][j][K] + sum(i,j)`


Some people may get confused that why we only use the split (k-1, 1). Is that sufficient? Don't we need to consider other patterns like (k-2, 2) or (k-3, 3)?

1. **Using (k-1, 1) or (1, k-1) is sufficient**.  You may think it in this way: for `dp[i][j][k]`, we hope finally we have `k` piles. Let's now split it into left part (1 pile) and right part (`k-1` piles). The left part could be merged by first 1 or 2 or 3 or ... stones and right part could be merged by other stones. So it is sufficient to only consider this case. 
2. **All other patterns might be incorrect**. Take (k-2, 2) as an example. It is possible that left part cannot be merged into `k-2` piles but `a` piles, while right part can only be merged into `b` piles. It is possible that `a + b >= K >= k`, which means we have to merge one more time to get k piles. However, in our code, if we cannot make left part into `k-2` piles, `dp[i][t][k-2]` is `max`, and same with `dp[t+1][j][2]`, thus our code would show that we cannot merge stones `i` to `j` into `k` piles, which, however, might be incorrect. Using split (k-1, 1) or (1, k-1) does not have this problem, as all merging strategies would show a split pattern (1, k-1) or (k-1, 1).

```java
class Solution {
    public int mergeStones(int[] stones, int K) {
        // how can you do it manually?
        // choose the minimal sum of consecutive k piles to move: greedy algorithm
        // but this is not correct
        // use dp
        // a hard one
        int len = stones.length;
        if ((len - 1) % (K - 1) != 0) {
            return -1;
        }
        
        int[][][] dp = new int[len+1][len+1][K+1];
        int[] sum = new int[len+1];
        
        for (int i = 1; i <= len; i++) {
            sum[i] = sum[i-1] + stones[i-1];
        }
        
        // init
        for (int i = 1; i <= len; i++) {
            for (int j = 1; j <= len; j++) {
                for (int k = 1; k <= K; k++) {
                    if (i == j && k == 1) dp[i][j][k] = 0;
                    else dp[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }
        
        // now go through every entry
        for (int l = 2; l <= len; l++) {
            for (int start = 1; start <= len -l + 1; start++) {
                int end = start + l - 1;
                for (int k = 2; k <= K; k++) {
                    for (int t = start; t < end; t++) {
                        if (dp[start][t][1] == Integer.MAX_VALUE || dp[t+1][end][k-1] == Integer.MAX_VALUE) continue;
                        dp[start][end][k] = Math.min(dp[start][t][1] + dp[t+1][end][k-1], dp[start][end][k]);
                    }
                    if (dp[start][end][K] != Integer.MAX_VALUE)
                        dp[start][end][1] = dp[start][end][K] + sum[end] - sum[start-1];
                }
            }
        }
        return dp[1][len][1];
    }
}
```

Based on this idea, we may think about improving this solution. Given stones from `i` to `j`, the piles left after all possible mergings is determined. So we could use a 2D array as dp instead. Now, `dp[i][j]` is the min cost to merge stones as less as possible.

```java
class Solution {
    public int mergeStones(int[] stones, int K) {
        // 3D array is not so good: coding is hard
        // 2D: dp[i][j] means cost to merge them (have less than K piles left), i.e., we merge them as less as possible
        int len = stones.length;
        if ((len - 1) % (K - 1) != 0) return -1;
        

        int[] sum = new int[len+1];
        for (int i = 1; i <= len; i++) {
            sum[i] = sum[i-1] + stones[i-1];
        }

        int[][] dp = new int[len+1][len+1];
        for (int l = K; l <= len; l++) {  // we can start from K; for l < K, always 0, as no move is needed.
            for (int i = 1; i <= len - l + 1; i++ ) {
                int j = i + l - 1;
                dp[i][j] = Integer.MAX_VALUE;
                for (int t = i; t < j; t += K - 1) {   
                    // why t += K - 1? think about it
                    dp[i][j] = Math.min(dp[i][j], dp[i][t] + dp[t+1][j]);
                }
                if ((j-i) % (K - 1) == 0) dp[i][j] += sum[j] -  sum[i-1];
            }
        }
        return dp[1][len];
    }
}
```

Note that the reason to increment `t` by `K-1` is to make sure we always wish we can merge the left part into 1 pile.

### <a id="516">516 Longest Palindromic Subsequence</a>

Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.

We start start with the first char and the last char. If these two chars are the same, we then know these two chars must be included in the final subsequence. Thus, we could have a smaller problem!

This problem is then solved by recursion, but you could use memo to reduce running time.

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        int[][] dp = new int[len][len];
        return helper(s, 0, s.length() -1, dp);
    }
    
    private int helper(String str, int start, int end, int[][] dp) {
        if (start == end) return 1;
        if (start > end) return 0;
        if (dp[start][end] > 0) return dp[start][end];
        if (str.charAt(start) == str.charAt(end)) {
            // these two chars must be in the final subseq
            dp[start][end] = helper(str, start + 1, end - 1, dp) + 2;
        } else {
            dp[start][end] = Math.max(helper(str, start, end - 1, dp), helper(str, start+1, end, dp));
        }
        return dp[start][end];
    }
}
```

You may have a question that why `dp[start][end] = helper(str, start + 1, end - 1, dp) + 2` when `str.charAt(start) == str.charAt(end)`?

Think it in this way. If we only include the first char, then we must find an equal char between the the first char and the last char, and then reduce the problem's size to the distance between the first char and the char between the first and the last. However, as we have to find the longest subsequence, it could return the wrong answer.

We may modify it into DP solution.

```java
class Solution {
    public int longestPalindromeSubseq2(String s) {
        // modify it to dp, so we can further improve space usage
        int len = s.length();
        if (len == 0) return -1;
        
        int[][] dp = new int[len][len];
        // only focus on i <= j
        for (int i = len - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < len; j++) {
                if (s.charAt(i) == s.charAt(j) ) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]);
                }
            }
         }
        return dp[0][len-1];
    }
}
```

Note how to determine the way to iterate DP array. You may then improve the space usage to O(len):

```java
public int longestPalindromeSubseq(String s) {
    int len = s.length();
    if (len == 0) return -1;
    int[] dp = new int[len];
    
    for (int i = len - 1 ; i >= 0; i --) {
        int[] tmp = new int[len];
        tmp[i] = 1;
        for (int j = i+1; j < len; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                tmp[j] = dp[j-1] + 2;
            } else {
                tmp[j] = Math.max(tmp[j-1], dp[j]);
            }
        }
        System.arraycopy(tmp, 0, dp, 0, len); 
    }
    return dp[len-1];
}
```

### <a id="198">198 House Robber</a>

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example:

    Input: [2,7,9,3,1]
    Output: 12
    Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
                 Total amount you can rob = 2 + 9 + 1 = 12.
                 
This should be a simple DP problem and you should write it fast.

For a single day, we have two options: rob it or not.

```java
public int rob2(int[] nums) {
    // use dp
    // dp[i]: how much money we can have with 0~i-1 numbers
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        // 1. pick this
        // 2. not pick this
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
    }
    return dp[nums.length - 1];
}
```

As we can see, `dp[i]` only depends on `dp[i-1]` and `dp[i-2]`, so we can further improve it to constant space usage.

```java
public int rob(int[] nums) {
    // look at the dp solution, the dp[i] only depends on i-1 and i-2
    // we only need to keep two variables
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    
    int prev1 = nums[0], prev2 = Math.max(nums[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        int tmp = Math.max(prev2, prev1 + nums[i]);
        prev1 = prev2;
        prev2 = tmp;
    }
    return prev2;
}
```

### <a id="1066">1066 Campus Bikes II</a>

On a campus represented as a 2D grid, there are `N` workers and `M` bikes, with `N <= M`. Each worker and bike is a 2D coordinate on this grid.

We assign one unique bike to each worker so that the sum of the Manhattan distances between each worker and their assigned bike is minimized.

The Manhattan distance between two points `p1` and `p2` is Manhattan`(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.

Return the minimum possible sum of Manhattan distances between each worker and their assigned bike.

This problem seems to be hard to find a smart solution, we we start with DFS solution.

The basic idea is to randomly assign a bike to the current worker, and update the total distance once all workers get bikes.

```java
class Solution {
    
    int res;
    
    public int assignBikes(int[][] workers, int[][] bikes) {
        
        res = Integer.MAX_VALUE;
        dfs(workers, bikes, new boolean[bikes.length], 0, 0);
        return res;
    }
    
    private void dfs(int[][] workers, int[][] bikes, boolean[] assigned, int index, int curDis) {
        if (index == workers.length) {
            res = Math.min(res, curDis);
            return ;
        }
        
        if (curDis >= res) return ;  // eliminate extra work
        
        for (int i = 0; i < bikes.length; i++) {
            if (assigned[i]) continue;
            int dis = getDistance(workers[index], bikes[i]);
            assigned[i] = true;
            dfs(workers, bikes, assigned, index+1, curDis +dis);
            assigned[i] = false;
        }
    }
    
    private int getDistance(int[] p1, int[] p2) {
        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
    }
}
```

Now we may find that a DFS call with same parameters would be called more than once. So we have to use memo: we need to keep track of `boolean[] assigned` and `index`.

For `boolean[] assigned`, we could use the binary representation of a integer `state` to store:
- make a bike at index `i` assigned: `state | (1 << i)`
- get the state of bike at index `i`: `state & (1 << i)`

```java
class Solution {
    
    public int assignBikes(int[][] workers, int[][] bikes) {
        int num = bikes.length;
        int[][] dp = new int[1<<num][workers.length];
        return dfs(workers, bikes, dp, 0, 0);
    }
    
    private int dfs(int[][] workers, int[][] bikes, int[][] dp, int index, int state) {
        // start with the worker at index, get the total distance
        if (index == workers.length) return 0;
        if (dp[state][index] > 0) return dp[state][index];
        
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < bikes.length; i++) {
            // go through each bike
            if ((state & (1 << i)) == 0) {
                res = Math.min(res, dfs(workers, bikes, dp, index+1, state | (1 << i))
                                    + getDistance(workers[index], bikes[i]));
            }
        }
        dp[state][index] = res;
        return res;
    }
    
    private int getDistance(int[] p1, int[] p2) {
        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
    }
}
```

In fact, we will not use any entry in the DP array. Once the state is known, the value of workers that get bikes are determined already, and index is also determined. So, it is possible to make the DP array 1D.

```java
class Solution {
    
    public int assignBikes(int[][] workers, int[][] bikes) {
        int num = bikes.length;
        int[] dp = new int[1<<num];
        return dfs(workers, bikes, dp, 0, 0);
    }
    
    private int dfs(int[][] workers, int[][] bikes, int[] dp, int index, int state) {
        // start with the worker at index, get the total distance
        if (index == workers.length) return 0;
        if (dp[state] > 0) return dp[state];
        
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < bikes.length; i++) {
            // go through each bike
            if ((state & (1 << i)) == 0) {
                res = Math.min(res, dfs(workers, bikes, dp, index+1, state | (1 << i))
                                    + getDistance(workers[index], bikes[i]));
            }
        }
        dp[state] = res;
        return res;
    }
    
    private int getDistance(int[] p1, int[] p2) {
        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
    }
}
```

### <a id="983">983 Minimum Cost For Tickets</a>

In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array `days`.  Each day is an integer from `1` to `365`.

Train tickets are sold in 3 different ways:

- a 1-day pass is sold for `costs[0]` dollars;
- a 7-day pass is sold for `costs[1]` dollars;
- a 30-day pass is sold for `costs[2]` dollars.
- 
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of `days`.

As there is only 365 days, so we can use dp (or you can find the max day which help reduces the space usage).

```java
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        // use dp
        // dp[365]
        // on day i, if there is no travel, then dp[i] = dp[i-1]
        // if has travel
        // 1. use a 1-day pass: dp[i] = dp[i-1] + costs[0]
        // 2. use a 7-day pass: dp[i] = min(dp[i-1], dp[i-2], dp[i-3], ... dp[i-7]) + costs[1]
        //    but dp is not decreasing, so only use dp[i-7];
        // 3. same with 30-day pas
        int[] dp = new int[366];
        boolean[] travel = new boolean[366];
        for (int day: days) travel[day] = true;
        
        for (int i = 1; i < 366; i++) {
            if (!travel[i]) dp[i] = dp[i-1];
            else {
                dp[i] = dp[i-1] + costs[0];
                dp[i] = Math.min(dp[i], dp[Math.max(i-7, 0)] + costs[1]);
                dp[i] = Math.min(dp[i], dp[Math.max(i-30, 0)] + costs[2]);
            }
        }
        return dp[365];
    }
}
```

 
 