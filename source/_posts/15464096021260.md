4 Edge-weighted Graphs and MST

[TOC]

## Definitions

A **spanning tree** of a graph is connected subgraph with no cycles that includes all the vertices. A **minimum spanning tree (MST)** of an edge-weighted graph is a spanning tree whose weight is no larger than the weight of any other spanning tree.

In this section, we will study the **Prim's** and **Kruskal's** algorithms to find MST for a edge-weighted graph.

## Underlying Principles

Before talking about any specific algorithm, let's discuss some principles.

At first, please recall two basic properties for **tree**:
- Adding an edge that connects two vertices in a tree creates an unique cycle;
- Removing an edge from a tree breaks it into two separate subtrees.

### Cut property

Here is a definitio of **cut**:

A **cut** of a graph is a partition of its vertices into two nonempty disjoint sets. A **crossing edge** of a cut is an edge that connects a vertex in one set with a vertex in the other.

Based on the definition above, here presents an important proposition:

**Cut property**: given any cut in an edge-weighted graph, the crossing edge of minimum weight is in the MST of the graph.

It is easy to prove this proposition by contradiction. Please note there is no requirement that the minimal edge be the *only* MST edge connecting the two sets.

### Greedy MST algorithm

In fact, based on the cut property, it is in fact not hard to find the MST of an edge-weighted tree. This algorithm is called **greedy MST algorithm**.

**Greedy MST algorithm**: starting with all edges colored gray, find a cut with no black edge (without black edge between these two sets), color its minimum-weight edge black, and continue until V-1 edges have been colored black.

Please refer to Page 607 for demonstration.

## Data type

Here are API for `Edge` and `EdgeWeightedGraph` classes.

### `Edge`

    public class Edge implements Comparable<Edge>
    ---------------------------------------------
           Edge(int v, int w, double weight)
    double weight()
       int either()
       int other()
       int compareTo(Edge that)
    String toString()
    
Implementation:

```java
public class Edge implements Comparable<Edge> {

    private final int v;
    private final int w;
    private final double weight;

    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    public double weight() {
        return weight;
    }

    public int either() {
        return v;
    }

    public int other(int vertex) {
        if (vertex == v) return w;
        else if (vertex == w) return v;
        else throw new RuntimeException("Inconsistent edge");
    }

    @Override
    public int compareTo(@NotNull Edge that) {
        if (this.weight() < that.weight()) return -1;
        else if (this.weight > that.weight()) return 1;
        else return 0;
    }

    @Override
    public String toString() {
        return String.format("%d-%d %.2f", v, w, weight);
    }
}
```

### `EdgeWeightedGraph`

    public class EdgeWeightedGraph
    ------------------------------
                   EdgeWeightedGraph(int V)
               int V()
               int E()
              void addEdge(Edge e)
    Iterable<Edge> adj(int v)
    Iterable<Edge> edges()
            String toString()
            
Implementation:
      
```java
public class EdgeWeightedGraph {

    private final int V;
    private int E;
    private Bag<Edge>[] adj;

    public EdgeWeightedGraph(int V) {
        this.V = V;
        this.E = 0;
        this.adj = (Bag<Edge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }

    public int V() { return V; }

    public int E() { return E; }

    public void addEdge(Edge e) {

        // get two vertices here
        int v = e.either(), w = e.other(v);
        adj[v].add(e);
        adj[w].add(e);
        this.E ++;
    }

    public Iterable<Edge> adj(int v) {
        return adj[v];
    }

    public Iterable<Edge> edges() {
        Bag<Edge> bag = new Bag<>();
        for (int v = 0; v < this.V; v++) {
            for (Edge e: adj(v)) {
                if (e.other(v) > v) bag.add(e);
            }
        }
        return bag;
    }
}
```

### `MST`

At the same time, we also define an API for MST algorithm.
    
    public class MST
    ----------------
                   MST(EdgeWeightedGraph G)
    Iterable<Edge> edges()
            double weight()
            
The API is self-explanatory.

## Prim's algorithm

The crux of Prim's algorithm is to attach a new edge to a single growing tree at each step.Start with any vertex as a single-vertex tree; then add V-1 edges to it, always taking next the minimum-weight edge that connects a vertex on the tree to a vertex not yet on the tree. 

The problem is: **how do we find the crossing edge with of minimal weight?**

One solution that is present later use some following data structures to implement this algorithm.

- `marked[v]`: mark the vertices on the tree;
- `mst`: a queue to store the tree edges;
- `pq`: a min priority queue to compare edges and help find the current one with the minimal weight.

### Lazy version

what does it mean by "lazy"? Please note: any edge, connecting the vertex just added to a tree vertex, that is already on the priority queue now becomes ineligible. A *eager* implementation would remove such edges out of the priority queue but a *lazy* one would leave these edges in the priority queue and conduct eligibility test when one of them is polled by the priority queue.

```java
public class LazyPrimMST {

    private boolean[] marked;
    private Queue<Edge> mst;
    private PriorityQueue<Edge> pq; // pq will poll the smaller ones first
    private double weight;

    public LazyPrimMST(EdgeWeightedGraph G) {
        marked = new boolean[G.V()];
        mst = new Queue<>();
        pq = new PriorityQueue<>();
        weight = 0;

        visit(G, 0); // add the first one
        while(pq.size() > 0) {
            Edge e = pq.poll();
            int v = e.either(), w = e.other(v);
            if (marked[v] && marked[w]) {
                // this edge is ineligible
                continue;
            }
            mst.enqueue(e);
            weight += e.weight();

            // in fact only v OR w is not marked
            if (!marked[v]) visit(G, v);
            if (!marked[w]) visit(G, w);
        }
    }

    private void visit(EdgeWeightedGraph G, int v) {
        // mark v and add to pq all edges from v to unmarked vertices
        marked[v] = true;
        for (Edge e: G.adj(v)) {
            if (!marked[e.other(v)]) pq.offer(e);
        }
    }
    
    public Iterable<Edge> edges() {
        return mst;
    }
    
    public double weight() {
        return weight;
    }
}
```

### Eager version

To improve the lazy version algorithm, we may have to delete some edges in the priority queue when necessary.
Here are some methods to do this:

- **Delete the ineligible edges**. Thus, the priority queue contains *only* the crossing edges between tree vertices and non-tree vertices;
- **Delete other edges**. Please note we only care the minimal edge from each non-tree vertex to a tree vertex. When we add a vertex `v` to the tree, the only possible change with respect to each non-tree vertex `w` is that adding `v` brings `w` closer than before to the tree. Thus, if an edge cannot make `w` closer to the tree, this edge in fact is also ineligible.

To make the second proposal above feasible, we may use an array `distTo[]` of `double` values to keep the distance between non-tree vertices and the tree. In this case, all edges polled by the priority queue are MST edges.

```java
public class PrimMST {
    private Edge[] edgeTo;
    private double[] distTo;
    private boolean[] marked;
    private PriorityQueue<Edge> pq;
    private double weight;

    public PrimMST(EdgeWeightedGraph G) {
        edgeTo = new Edge[G.V()];
        distTo = new double[G.V()];
        marked = new boolean[G.V()];
        pq = new PriorityQueue<>();
        weight = 0.0;
        Arrays.fill(distTo, Double.POSITIVE_INFINITY);

        distTo[0] = 0.0;

        // this is not necessary
        // edgeTo[0] = null;
        visit(G, 0);
        while (pq.size() > 0) {
            Edge e = pq.poll();
            // e must be MST edges
            int v = e.either(), w = e.other(v);
            weight += e.weight();

            // only v OR w is marked
            if (!marked[v]) visit(G, v);
            if (!marked[w]) visit(G, w);
        }
    }

    private void visit(EdgeWeightedGraph G, int v) {
        // add v to the tree and update data structures
        marked[v] = true;

        for (Edge e: G.adj(v)) {
            int w = e.other(v);
            if (marked[w]) continue; // already on the tree; ineligible
            if (e.weight() < distTo[w]) {
                // need update
                if (pq.contains(edgeTo[w])){
                    // in fact, we may remove without the checking
                    // as remove will not report error if edgeTo[w] does not exist in pq or is null
                    pq.remove(edgeTo[w]);
                }
                pq.add(e);

                distTo[w] = e.weight();
                edgeTo[w] = e;
            }
        }
    }

    public Iterable<Edge> edges() {
        // simply scan the edgeTo[] to get all MST edges
        Queue<Edge> queue = new Queue<>();
        for (Edge e: edgeTo) {
            if (e != null) queue.enqueue(e);
        }
        return queue;
    }

    public double weight() {
        return weight;
    }

}
```

In the original solution of the textbook, an `indexMinPQ` is exploited. Here I modify it and a normal `PriorityQueue` structure would suffice. This modified version is more similar to the lazy version and easier to understand. You may also refer to the original eager version on Page 622.

In the eager version, every time time when we visit a new vertex and add it into the tree, we may check all its vertices that may be candidates of the priority queue.Two conditions should be met if an edge is added into the priority queue:

1. `e.either()` is not on the tree (avoid trace back);
2. `e` would make changes to `distTo[e.other(v)]`.

Compared with lazy version, eager version is more efficient as it reduces the size of priority queue.  

### Lazy version VS Eager version

In fact, the MST edge orders are same in both versions, and the difference is how we operate the priority queue. But eager version seems to be more efficient if `V` is smaller than `E`.

- lazy version: space proportional to `E` and time to `ElogE`;
- eager version: space proportional to `V` and time to `ElogV`;

But sometimes it is hard to notice the difference.

## Kruskal's algorithm

In fact, you may notice that the Prim's algorithm is one example of **greedy MST algorithm**. In greedy algorithm, it does not indicate how to find a cut and then add a minimal edge accordingly. Prim's algorithm answers this question by maintaining an acyclic subgraph (the current tree) and looking for the next minimal edge from the priority queue. The correctness of prim's algorithm is easily deduced by the correctness of greedy algorithm.

Is there another way to find a cut, as indicated by the greedy algorithm, and find the next minimal edge? Of course.

In Kruskal's algorithm, we process the edges in order of their weigh values, taking for the MST each edge that **does not** form a cycle with edges previously added. It is easy to prove its correctness:  The next edge to be processed, which does not form a cycle, is in fact the crossing edge of a cut defined by the set of vertices connected to one of the edge's vertices by tree edges (and its complement). This is because we process edges in such a order that there is no shorter edge connecting the two sets. You may need to refer to the figures on Page 624 for understanding.

You may find this is also an example of greedy algorithms. In this case, we define a new way to locate a cut.

It is easy to implement it with `UF` structure.

```java
 */
public class KruskalMST {

    private Queue<Edge> mst;
    private double weight;

    public KruskalMST(EdgeWeightedGraph G) {
        mst = new Queue<>();
        weight = 0.0;
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        for (Edge e: G.edges()) pq.offer(e);

        UF uf = new UF(G.V());

        while (pq.size() > 0 && mst.size() < G.V() - 1) {
            // the max size of queue is V-1;
            Edge e = pq.poll();
            int v = e.either(), w = e.other(v);
            if (uf.connected(v, w)) continue; // e forms a cycle
            uf.union(v, w);
            mst.enqueue(e);
            weight += e.weight();
        }
    }

    public Iterable<Edge> edges() {
        return mst;
    }

    public double weight() {
        return weight;
    }
    
}
```

We must use `UF` here: though the edge's two vertices are marked, the edge is still possible to be unmarked.

The output of edges are in the order of edges' weight values. It is also easy to conclude that this algorithm uses space proportional to `E` and time proportional to `ElogE`.