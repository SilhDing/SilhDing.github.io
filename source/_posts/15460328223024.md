1 Undirected Graphs

[TOC]

## Some definitions

At first, some notations should be noted.

- A graph is **connected** is there is path from every vertex to every other vertex in the graph. 
- A tree is an acyclic graph. A disjoint set of trees is called a **forest**.
- **A spanning tree** of a connected graph is a subgraph that contains all of that graph's vertices and is a single tree.
- **A bipartite tree** is a graph whose vertices we can divide into two sets such that all edges connects a vertex in one set with a vertex in the other set.

## The basic class of graph

Here is the basic class for undirected graph. In this implementation, every vertex holds a bag to record its adjacent vertices.

```java
public class Graph {

    private final int V;
    private int E;
    private Bag<Integer>[] adj;

    public Graph(int V) {
        this.V = V;
        this.E = 0;
        
        // note this part
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    public int V() {
        return this.V;
    }

    public int E() {
        return this.E;
    }

    public void addEdge(int v, int w) {
        // there is no delete method in Bag structure
        adj[v].add(w);
        adj[w].add(v);
        E ++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }

    @Override
    public String toString() {
        String s = V + " vertices, " + E + " edges\n";
        for (int v = 0; v < this.V(); v++) {
            s += v + ": ";
            for (int w : this.adj(v))
                s += w +" ";
            s += "\n";
        }
        return s;
    }

    // some static methods
    // please see this part in code base

    public static void main(String[] args) {
        // a small test
        Graph G = new Graph(5);
        G.addEdge(0, 1);
        G.addEdge(2, 1);
        G.addEdge(3, 4);
        G.addEdge(3, 2);
        System.out.println(G);
    }
}
```

## Search in undirected graph

In this case, we normally set a vertex as a source and search other vertices based on this source. A search algorithm will follow an API:

    public class Search
    -------------------
            Search(Graph G, int s) // find vertices connected to a source vertex s
    boolean marked(int v)     // is v connected to wï¼Ÿ
            int count()       // how many vertices are connected to s?
            
### Depth-first search (DFS)

No need to explain this algorithm here.

```java
public class DepthFirstSearch {

    private boolean[] marked;
    private int count;

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count ++;
        for (int w: G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    public boolean marked(int w) {
        return marked[w];
    }

    public int count() {
        return count;
    }
}
```

DFS marks all the vertices connected to a given source in time proportional to the sum of their degrees. Please note that DFS always traverses each edge in the graph twice, always finding a marked (visited) vertex the second time.

#### Finding paths by DFS

An important problem addressed by DFS is the single-source path problem. Similarly, such a algorithm follows an API:

    public class Paths
    ------------------
                      Paths(Graph G, int s) // find pathes in G from source s
                      boolean hasPathTo(int v) // is there a path from s to v?
    Iterable<Integer> pathTo(int v) // path from s to v; null if no such path
    
To implement, it is easy to exploit the `DepthFirstSearch` algorithm to find a path. We add a `edgeTo[]` to assist this algorithm. In fact, `edgeTo[]` is a parent-like representation of a tree! It records the last vertex on known path to this vertex. Please note that we cannot make sure the path discovered is the shorted path.

```java
public class DepthFirstPaths {

    private boolean[] marked;
    private int[] edgeTo;
    private final int s;

    public DepthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w: G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    public boolean hasPathTo(int v) {
        // if this vertex is marked, then there must be path to this vextex
        return marked[v];
    }

    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;

        Stack<Integer> path = new Stack<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}


    public static void main(String[] args) {
        Graph G = new Graph(5);
        G.addEdge(0, 1);
        G.addEdge(2, 1);
        G.addEdge(3, 4);
        G.addEdge(4, 2);
        int s = 0;
        
        // this is to demonstrate how to use this method
        DepthFirstPaths search = new DepthFirstPaths(G, s);
        for (int v = 0; v < G.V(); v++) {
            System.out.print(s + " to " + v + ": ");
            if (search.hasPathTo(v)) {
                for (int x: search.pathTo(v)) {
                    if (x == s) System.out.print(x);
                    else System.out.print("-" + x);
                }
            }
            System.out.println();
        }
    }
```

### Breadth-first search (BFS)

BFS algorithm is able to find the shortest path from the source to a given vertex. In DFS, we use a stack to support that algorithm (recursive call method) while is BFS a queue in used instead.

```java
public class BreadthFirstPaths {

    private boolean[] marked;
    private int[] edgeTo;
    private final int s;

    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        bfs(G, s);
    }

    private void bfs(Graph G, int s) {

        // keep a queue rather than a stack
        Queue<Integer> queue = new Queue<>();
        marked[s] = true;
        queue.enqueue(s);

        while (!queue.isEmpty()) {
            int v = queue.dequeue();
            for (int w: G.adj(v)) {
                if (!marked[w]) {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.enqueue(w);
                }
            }
        }
    }

    public boolean hasPathTo(int v) {
        return marked[v];
    }

        Stack<Integer> path = new Stack<>();
        for (int x = v; x != s; x = edgeTo[x]) {
   
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;

        Stack<Integer> path = new Stack<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }
        path.push(s);
        return path;
    }
}
```

### Connected Components

Another problem addressed by searching algorithms is to find connected components in a graph. 
    
    public class CC
    ---------------
            CC(Graph G)
    boolean connected(int v, int w)  // are v and w connected?
        int count()  // number of connected components
        int id(int v)  // component identifier for v (0 ~ count() - 1)

Note that it is only possible solved by DFS. Below is the code.
```java
public class CC {

    private boolean[] marked;
    private int[] id;
    private int count;

    public CC(Graph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        count = 0;
        for (int s = 0; s < G.V(); s++) {
            if (!marked[s]) {
                dfs(G, s);
                count ++;
            }
        }
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        id[v] = count;
        for (int w: G.adj(v)) {
            if (!marked[v]) dfs(G, w);
        }
    }

    public boolean connected(int v, int w) {
        return id[v] == id[w];
    }

    public int id(int w) {
        return id[w];
    }

    public int count() {
        return count;
    }
}
```

### Cycle detection

It is always necessary to whether a graph is cyclic. Here is a simple implementation.

Note here we use a different way to do the DFS, in order to eliminate the effects of parallel edges. To do this, every time we have to record the last vertex just visited.

Please also note the way to detect the cycle in a graph. It is simple: if a marked vertex is visited again, then a cycle is present.

```java
public class Cycle {

    private boolean[] marked;
    private boolean hasCycle;

    public Cycle(Graph G) {
        marked = new boolean[G.V()];
        for (int s = 0; s < G.V(); s++){
            if (!marked[s]) dfs(G, s, s); // to eliminate the effect of parallel edges
        }
    }

    private void dfs(Graph G, int v, int u) {
        marked[v] = true;
        for (int w: G.adj(v)) {
            if (marked[w]) dfs(G, w, v); // record the last vertex visited
            else if (w != u) hasCycle = true;
        }
    }

    public boolean hasCycle() {
        return hasCycle;
    }
}
```

### Two-colorability

Can the vertices of a given graph be assigned one of two colors in such a way that no edge connects vertices of the same color? In other words: is the graph bipartite?
It is not hard to implement: just use a standard DFS to mark color for each vertex and, in the meantime, check the colorability.

```java
public class TwoColor {
    
    private boolean[] marked;
    private boolean[] color;
    private boolean isTwoColorable = true;
    
    public TwoColor(Graph G) {
        marked = new boolean[G.V()];
        color = new boolean[G.V()];
        for (int s = 0; s < G.V(); s++) {
            if (!marked[s]) dfs(G, s);
        }
    }
    
    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w: G.adj(v)) {
            if (!marked[w]) {
                color[w] = !color[v];
                dfs(G, w);
            } else {
                if (color[w] == color[v]) isTwoColorable = false;
            }
        }
    }

    public boolean isTwoColorable() {
         return isTwoColorable;
    }
}
```

## Symbol Graph

A symbol graph would assign every vertex a name, rather than a single name. A defined API for symbol graph is as follows:

    public class SymbolGraph
    ------------------------
    boolean contains(String key)  // is key a vertex?
        int index(String key)  // index associated with key
     String name(int v)  // name associated with index v
      Graph G()  // underlying graph
      
To implement the symbol graph, three data structures are exploited here:
1. **a symbol table**: map the `String` keys (vertex names) to `int` values (vertex indices);
2. **a inverted index**: map vertex indices to vertex names; it is actually an `String` array;
3. **an undirected graph**: the underlying graph.

The key problem is how to implement `G()` from a symbol graph file (many ways to define it so the implementation is dependent). Once it is achieved, we may use the standard methods to process the graph. Please refer to Page 552 for an example.
        

