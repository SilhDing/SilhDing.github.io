## Discussion

In this document, we will explicitly discuss the working flow in the sequential program, and, more importantly, the ideas and strategies used in designing and implementing the parallelized program.

### Sequential Workflow

The sequential program is trivial to implement: it would at first initialize two repositories one by one, and get all revisions from these two repositories; it then uses a nested loop to get all revision pairs and compute similarity for each pair. A priority queue is finally used to store these pairs and sort them by similarity values, and the program will end up polling top pairs that have high similarity values with the number the user specified in the command.

### Parallelized the Program

#### Ideas and Unit of Work

We carefully studied the running time of the sequential program by executing the sequential program with different size of repositories as input. The results are shown below (Note: initialization time is used to initialize the two repositories and get all their revisions; computation time is used to compute similarities for all possible revision pairs):

| Repo configuration             | Initialization Time (s) | Computation Time (s) | Total Time (s) |
|--------------------------------|------------------------|----------------------|----------------|
| 270 revisions, 197 revisions | 1.13                   | 0.28                | 1.41           |
| 539 revisions, 649 revisions | 6.09                   | 5.40                 | 11.49           |
| 2058 revisions, 2594 revisions | 25.22                  | 70.35                 |  95.57|
| 3907 revisions, 4339 revisions | 39.03                  | 510.84               | 549.87         |

It is found that there are mainly two parts that cost substantial time during the execution:

1. Initialization of the repositories and all revisions. Since we have two repositories and we may parallelize with two threads, each initializing one repository;
2. Computation of similarity for all revision pairs. If two repositories have `M` and `N` revisions respectively, there are in total `M * N` revisions pairs. It could be a huge value if our repositories have many commits and revisions. We may also need to parallelize this part: for a single revision pair, it could compute its similarity in an exclusive thread. 

We implemented our parallelized program with the ideas above. **The unit of work would be initialization of a repository, and similarity computation for a single revision pair.**


#### Safety

Safety is a critical part in concurrent program that uses multi-process or multi-thread. Here we guarantee the safety by **making all relevant classes immutable**. Specifically speaking, we make `Revision` and `RevisionPair` immutable. Their states cannot be altered once initialization is finished, and we will not return mutable objects or data structures in public getter methods.Thus, parallelized computation would be safe:

1. Initialization of two repositories would be safe as these two threads will not access same resources;
2. Computation of similarity for all revision pairs would be safe as they will only access immutable data structures and objects (`Revision`). Each thread will only read data from the word-to-frequency map of a `Revision` object and cannot change its states.

#### Improvement

To check how the parallelized program improves the running time, we run the parallelized program with the same input, and results are shown in the table below:

| Repo configuration             | Initialization Time (s) | Computation Time (s) | Total Time (s) |
|--------------------------------|------------------------|----------------------|----------------|
| 270 revisions, 197 revisions | 1.00                   | 0.25                 | 1.25           |
| 539 revisions, 649 revisions | 4.45                   | 1.55                 | 6.00           |
| 2058 revisions, 2594 revisions | 20.61                   | 18.30                 | 38.91           |
| 3907 revisions, 4339 revisions | 23.46                  | 121.56               | 145.03         |


It is apparent that our parallelized program would significantly reduce the running time both for initialization time and computation time. When the number of revision is larger, the effect of parallelism is more apparent.

(Please note that the initialization time and computation time significantly depends on the repositories themselves. Generally speaking, we found that a repository with more commits and branches will lead to a higher initialization time, and computation time would be relatively low if the owner of the repository tends to commit small changes. Thus, it in fact makes no sense to compare results from a same program but with different input arguments, but we can compare the results from different programs with same input arguments to see how much improvement the parallelized program makes in terms of running time.)

#### Appendix

Below are repositories used for benchmarking experiments. These repositories are from different owners or projects and different in sizes, which make them suitable for benchmarking experiments.

[humiaozuzu/awesome-flask](https://github.com/humiaozuzu/awesome-flask): 270 revisions

[tiangolo/uwsgi-nginx-flask-docker](https://github.com/tiangolo/uwsgi-nginx-flask-docker): 197 revisions

[Ehco1996/django-sspanel](https://github.com/Ehco1996/django-sspanel): 539 revisions

[JoneXiong/DjangoX](https://github.com/JoneXiong/DjangoX): 649 revisions

[jazzband/django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar): 2058 revisions

[sehmaschine/django-grappelli](https://github.com/sehmaschine/django-grappelli): 2594 revisions

[dpgaspar/Flask-AppBuilder](https://github.com/dpgaspar/Flask-AppBuilder): 3907 revisions

[pallets/flask](https://github.com/pallets/flask): 4339 revisions




