# Virtualization Techniques

## Why virtualization?

- Improve Resource Utilization
- Resource & Failure Isolation
- Mixed-OS Environment
- Security Isolation

## Types of virtualization

### Hardware Virtualization

![-w842](media/15516370264328/15516382447033.jpg)

#### Virtualization Layers

**Requirements**:
- Isolation
    - Resource and failure
- Encapsulation
    - Cleanly capture all VM state 
    - Enables VM snapshots, clones
- Portability
    - Independent of physical hardware 
    - Enables migration of live, running VMs
- Interposition
    - Completely control access to all system resources
    - Transformations on instructions, memory, I/O

**Implementation**:
- Virtual Machine Monitor (VMM) ,a.k.a. hypervisor
- How does this implement interposition? (For CPU, I/O, memory, disk)
    - For performance: statistically dominant subset of the instructions must be executed directly on the CPU.
    - **CPU virtualization** 
        - Privileged instructions: **"Trap and Emulate" virtualization**
        - Non-privileged instructions: **Run as native machine**
![-w361-w400](media/15516370264328/15516388844824.jpg)
    - **Memory** 
        - VMM partitions memory among VMs
        - VMM needs to assign hardware pages to VMs
        - VMM needs to control mapping for isolation
        - **Three layers of abstraction**
        ![-w526](media/15516370264328/15516417874895.jpg)
            - **Logical**: process address space in a VM 
            - **Physical**: abstraction of hardware memory. Managed by guest OS 
            - **Machine**: actual hardware memory
- Real-World Variants
    - Direct access: VMs can directly access to devices
    - Two types of VM:
        - Native/Bare metal
        - Hosted
- Live migration
    - Running guest OS can be moved between systems, without interrupting user access to the guest or its apps
    - Supported by type 1 hypervisors

### Container Virtualization

- Problem with VM: **VM have too much overhead!**
- New ideads:
    - Multiple isolated instances of programs
    - Running in user-space (shared kernel)
    - Instances see only resources (files, devices) assigned to their container
- Requirements
    - Isolation and encapsulation
        - Resource View Isolation
            - containers should only see “their” resources, and are the only users of their resource
            - Thus each process is assigned a “namespace”
        - Resource Usage Isolation
            - meter resource usage and enforce hard limits per container
            - usage counters for groups of processes
        - File system
            - per-container filesystems without overhead of a “virtual disk” for each container
            - Thus layering of filesystems
    - Low overhead
    - Portability
- Ads:
    - Fast boot times
    - High density
    - Very small I/O overhead 
    - Require no CPU support
- Disads:
    - complexity of implemenation
    - less general (Can only run the same Operation System)
    - harder to migrate (State of containers is not fully encapsulated, state leaks into host OS)
    - larger attack surface

## In one picture!

![-w750](media/15516370264328/15516448536623.jpg)
