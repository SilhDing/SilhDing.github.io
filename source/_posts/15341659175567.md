## 146 460 LRU and LFU

这两个题目都是很有意思的题目，其中LRU稍微简单一点，LFU在LRU的基础上做了更多的延伸。总体来说思路到了都不难，主要是LFU的内容比较庞大，容易出错。

### 146 LRU Cache

在这里LRU指的是least recently used，方法其实比较简单，使用一个双向的链表，实际上就是链表的删除和插入操作等等。

```java
// 掌握两个方法，第一种是使用自带的LinkedHashMap来做，第二种实际上是对前一种的具体实现
// 重点是第二种：使用双向链表，链表的头和尾均为无内容的节点；链表的各种操作自己实现
/**
class LRUCache {
    
    private LinkedHashMap<Integer, Integer> map;
    
    public LRUCache(int capacity) {
        int CAPACITY = capacity;
        this.map = new LinkedHashMap<Integer, Integer>(CAPACITY, 0.75f, true){
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return this.size() > CAPACITY;
            }
        };
    }
    
    public int get(int key) {
        return this.map.getOrDefault(key, -1);
    }
    
    public void put(int key, int value) {
        this.map.put(key, value);
    }
}
*/


class LRUCache {
    
    class Node{
        int key, value;
        Node pre, next;
        public Node(int key, int value) {
            this.key= key;
            this.value = value;
        }
        public Node() {
            this(0,0);
        }
    }
    
    private int capacity;
    private HashMap<Integer, Node> map;
    private Node start, end;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        this.start = new Node();
        this.end = new Node();
        this.start.next = this.end;
        this.end.pre = this.start;
    }
    
    private void deleteNode(Node tmp) {
        tmp.next.pre = tmp.pre;
        tmp.pre.next = tmp.next;
    }
    
    private void insertAtEnd(Node tmp) {
        Node last = this.end.pre;
        last.next = tmp;
        tmp.pre = last;
        tmp.next = this.end;
        this.end.pre = tmp;
    }
    
    public int get(int key) {
        if (!this.map.containsKey(key)) return -1;
        Node tmp = this.map.get(key);
        deleteNode(tmp);
        insertAtEnd(tmp);
        return tmp.value;
        
    }
    
    public void put(int key, int value) {
        
        if (this.map.containsKey(key)) {
            Node tmp = this.map.get(key);
            deleteNode(tmp);
            insertAtEnd(tmp);
            tmp.value = value;
            return;
        }
        
        Node new_node = new Node(key, value);
        if (this.map.size() + 1 > this.capacity) {
            this.map.remove(this.start.next.key); // 这一行和下面一行不要颠倒，否则会错误！想想为什么？？
            deleteNode(this.start.next);
        }
        insertAtEnd(new_node);
        this.map.put(key, new_node);
        
    }
    
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

-

### 460 LFU Cache

第二个问题中的LFU指的是Least Frequently Used，那么这个题目就稍微复杂一点。同时，在移除元素的时候，要是需要移除的可能有多个（使用频率是一样的），那么就移除least recently used那个。

对于后面的那么问题，前面已经给出了解法，现在主要关心前面那么怎么实现。其实也不难：我们可以对可能每一个存在的使用频率做一个map，map的value是一个双向链表，这样就可以实现LRU的策略，同时，每次访问一个key之后，要从原有的频率对应的双向链表中拿出来，然后再放入新的。同时，设置一个全局的变量minFreq来记录当前最小的使用频率。

```java
class LFUCache {
    
    // 这个题目实际上是LRU的进阶版
    // 我们可以为每个节点加入一个count参数表示使用的次数，记录最少使用的node的使用量，并用一个map存好改用量下的所有node
    // 用一个使用量下面的所有node，可以用LRU的方法来做存储：也就是一个双向的链表
    // 这个题目可以说是非常庞大，需要耐心
    
    class Node {
        Node pre;
        Node next;
        int freq;
        int key;
        int val;
        public Node(Node pre, Node next, int freq, int key, int val) {
            this.pre = pre;
            this.next = next;
            this.freq = freq;
            this.key = key;
            this.val = val;
        }
    }
    
    class List {
        Node head;
        Node tail;
        int size;
        
        public List() {
            // please note that the head and tail are not "real"
            // these two nodes do not count in the size of the list
            head = new Node(null, null, 1, 1, 1);
            tail = new Node(head, null, 1, 1, 1);
            head.next = tail;
            this.size = 0;
        }
        
        public void delete(Node node) {
            // delete a node in the list
            Node pre = node.pre;
            Node next = node.next;
            pre.next = next;
            next.pre = pre;
            size -= 1;
        }
        
        public void add(Node node) {
            // add a node at the tail
            Node pre = tail.pre;
            pre.next = node;
            node.pre = pre;
            node.next = tail;
            tail.pre = node;
            size += 1;
        }
    }
    
    // fields
    HashMap<Integer, Node> map;
    HashMap<Integer, List> LFUMap;
    int cap;
    int minFreq;
    
    public LFUCache(int capacity) {
        cap = capacity;
        minFreq = -1;
        map = new HashMap<>();
        LFUMap = new HashMap<>();
    }
    
    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        else {
            Node cur = map.get(key);
            updateFreq(cur);
            return cur.val;
        }
    }
    
    public void put(int key, int value) {
        if (this.cap == 0) return;
        if (map.containsKey(key)) {
            // if key is contained only need to update the freq
            Node cur = map.get(key);
            cur.val = value;
            updateFreq(cur);
        } else {
            // check if full at first
            if (this.cap == map.size()) {
                // delete the least frequently used one
                // the least recently used is at the head of the list
                List list = LFUMap.get(minFreq);
                Node nodeToDelete = list.head.next;
                map.remove(nodeToDelete.key);
                list.delete(nodeToDelete);

                if (list.size == 0) LFUMap.remove(minFreq);
                
            }
            
            // add a new node
            Node nodeToAdd = new Node(null, null, 1, key, value);
            if (!LFUMap.containsKey(1)) {
                List list = new List();
                LFUMap.put(1, list);
            }
            
            List l = LFUMap.get(1);
            l.add(nodeToAdd);
            map.put(key, nodeToAdd);
            minFreq = 1;
        }
    }
    
    private void updateFreq(Node node) {
        // we will increment the freq of node and update minFreq
        List l = LFUMap.get(node.freq);
        l.delete(node);
        
        if (l.size == 0) {
            // now we may delete this key in the LFUMap and obviously minfreq would ++ if minfreq == node.freq
            LFUMap.remove(node.freq);
            if (minFreq == node.freq) minFreq += 1;
        }
        
        node.freq ++;
        if (!LFUMap.containsKey(node.freq)) {
            List new_l = new List();
            new_l.add(node);
            LFUMap.put(node.freq, new_l);
        } else{
            LFUMap.get(node.freq).add(node);
        }
    }
}

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache obj = new LFUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```