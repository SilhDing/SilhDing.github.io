## 1. 基本排序算法

先写一个可以交换的函数


```python
def swap(lyst, i, j):
    temp = lyst[i]
    lyst[i] = lyst[j]
    lyst[j] = temp
```

#### 选择排序

选择排序的核心是反复搜索整个列表然后找到最小的值，放在最前面。


```python
def selectionSort(lyst):
    i = 0
    while i < len(lyst) - 1:
        minIndex = i
        j = i + 1
        while j < len(lyst): 
            if lyst[j] < lyst[minIndex]:
                minIndex = j
            j += 1
        if minIndex != i:
            swap(lyst, minIndex, i)
        i += 1
        
lyst = [1,6,8,3,5,9,1,0,4]
selectionSort(lyst)
print(lyst)
```

    [0, 1, 1, 3, 4, 5, 6, 8, 9]


#### 冒泡排序

冒泡排序的核心在于比较交换相邻的两个值


```python
def bubbleSort(lyst):
    n = len(lyst)
    while n > 1:
        i = 0
        while i < n - 1:
            if lyst[i] > lyst[i + 1]:
                swap(lyst, i, i + 1)
            i += 1
        n -= 1

lyst = [1,6,8,3,5,9,1,0,4]
bubbleSort(lyst)
print(lyst)
```

    [0, 1, 1, 3, 4, 5, 6, 8, 9]


考虑一个特殊的情况：假如`lyst`已经是排好序的，那么这个时候，实际上第一次循环，`swap`将不会执行。因此，`bubbleSort`可以适当修改来一定程度上减小时间复杂度。


```python
def bubbleSortTweak(lyst):
    n = len(lyst)
    while n > 1:
        swapped = False
        i = 0
        while i < n - 1:
            if lyst[i] > lyst[i + 1]:
                swap(lyst, i, i + 1)
                swapped = True
            i += 1
        if not swapped:
            return 
        n -= 1 
lyst = [1,2,3,4,5,6,7,8]
bubbleSort(lyst)
print(lyst)
```

    [1, 2, 3, 4, 5, 6, 7, 8]


#### 插入排序


```python
def insertionSort(lyst):
    i = 1
    while i < len(lyst):
        itemToInsert = lyst[i]
        j = i -1
        while j >= 0:
            if itemToInsert < lyst[j]:
                lyst[j + 1] = lyst[j]
                j -= 1
            else:
                break
        lyst[j + 1] = itemToInsert
        i += 1

lyst = [1,6,8,3,5,9,1,0,4]
insertionSort(lyst)
print(lyst)
```

    [0, 1, 1, 3, 4, 5, 6, 8, 9]


有没有更好的排序方法呢？

#### 快排法


```python
def partition(lyst, left, right):
    middle = (left + right)//2
    pivot = lyst[middle]
    lyst[middle] = lyst[right]
    lyst[right] = pivot
    boundary = left # 在整个过程中，boundary始终指向比pivot大的第一个元素
    for index in range(left, right):
        if lyst[index] < pivot:
            swap(lyst, boundary, index)
            boundary += 1
    swap(lyst, boundary, right)
    return boundary
    
lyst = [1,6,8,3,5,9,1,0,4]
partition(lyst, 0, len(lyst) - 1)
print(lyst)
```

    [1, 3, 4, 1, 0, 5, 6, 8, 9]


以上的程序是为了，找到中点，然后比中点小的在左边，大的在右边，这样的话，中点的位置是唯一确定好了的。接下来，我们事先完整的排序。同时，函数的输出值是`pivot`的位置。


```python
def quickSort(lyst):
    quickSortHelper(lyst, 0, len(lyst) - 1)
    
def quickSortHelper(lyst, left, right):
    if left < right:
        pivotLocation = partition(lyst, left, right)
        quickSortHelper(lyst, left, pivotLocation - 1)
        quickSortHelper(lyst, pivotLocation + 1, right)

lyst = [1,6,8,3,5,9,1,0,4]
quickSort(lyst)
print(lyst)
```

    [0, 1, 1, 3, 4, 5, 6, 8, 9]


注意，快速排序的时间复杂度和`pivot`的选取有直接的关系，现在假如我们每次取第一个为`pivot`，那么假若列表是已经排好序的，那么，很明显，时间复杂度为`O(n^(2))`。因此，把第一个和最后一个作为`pivot`并非明确的做法。而且，这种情况下，空间复杂度也会变为`O(n)`。最好的情况下则是`O(logn)`。

#### merge sort


```python
def mergeSort(lyst):
    mergeSortHelper(lyst, 0, len(lyst) - 1)
    
def mergeSortHelper(lyst, low, high):
    if low < high:
        middle = (low + high) //2
        mergeSortHelper(lyst, low, middle)
        mergeSortHelper(lyst, middle + 1, high)
        merge(lyst, low, middle, high)
        
def merge(lyst, low, middle, high):
    i1 = low
    i2 = middle + 1
    buffer = []
    for i in range(low, high+1):
        if i1 > middle:
            buffer.append(lyst[i2])
            i2 += 1
        elif i2 > high:
            buffer.append(lyst[i1])
            i1 += 1
        elif lyst[i1] < lyst[i2]:
            buffer.append(lyst[i1])
            i1 += 1
        else:
            buffer.append(lyst[i2])
            i2 += 1
    for i in range(low, high+1):
        lyst[i] = buffer.pop(0)
    
lyst = [1,6,8,3,5,9,0,4]
mergeSort(lyst)
print(lyst)
```

    [0, 1, 3, 4, 5, 6, 8, 9]



