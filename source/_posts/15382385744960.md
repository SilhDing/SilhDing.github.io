## Morris Traversal of Tree

树的中序遍历，要是只能用iterative的方法的话，那就一般都是用stack的方法来做，但是如果要是是O(1)的空间，那就要用其他办法了。一种情况是可能这个树里面的`Node`有一个属性是`parent`，这样可以用iterative做完（也就是谷歌的那个面试题）。但是如果只是普通的tree，该怎么做呢？

接下来介绍Morris方法。这个方法不使用stack可以完成iterative的中序遍历。**这个方法的核心在于，让每一个子树最右边的节点设置一个右链接指向其下一个遍历结果**。

设置当前的节点是`curr`，那么思路如下：
1. 如果`curr`左边为空，那么打印当前结果，并且`curr = curr.right`;
2. 如果`curr`左边不为空，那么`pre = curr.left`，进入左子树，找到以`pre`为root的树的最右边节点。显然，这个节点是`curr`的pre，也即前一个；
    1. 如果这个节点右边为空，那么久设置新的链接，让这个节点的右边为其下一个遍历结果，也就是`curr`，然后`curr = curr.left`,进入左子树；
    2. 如果这个节点的右边不为空，**说明这个节点被人为操作过**。我们让`curr`等于这个节点的右指向，然后再回复节点右指向为空。此时可以打印`curr`，因为说明前面的已经便利完了，然后`curr = curr.right`进入其右子树。

```java
public void MorrisTraversal(Node root)  { 
    Node curr, pre;

    if (root == null) return ;

    curr = root;

	while (curr != null) {
		if (curr.left == null) {
			// 左边是空的
			System.out.print(curr.val + " ");
			curr = curr.right;
		} else {
			// 左边不是空的

			// 找到此时curr的前一个遍历结果
			pre = curr.left;
			while (pre.right != null && pre.right != curr) pre = pre.right;

			// 在看pre的右边有没有链接

			if (pre.right == null) {
				// 没有链接，还没有遍历，需要加上
				pre.right = curr;
				curr = curr.left;
			} else {
				// 有链接，遍历完了，调整树的结构，跳出去
				pre.right = null;
				System.out.print(curr.val + " ");
				curr = curr.right;
			}

		}
	} 
}
```

回到谷歌的那个面试题，可以修改上面的来get all leaves.