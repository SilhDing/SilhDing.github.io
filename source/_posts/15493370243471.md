# RPC: Making Remote Look Local


Please also refer to slides.
## Overview
- Client-server mode
- Interfaces
    - a set of related operations
- Historical roots of RPC
    - use message passing
        - A sends invocation message to B
        - A does other work
        - A polls for B 's reply or is interrupted
        - A receives B's reply
    - little A could do while waiting
    - explicit matching of replies complicates code
    - parallelism better exploited via threads
    - message passing offers greater generality, which is not useful in common cases
- How abt RPC?
    - well suited for the client server model
    - sacrifices some generality
    - simple to use
    - emulates familiar procedure call paradigm
    - efficient
- Characteristics
    - Two aspects: **control flow**, **invocation syntax**
    - **control flow**
        - caller makes request and blocks
        - callee services request and replies
        - caller resumes
        - There is thus synchronous transfer of control
    - invocation syntax: match host language
    - limitation
        - cannot use pointers as different address, thus
            - can’t share global data 
            - can’t use call-by-reference 
            - only call-by-value-result 
            - large data structures can be expensive
            - procedure parameters don't work easily 
            - up-level addressing doesn't work easily
    - more failure mode
        - network failure, server machine crash, process crash
        - failure handling code to be more thorough
    - security issue
        - local calls normally within same security domain
        - remote calls often cross domains
        - remote RPC implementation may not be trusted!
        - security concerns play a bigger role in RPC
    
    Here is an overview of RPC:
    
    ![-w842](media/15493370243471/15493390361152.jpg)

## Stub generation
- stub generation
    - client stub:
        - pack parameters
        - invoke RPC transport, block, check for runtime errors
        - unpack reply
    - server stub:
        - unpack parameters
        - examine opcode and demultiplex
        - invoke server procedure locally
        - pack reply packet
        - invoke RPC transport to send reply
- two problems
    - interface description
        - interface definition language
        - name and parameters of each procedure
        - parameter usage: in, out, inout
        - 
    - code generation

```
// client stub example
foo (in int32 a, inout int64 b, out int32 { 
    pack a and b into packet p;
    makerpc (p, &q); 
    check for runtime errors 
    unpack b and from packet q 
    return;
}
```

```
.. server stub example
while (1) { 
    get-request (&p); /* blocking call */ 
    execute-request (p); /* demux based on opcode */ 
}

execute-request (packet *p, packet *q) {
    switch (p->opcode) {
        case 1:
            allocate memory for parms 
            unpack in and inout parms for opcode 1 
            proc1 (all parms); 
            pack inout and out parameters for opcode 1 
            deallocate memory 
            send-response (q) 
            break;
        case 2: 
            similar code for opcode 2
        case 3:
            similar code for opcode 3
            ..........
    }
}
```
## RPC Transport

Real distributed systems are flaky:
- server hardware failures, server software failures, ...
- lost packets, mutilated packets, hard network failure ...
- 1 invocation by caller may or may not succeed
- even more complexity in store, as discussed below

### timeout

If reply not in when timer goes off, client declare failure. But:
- lost packets for transient reasons common: giving up too soon is pessimistic (maybe server never received your request)
- perhaps server is still computing or perhaps it is overloaded (or perhaps it sent a reply, and this was lost)

How to pick a perfect timeout value? **No such a value!**
- at best, using known statistics, one can pick a “reasonable” value
- no matter what value is picked, it could be “too soon”

Can we do transmission？
- assumes cause was transient condition (request pkg is lost), and this retry will get through
- RPC layered on TCP: handled by TCP; on UDP: handled by RPC layer

But what is sluggish server or lost reply 
- executing second request packet (one invocation causes multiple computations)
- violates local emulation semantics
- server must perform **duplicate elimination**: able to identify retransmission (by per-connection sequence number, and only most recent sequence number is needed)
- Replies must be preserved: cannot re-compute reply (avoid multiple computation)

### Exactly-once

How long to keep old replies and sequence numbers?

- rigorous: forever!
- save it in non-volatile memory

Such an RPC would have exactly-once semantics
- success return from RPC call -> call executed exactly once
- call blocks **indefinitely**, no failure return
- Not appropriate for many real applications
    - too slow because of synchronous disk writes
    - indefinite blocking unacceptable in many cases
    - application-level recovery precluded
    - requires transactional semantics for server actions

### At-most-once

How to avoid indefinite blocking?
- declare timeout if call takes longer than specified bound

Such an RPC has at-most-once semantics
- success -> call executed exactly once
- timeout -> call executed once or not at all

Many possible reasons for RPC timeout
- request and retries never got to server
- server died while working on request
- network broke while server working on request
- server still working on request
- server replied, but reply lost
- server resent reply, but all copies of reply lost

Servers may be sluggish or unreachable
- complicates setting of timeout value
- probes to check server health during long calls
- server responds with busy if still working
- essentially a keepalive mechanism

### Orphaned Computations

Danger with at-most-once semantics
- client sends request, server starts computing
- network failure occurs
- server continues, unaware its work is useless (server may hold resources (e.g. locks), slowing other activity)

**Orphan detection and extermination are difficult!**

### Choices of semantics

Achieving exactly-once semantics
- not provided by any real RPC package
- requires application-level duplicate elimination
- built on top of at-most-once RPC
Most RPC packages provide at-most-once RPC

At-most-once semantics avoids
- transactional storage
- non-volatile storage of replies and sequence #s
- indefinite storage of replies

### At-least-once

- requires operation idempotency, e.g., `read()`
- implementation can be completely stateless on server side
    - even sequence numbering to detect duplication can be avoided

### Safety and Liveness Properties

- Safety property: characterizes correct functionality
    - bad things will never happen
    - **Exactly-once**
- Liveness property: characterizes timely execution progress
    - good thing will eventually happen
    - **liveness property**

### Cross-language RPC

- Mapping of data types has to be defined
    - very hard to solve in full generality
    - hard to handle exception

## RPC Protocol and E2E

### TCP is useful?

- exactly-once RPC no easier with TCP
    - still have to do duplicate elimination
    - orphans still possible
- TCP can simplify at-most-once RPC
    - absence of TCP failure -> exactly once RPC
    - on TCP failure, declare RPC failure
    - or say, these two are similar
- performance is worse
    - 4 packets for best case; UDP only two

### End-to-end

For given functionality:
- correctness is expressed relative to two endpoints (safety)
- implementation requires support of those two end points
- support below end points cannot suffice
