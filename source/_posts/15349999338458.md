## Binary search: some advanced examples

### 300. Longest Increasing Subsequence

Given an unsorted array of integers, find the length of longest increasing subsequence.

    Input: [10,9,2,5,3,7,101,18]
    Output: 4 
    Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
    
At first we will give a simple DP solution which run in O(n^2) time:

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        
        int n = nums.length;
        int res = 1;
        int[] dp = new int[n];
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            int k = i - 1;
            while (k >= 0) {
                if (nums[i] > nums[k]) dp[i] = Math.max(dp[i], dp[k] + 1);
                k --;
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

This solution is self-explanatory and no more detail here. Below it is another solution that is much better in running time: less then O(nlgn) time.

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // the second solution is a good exploitation in binary search.
        // say tail in an array where tail[i] refer to the smallest tail among tails of all continuous arrays with length of i+1
        // Integer size is the max length of continuous subsequence we have up to now
        // every time we have a new number from nums: do baniray search
        // if found that tail[i] < num <= tail[i+1] then update tail[i+1] = num
        // if num is larger than all numbers in tail then we increment size by 1
        // explanation: every time we get a new number from nums, it is possible to update an entry in nums
        // but in what conditions: to update tail[i+1], must be: num < tail[i+1]
        // then, updating tail[i+1] we have to make sure that we are able to find such a new sequence that is increasing
        // it is simple: just to make sure that tail[i] < num
        // we did not update tail[i+2] or more number afterwards because we cannot find a sequence which is increasing
        // we do not update tail[i] or more numbers in the front since there is no difference with them
        
        int size = 0;
        int[] tail = new int[nums.length];
        for (int num: nums) {
            int i = 0, j = size;
            while (i < j) {
                int mid = (i + j) / 2;
                if (num <= tail[mid]) {
                    j = mid;
                } else {
                    i = mid + 1;
                }
            }
            tail[i] = num;
            if (i == size) size ++;
        }
        return size;
    }
}
```

To understand why we have to update `tail[i+1]` if we find that `tail[i] < num <= tail[i+1]`, let's think about an example below:

Say we have scanned `nums` for `[4,7,10,6,13]` and obviously `tail` is something like:

    [4, 6, 10, 13]
    
and now here comes a new number `9`. Follow the instruction in the comment you will convince yourself that the algorithm is right.

The problem [354](https://leetcode.com/problems/russian-doll-envelopes/description/) could be smartly solved based on this solution.

### 4 Median of two sorted arrays

This problem is very classic. Here are some solutions that are most common.

- Linear search: time complexity is O(n) and it is trivial to implement, but you have to generalize the two case.
- Find `k`th element using binary search in the merged array: time complexity is O(log(m+n)). 
- find cutting position using binary search: time complexity is O(log(min(m, n))).

We will start to analyze each of them except the first one. For detailed information you can access [this](https://windliang.cc/2018/07/18/leetCode-4-Median-of-Two-Sorted-Arrays/) link.

##### Find `k`th in the merged array

The basic idea is we compare `k/2` numbers in each array, and we can make sure that some numbers must not be the `k`th number, so we can remove them.

```java
public double findMedianSortedArrays2(int[] nums1, int[] nums2) {
        // https://windliang.cc/2018/07/18/leetCode-4-Median-of-Two-Sorted-Arrays/
        // refer to the url for detailed idea
        // this solution is Genius!
        // still binary search, but more flexible and smarter
        
        // we cen generalize two cases
        int len1 = nums1.length, len2 = nums2.length;
        int k1 = (len1 + len2 + 1) / 2, k2 = (len1+ len2 + 2) / 2;
        return (findKth(nums1, 0, len1, nums2, 0, len2, k1) + 
               findKth(nums1, 0, len1, nums2, 0, len2, k2)) / 2;
    }
    
    
    private double findKth(int[] arr1, int start1, int m, int[] arr2, int start2, int n, int k) {
        // find kth smallest elements in the merged array
        // note that k is not the index: 1-based
        // m, n is the length
        
        // always make sure that len1 < len2
        if (m > n)  return findKth(arr2, start2, n, arr1, start1, m, k);
        if (m == 0) return arr2[start2+k-1];
        if (k == 1) return Math.min(arr1[start1], arr2[start2]);
        
        // now do the binary search
        int i = Math.min(m, k/2);  // offset 
        int j = Math.min(n, k/2);
        
        if (arr1[start1 + i - 1] < arr2[start2 + j - 1]) {
            return findKth(arr1, start1 + i, m - i, arr2, start2, n, k - i);
        } else {
            return findKth(arr1, start1, m, arr2, start2 + j, n - j, k - j);
        }
    }
```

##### Finding cutting position

This solution starts from the definition of medians, and try to cur each array to meet some requirements.

        //       left_part          |        right_part
        // A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
        // B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
        // we have tp make sure:
        // i + j < m + n - i - j
        // A[i-1] < B[j]
        // B[j-1] < A[i]

So the main problem is to find `i` that meet the requirements above: use binary search.


```java
public double findMedianSortedArrays(int[] A, int[] B) {

    // this is the third solution
    // the basic idea is to find i and j, so that
    // A[0], A[1], A[2], … A[i-1] | A[i], …, A[m-1]
    // B[0], B[1], B[2], … B[j-1] | B[j}, …, B[n-1]
    // 1.i + j = m-i+n-j, so j = (m+n)/2-i. We can generalize it 
    // by j  = (m+n+1)/2 -i. So left is equal to right or have one
    // element. Make sure that m <= n
    // 2. A[i-1] <= B[j] && B[j-1] <= A[i]
    // then we use binary search to find i.
    
    int m = A.length, n = B.length;
    if (m > n) return findMedianSortedArrays(B, A);

    int left = 0, right = m;
    while (left <= right) {
        int i = (left + right) / 2;
        int j = (m + n + 1)/ 2 - i;
        if (i != 0 && j != n && A[i-1] > B[j]) {
            // not valid: need to decrease i
            right = i - 1;	
        } else if (j != 0 && i != m && B[j-1] > A[i]) {
            left = i + 1;
        } else {
            // now it is valid
            // Note: corner cases would appear here
            // get the result, note we need to be careful
            int maxLeft = 0, minRight = 0;
            if (i == 0) {
                maxLeft = B[j-1];
            } else if (j == 0) {
                maxLeft = A[i-1];
            } else {
                maxLeft = Math.max(A[i-1], B[j-1]);
            }
            
            if (((m + n) % 2) == 1) return maxLeft;
            
            if (i == m) {
                minRight = B[j];
            } else if (j == n) {
                minRight = A[i];
            } else {
                minRight = Math.min(A[i], B[j]);
            }
            return ((double)maxLeft + minRight)/2;
        }
    }
    return 0.0;
}
```

### 410 Split Array Largest sum

Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.

Note:
If n is the length of array, assume the following constraints are satisfied:

- 1 ≤ n ≤ 1000
- 1 ≤ m ≤ min(50, n)

Using binary search here is very smart. But before talking about it, we also have a DP solution for this problem. Please check the DP solution in other notes.

The binary solution is very smart and not hard to understand. First of all, it is trivial to get that the final output must be between max of the array and sum of the array. It also defines how the range for binary search. 

The next step is, if we pick a value from that range, how can we determine the validity of the value? Is that too big or too small? Here we use a `valid` function to determine that value. With the array `nums`, we cut the array in a greedy way: pick the entry in the array from the left and aggregate the sum; if the sum would exceed the target, we prepare a new sub array.  If the number of sub arrays is equal or smaller than `m`, return true; else false.

- If returned value is true, then it means the current split is valid or we can make more smaller pieces to make it valid; and target might be the final result, or bigger than the final result;
- If returned value is false, then it means we cannot make such a split with the `target` value. We should pick a smaller value.

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        // binary search
        // very smart
        int sum = 0, max = 0;
        for (int num: nums) {
            sum += num;
            max = Math.max(max, num);
        }
        
        if (m == 1) return sum;

        int l = max, r = sum;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (valid(mid, nums, m)) {
                r = mid-1;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    private boolean valid(int target, int[] nums, int m) {
        int running_sum = 0;
        int count = 1;
        for (int num: nums) {
            if (running_sum + num > target) {
                running_sum = num;
                count ++;
                if (count > m) return false;
            } else {
                running_sum += num;
            }
        }
        return true;
    }
}
```