## 关于正则匹配的问题总结

### 44 Wildcard Matching

正则匹配问题

`?` Matches any single character.
`*` Matches any sequence of characters (including the empty sequence).

其实不难，用pointer和dp都可以做。

```java
class Solution {
    public boolean isMatch(String string, String pattern) {
        // dp的方法
        boolean[][] dp = new boolean[string.length()+1][pattern.length()+1];
        dp[0][0] = true;
        for (int j = 1; j <= pattern.length(); j++) {
            if (pattern.charAt(j-1) == '*') dp[0][j] = true;
            else break;
        } 
        
        for (int i = 1; i <= string.length(); i++) {
            for (int j = 1; j <= pattern.length(); j++) {
                if (string.charAt(i-1) == pattern.charAt(j-1) || pattern.charAt(j-1) == '?')
                    dp[i][j] = dp[i-1][j-1];
                else if (pattern.charAt(j-1) == '*') 
                    dp[i][j] = dp[i][j-1] || dp[i-1][j];
                    // 第一个意思是*长度为0
                    // 第二个意思是长度不为0，应该dp[i-1][j]、dp[i-2][j]等等都算在里面，但是考虑到递进的关系，只要考虑最后一个就行
                    // 全部列出来也是没有问题的
            }
        }
        return dp[string.length()][pattern.length()];
    }
}

class Solution2 {
    public boolean isMatch(String str, String pattern) {
        // 有几点说明一下
        // 首先，非*的情况下，是很容易理解的，只要一起移动两个指针就好了
        // 主要是怎么实现对*的匹配
        // 一旦出现*，那么记录此时*的位置，和准备与str匹配的位置，也就是match，从这个match位置，让*之后的第一个位置与str的s开始匹配
        // 假如此时的s和p是不一样的，那么因为*可以代表多个char，所以s需要移动，移动的方法是match加一再给s赋值。
        // 假设现在s和p已经有了相同的指向了，移动了几轮之后，突然发现无法继续匹配了，那么，我们需要跳回原来的位置，开始匹配，该怎么做？
        // 这个时候，s和p可能已经在很后面了，需要把其拉回来重新匹配，这个时候match在哪里呢？match在和*后第一个元素第一次匹配的地方
        // 那么要寻找下一个匹配对象的话，需要把match往后移，再给s赋值，直到s和p又可以开始匹配。
        // 当s中的元素已经遍历完后，假如p中还剩元素，这个时候只能是*了，否则，明显，匹配会失败。
        // str = "acdcb", pattern = "a*c?b" 是一个很好的例子，可以画画图加深理解
        int s = 0, p = 0, starIndex = -1, match = 0;
        while (s < str.length()) {
            if (p < pattern.length() && (pattern.charAt(p) == '?' || pattern.charAt(p) == str.charAt(s))){
                s++;
                p++;
            } else if (p< pattern.length() && pattern.charAt(p) == '*') {
                starIndex = p;
                match = s;
                p++;
            } else if (starIndex != -1) {
                p = starIndex + 1;
                match ++;
                s = match;
            } else return false;
        }
        while (p < pattern.length() && pattern.charAt(p) == '*') p++;
        
        return p == pattern.length();
    }
}
```
