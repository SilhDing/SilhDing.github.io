## Django中出现的`Class Meta`解释

在项目的代码中出现了这样的一段代码，很是费解。

```python
class Audit(PtcModel):

    class Meta:
        db_table = settings.AUDIT_TABLENAME
        
    taskId = models.BigIntegerField(u'taskid', unique=True)
    
    def ...
```

翻阅了一下，做一个小小的总结。

#### 关于`Class Meta`

首先可以看到`class Meta`是嵌套到我们的`Model`类里面的，所以是一个内嵌类，同时，`class Meta`定义的数据统称为元数据选项。其实和python3中的`metaclass`有相似的定义类型。（虽然我不知道python2.7是不是支持同样的语法，但是面试时元类也是按照python3的语法说的现在想想真的是好虚啊……）

请记住，元数据选项（meta options）是固定好的，我们可以在meta中重新定义这些选项。下面是几个比较重要的选项。

#### `Options.abstract`

`abstract`是一个`boolean`类型的变量。假如`abstract=True`, 那么这个model就是一个抽象基类。（关于抽象基类赶快去看完数据结构= =！）

#### `Options.app_lable`

在一般情况下，借助Django良好的App管理模式，一个model一般是定义在默认的app目录下的`models.py`中，但是也会有例外，也就是这个model在默认的`models.py`之外，这个时候必须要用`app_lable`来指明其属于哪一个app。比如：

```python
class Meta:
	app_lable='myapp'
```

#### `Options.db_table`

这是一个很重要的概念。首先需要明确，为了节省时间，Django会根据类的名称和其被包含的app来自动制定数据库中table的名称。一个Model的数据库表名称，由这个Model所在的应用名称加上下划线再加上model名称组成。

比如，现在`bookstore`应用下有一个名为`Book`的模型，那么数据表的默认名称就是`bookstore_Book`。

利用Meta类中`db_table`参数可以重新写数据表的名称。数据表的名称可以是SQL保留字，也可以包含不允许出现在python变量中的特殊字符，因为Django可以自动给列名和表名添加引号。

#### `Options.managed`

默认值为`True` ，这意味着 Django 可以使用`syncdb`和`reset`命令 来创建或移除对应的数据库。换句话说， Django 管理 了数据库的生命周期。

如果设置为`False`，Django 将不会为当前model创建或者删除数据库表。通常在表示某个通过其他方法创建的现有数据表时这会非常有用。这是当`managed=False`时仅有的不同之处。model在处理所有其他方面的事情时是完全一致的。这包括:

* 如果没有声明主键字段，Django将自动的为model增加一个自增的主键字段。当你使用不被管理的models时，为了避免让将来阅读代码的人迷惑，建议指明所有所有托管在model中的字段与数据库表的关系。

* 如果两个非托管的models(`managed=False`) 之间，使用了`ManyToManyField`关联，就不会创建多对多关系的中间表。然而 如果是一个托管的model与另一个非托管的model的话，多对多关系将会被创建。如果你需要改变默认的行为，就的显示的定义中间 model 来在数据库中创建中间表(要将`managed`设置为`True`)，然后在你的原model上使用`ManyToManyField.through`属性指向中间model，就能实现自定义的多对多关系。

如果你的测试中包含非托管model(`managed=False`)，那么在测试之前，你应该要确保在测试创建时已经创建了正确的数据表。

#### More Infomation
可以看看[这个](http://django-chinese-docs-14.readthedocs.io/en/latest/ref/models/options.html)链接。


