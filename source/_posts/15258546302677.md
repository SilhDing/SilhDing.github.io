# Python Package Notes

Now we consider a directory whose structure is as showed below:


    - nose_test_demon
        - DictModule
            - __init__.py
            - mydict.py
        - test
            - __init__.py
            - test_mydict.py

Here is a small project where a new data structure inherited from `dict` is build and we will use module `nose` to test the features of this new class. Here are what I leanred:

## Role of file `__init__.py`:
Once you use `__init__`, the directory in which such file is placed is treated as a **package**. Then, everytime when we **'import'** a package, actually we are importing all elements existed in `__init__.py` which places in the package directory. If the `__init__.py` is empty, actually we do not import anything.

Let's consider an example to demonstrate it. Now use `cmd` and `cd` the directory `nose_test_demon`. Enter `python` and try some `import` sentences and get their results (all `__init__.py` files are empty now):

    >>> import DictModule   # no error
    >>> d = DictModule.mydict.Dict() # error: has no attribute named 'mydict'


    >>> import DictModule.mydict  # no error
    >>> d = DictModule.mydict.Dict() # no error

Such results, in fact, are easy to understand if we get the role of `__init__.py`. In `import` statement, we may always treat `XXX.XXX.XXX` after `import` as a file path, but we cannot do this like in `d = DictModule.mydict.Dict()`. In these two cases, you may treat what you import as **names of variable**, e.g., `DictModule` and `DictModule.mydict`, and the only thing we have to consider is that what attributes these variables have. But if we only want to import `DictModule`, what should we do? let add some stuffs in `__init__.py`:

```python
# __init__.py
import mydict
```
    
and now try again:

    >>> import DictModule   # no error
    >>> d = DictModule.mydict.Dict() # no error

Samely, if we write like `from mydict import Dict`, we may even use like:

    >>> import DictModule   # no error
    >>> d = DictModule.Dict() # no error

**In a word, the `__init__.py` defines the way we import a package and the way we use its contents,** and it acts, at least ostensibly, to assign attributes to a directory. If we write like `import DictModule.mydict`, it is not necessary to place a `__init__.py` file in that directory, i.e., it is not a package anymore, though we could still import modules from that directory (now it is used like a *file path*).

In addition, it is common to see something like:

    from <module-name> import *
   
to import all contents from that module or file. Note that this is also assisted by the file `__init__.py`. If that file is empty or does not exist, nothing would be imported.

## Always use `sys.path` to see the import paths

If you run a single `*.py` file like `python *.py`, except the system paths, the import path would be always be the directory in which the `*.py` file is placed. So, you are not able to import anything out of this module. For example, let's look at the small test project at the top of this article: in `test/test_mydict.py` file, we have to import a class from `DictModule/mydict.py`, so we add `from DictModule.mydict import Dict` in that file; if we solely run `test/test_mydict.py`, it would fail. If you use `sys.path` to see the import path, you could only see:

    ['/home/yihang/文档/coding/nose_test_demon/test', ...

However, if you run nose to execute such test task like 

    $: ~/文档/coding/nose_test_demon$ nosetests -s -v

There is no mistake at all. Seemingly that *using nose or other similar plugin to execute this project would modify the 'sys.path'*. Once again, let's print out `sys.path`:

    ['/home/yihang/文档/coding/nose_test_demon/test', 
     '/home/yihang/文档/coding/nose_test_demon', ...
    
Our guess is right. Anyway, when you are really confused with import path, just try more with **`sys.path`** to make your mind clear.






