## 239 Sliding Window Maximum 好聪明啊

Given an array nums, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.

    Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
    Output: [3,3,5,5,6,7] 
    Explanation: 
    
    Window position                Max
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7

这个题目有很多方法可以做，但是发现有一个解答非常聪明，可以保证时间是`O(n)`，非常有意思。先看解法:

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0 || nums == null) return new int[0];
        int n = nums.length;
        int[] left_max = new int[n];
        int[] right_max = new int[n];
        int[] res = new int[n-k+1];
        
        int lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (i % k == 0) lmax = Integer.MIN_VALUE;
            lmax = Math.max(lmax, nums[i]);
            left_max[i] = lmax;
            
            int j = n - 1 -i;
            if (j % k == k - 1) rmax = Integer.MIN_VALUE;
            rmax = Math.max(rmax, nums[j]);
            right_max[j] = rmax;
        }
        for (int i = 0; i < res.length; i++) {
            res[i] = Math.max(right_max[i], left_max[i+k-1]);
        }
        
        return res;
    }
}
```

这个解法的思路是：

1. 先按照`k`分组`nums`，每`k`个一组；
2. `left_max`表示每个组中，从左边开始的目前最大值；每个组的操作是独立运行的；
3. `right_max`也是类似的，从右边开始数。
4. 输出的结果为：`res[i] = Math.max(right_max[i], left_max[i+k-1])`

这个过程可以从下面的一个例子理解：

![Picture6-w500](media/15310426731287/Picture6.png)

其中相连的圆圈就是`right_max[i]`和`left_max[i+k-1]`。我们把箭头所指向的那一个window作为例子来看，等于现在要的结果**第一个区间后两个数**和**第二个区间前两个树**的最大值。而第一个区间后两个数的最大值就是`right_max[i]`，第二个区间前两个树就是`left_max[i+k-1]`，所以我们只要取这两个的最大值就可以了。

**That's so clever!**

