## Docker里使用crontab以及systemctl
五一节，放假完毕后的第一天，挤地铁挤成狗到了公司后，leader让我把部署在公司qae的镜像给他看看，然后看了一会后让我加上crond的启动功能，实现脚本的定时运行。没想到，这个小问题让我纠结了好久。下面是具体的过程。

首先，先尝试一下在镜像里直接使用crond。在启动了docker的centos定制镜像之后，想使用crontab但是提示如下错误：`Failed to get D-Bus connection: Operation not permitted`

解决方法：

    $ docker run -d --privileged=true IMAGE:TAG /usr/sbin/init

如果已经在Dockerfile里面设置了入口为`/usr/sbin/init`那么可以不在上面添加`cmd`的参数。

然后再进入容器：

    $ docker exec -it CONTAINER_ID /bin/bash

那么，为什么会有这样的错误呢？这是因为docker本身的原因。实际上，docker的设计理念是在容器里面不运行后台的服务，因为容器本身就是宿主机上一个独立的主进程，**一个容器的生命周期是围绕着这个主进程存在的**。所以，一般而言，使用容器的正确方法是将里面的服务运行在前台。

其次，在centos7中，我们使用`systemd`来管理系统服务程序。说到`systemd`，这个套件已经成为主流Linux发行版（比如CentOS7、Ubuntu14+）默认的服务管理，取代了传统的SystemV风格服务管理。`systemd`维护系统服务程序，它需要特权去访问Linux内核。而容器并不是一个完整的操作系统，只有一个文件系统，而且默认启动只是普通用户这样的权限访问Linux内核，也就是没有特权，所以自然就用不了！

当然，一定要这样运行，也是可以的，方法就是上面的方法。一般会先用`-d`参数让容器运行在后台，而参数`/usr/sbin/init`可以放在Dockerfile的`CMD`或者`ENTRYPOINT`中，这样使用启动镜像时就不需要再使用参数。然后，再使用`docker exec`来进入容器的伪终端。

进入后，安装支持包。只需要用`yum`命令安装`crontabs`这一个就可以，相应的依赖包会自己安装。除了这个，再安装`rsyslog`，这个用来记录`cron`的相关日志信息。

总之，安装好包，修改好了入口，在`run`时也赋予了权限之后，就可以在docker中使用crond了。

接下来，可直接用`crontab -e`来修改crond的任务，然后，可以使用`tail -f /var/log/cron`或者直接`cat /var/log/cron`来查看日志，这两个的区别是`tail`可以保持追踪`cron`文件内的信息，需要`ctl`+`c`退出。

这样一来的话就可以完成操作了，事实证明也不会有错。如果想偷懒，这个时候就可以直接使用`commit`语句来生成一个新的镜像了，并且经过测试，这个新的镜像如果按照上面的方法运行的话，crond可以自动启动，没毛病。

#### 但是！作为一名以完美为目标的程序员，这样就够了吗？
**`commit`是不适合用来创建镜像的。**这点还是要强调很多次才行。首先对容器的改动并不能反映在Dockerfile中，不知道的人根本不知道对容器会有什么改进、动；其次，假如之后新`tag`的镜像出现，那无法用Dockerfile一次创建完成，必须运行镜像做手动的改动才行。这当然不是我们愿意看到的。所以我们要在Dockerfile里面一次配置。 其实，配置起来也很简单，只要在Dockerfile里面加上如下的语句（提前准备好`crontabfile`）。

    RUN crontab /var/vtc_admin/crontabfile \
        && cp /var/vtc_admin/crontabfile /var/spool/cron/root

**当然了！我是不可能一次性就成功的。一开始的代码是这样的：**

    RUN crontab /var/vtc_admin/crontabfile \
        && cp /var/vtc_admin/crontabfile /etc/crontab

但是会有很奇怪的错误产生。首先来看这个`crontabfile`包含那些内容：

    SHELL=/bin/bash
    PATH=/sbin:/bin:/usr/sbin:/usr/bin
    MAILTO=root
    HOME=/
    
    */10 * * * * /var/vtc_admin/ptc/stats_data.py > /dev/null

里面是执行一个python的脚本任务，每十分钟执行一次。但是在运行的时候，在`/var/log/cron`中可以看到有错误信息：`getpwnam() failed`。这是为什么呢？

原因在这里，请注意，在`/etc/crontabfile`存储的内容，是**系统级任务**，并且，系统级任务一般需要任务中指明执行该任务的用户才行。所以，上面的任务语句应该写成：

    */10 * * * * root /var/vtc_admin/ptc/stats_data.py > /dev/null

这样一来，就可以知道是由`root`执行这个任务了。改动完毕后，再尝试，还是出现了错误： `/bin/bash: root: command not found`。其实只要理解好了cron任务的原理，也能明白怎么回事了。前面讲到了系统级的任务，那么相对应的，也有用户级的任务。用户级的任务一般是储存在`/var/spool/cron/`下的，这个目录下可以看到很多的文件，每一个文件名就是用户名。在上面的错误出现时，我们可以进去看一下`/var/spool/cron/root`这个文件，可以看到其中的任务语句为：

    */10 * * * * root /var/vtc_admin/ptc/stats_data.py > /dev/null

也就是说这个语句和crontabfile中的任务语句是一样的。但是，请记住，**用户cron语句不需要去指明用户是谁**，原因也很简单，因为其已经是存储在了用户专门的文件中了，不用再多此一举。否则，这个root会被当成`cmd`的一部分，从而产生上面的错误。

那么，怎么解决这个问题呢？首先需要明确的是，实际上，**系统级任务和用户级任务是都会执行的**，一般来说，还会在crontabfile里面看到`run parts`的语句，一般执行的都是hourly/monthly任务，所以如果让crontabfile为空并且只给`/var/spool/cron/root`赋予内容（不包含`root`用户名的关键字），问题就解决了。所以Dockerfile里面应该写成：

    RUN crontab /var/vtc_admin/crontabfile \
        && cp /var/vtc_admin/crontabfile /var/spool/cron/root

并且cron任务中不带`root`用户名。实际上，在用`crontab -e`这个指令时，如果不带参数，默认修改的是root用户的用户任务内容，也就是`/var/spool/cron/root`的内容。问题解决后，`cat /etc/crontabfile`没看到有任务，但是`crontab -l`和`cat /var/spool/cron/root`均可以看到设置的定时任务，问题解决。

这个问题解决之后，就没有什么问题了，`tail -f /var/log/cron`也可以看到任务按照预期执行，唯一的缺憾就是在运行时需要加上`--privileged`参数。我们在手动运行的时候是没有什么问题的，加上就好了，但是很多时候，公司有自己内部的APP管理引擎。爱奇艺的QAE就是一个强大的App Engine，用户上传了自己的镜像后可以直接创建应用并且简历容器，这个时候是不能加上参数的，那怎么办呢？

没办法了，我只能自己再写一个python脚本，定时执行`stats_data.py`，并把执行脚本作为容器的入口（反正QAE在进入容器时也是不能加上自己的`cmd`的，只能使用默认入口），同时，脚本中使用`logging`把日志写到固定的文件，这样也可以完成定时任务。

### 所以我最后还是没有用cron完成定时脚本执行……🙂🙂🙂🙂🙂🙂🙂🙂
### 只能说systemd和docker真的是互相都看不惯对方……🙂🙂🙂🙂🙂🙂


