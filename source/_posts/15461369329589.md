2 Directed Graphs

[TOC]

## Some definitions

Some definitions are noted here.
1. The **outdegree** of a vertex in a digraph is the number of edges going from it; the **indegree** of a vertex is the number of edges going to it;
2. The first vertex in a directed edge is **head** and the second one is **tail**;
3. A **directed cycle** is a directed path with at least one edge whose first first and last vertices are the same. A **simple cycle** is a cycle with no repeated edges or vertices.
4. We say that a vertex is **reachable** from a vertex `v` if there is a directed path from v to w.
5. Pls.note that **reachability** and **connectivity** are different.

## Class and data type

Similarly, the directed graph follows a defined API:

    public class Digraph
    --------------------
                      Digraph(int V)
                  int V()
                  int E()
                 void addEdge(int v, int w)
    Iterable<Integer> adj(int v)
              Digraph reverse() // reverse of this graph
               String toString()
               
The API also supports a methods to return a copy of the directed graph with all edges reversed. This methods sometimes is helpful as it allows clients to find the edges that point *to* each vertex. Below is an implementation.

```java
public class Digraph {

    private final int V;
    private int E;
    private Bag<Integer>[] adj;

    public Digraph (int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[])new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(int v, int w) {
        adj[v].add(w); // v -> w
        this.E ++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }

    public Digraph reverse() {
        Digraph R = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w: adj(v)) {
                R.addEdge(w, v);
            }
        }
        return R;
    }
}
```

## Reachability in digraphs

In undirected graph the single-source connectivity problem is solved by DFS. Here, in directed graph, a similar problem is the **single-source reachability**. The API is as follows:

    public class DirectedDFS
    ------------------------
            DirectedDFS(Digraph G, int s) // find vertices in G that are reachable from s
            DirectedDFS(Digraph G, Iterable<Integer> sources) // find vertices in G that are reachable form sources
    boolean marked(int v)  // is v reachable?
    
The second constructor allows a generalization of the original problem: **multiple-source reachability**. That is, given a digraph and a set of source vertices, is there a directed path from any vertex in the set to a given target vertex `v`?

It is easy to handle this problem with the standard DFS in the undirected graph.

```java
public class DirectedDFS {

    private boolean[] marked;

    public DirectedDFS(Digraph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    public DirectedDFS(Digraph G, Iterable<Integer> sources) {
        marked = new boolean[G.V()];
        for (int s: sources) {
            if (!marked[s]) dfs(G, s);
        }
    }

    private  void dfs(Digraph G, int v) {
        marked[v] = true;
        for(int w: G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    public boolean marked(int v) {
        return marked[v];
    }
    
}
```

## Finding paths in digraphs

`DepthFirstPaths` and `BreadthFirstPaths` in undirected graphs are also useful here. It would help solve the following problems:
1. Single-source directed paths;
2. Single-source shorted directed paths.

No need to repeat the codes here.

## Cycles, ADGs and Scheduling Problems

Directed cycle is an important notation in directed graphs. At first, let's focus on the scheduling problem.

Say now you are supposed to arrange a set of jobs, under a set of constraints, by specifying when and how the jobs are to be performs. Now we only focus on one type of constraints: **precedence constraints**, which specify certain tasks must be performed before certain others.

Here we give an example. Considering a college student planning a course schedule, under the constraint that certain courses are prerequisite for certain other courses. In this case, each course is a graph; a edge from course `v` to course `w` refers to that `v` is a prerequisite of `w`. We also assume that student can only take one course at a time. Now, it arises a problem to be solved:

**Topological Sort**: given a graph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is impossible). In other words, we have to make a schedule for student to take all course in a proper order.

### Cycles in digraphs

To make sure such order is possible, firstly we have to determine whether there is a directed cycle in this directed. If so, then we cannot find such an order.

**Directed cycle detection**: does a given digraph have a directed cycle? If so, find the vertices on some such cycle, in order from some vertex back to itself. A directed acyclic graph (DAG) is a digraph with no directed cycles.
    
Now, recall how we find a cycle in undirected graphs. It is not hard: do the standard DFS and once we find a vertex which is going to be visited is visited already, then a cycle is detected. **But can you just use this method is directed graph?** 

Possibly not. It is more complicated in directed graph. Visiting a marked vertex does not necessarily mean a directed cycle is detected (it is easy to present an example). However, a similar methods is useful: we hole a `boolean` array to records the vertices that are currently on the call stack. If a vertex on that stack is visited again, then a directed cycle is present (not hard to reason). API for the directed cycle class:

    public class DirectedCycle
    --------------------------
                      DirectedCycle(Digraph G)
              boolean hasCycle()
    Iterable<Integer> cycle()
    
The API is self-explanatory.

```java
public class DirectedCycle {

    private boolean[] marked;
    private int[] edgeTo;
    private boolean[] onStack;
    private Stack<Integer> cycle;

    public DirectedCycle(Digraph G) {
        this.marked = new boolean[G.V()];
        this.edgeTo = new int[G.V()];
        this.onStack = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digraph G, int v) {
        marked[v] = true;
        onStack[v] = true;
        for(int w: G.adj(v)) {
            if (this.hasCycle()) return ;
            else if (!marked[w]) { 
                // if unmarked then not on stack for sure
                edgeTo[w] = v;
                dfs(G, w);
            } else if (onStack[w]) {
                // a cycle is detected then store it in a stack
                cycle = new Stack<>();
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.push(x);
                }
                cycle.push(w);
                cycle.push(v);
            }
        }
        onStack[v] = false; // restore stack status
    }

    public boolean hasCycle() {
        return this.cycle != null;
    }

    public Iterable<Integer> cycle() {
        return this.cycle;
    }
}
```

### Depth-first orders and topological sort

Now we deal with the precedence-constrained scheduling problem.

    public class Topological
    ------------------------
                      Topological(Digraph G)
              boolean isDAG()
    Iterable<Integer> order()
    
Please note that **a digraph has a topological order if and only if it is a DAG**. In fact, just add an additional line to the standard DFS algorithm, we may get a topological order. But to convince you, we still need to discuss something.

It is actually based on the fact that depth-first search visits each vertex exactly once.In the standard DFS, every time we call the function `dfs()` we will pass a vertex into the function.If we save the vertex in a data structure, three vertex ordering are of interest in typical applications:

- Preorder: put the vertex on a queue before the recursive calls
- Postorder: put the vertex in a queue after the recursive calls
- Reverse postorder: put the vertex on a stack after the recursive calls (the reverse order of the second one)

Now, we modify the DFS algorithms to conclude such three orderings. It in fact is the same DFS algorithm though we add some data structures to save the vertex in `dfs()`.

```java
public class DepthFirstOrder {

    private boolean[] marked;
    private Queue<Integer> pre;
    private Queue<Integer> post;
    private Stack<Integer> reversePost;

    public DepthFirstOrder(Digraph G) {
        pre = new Queue<>();
        post = new Queue<>();
        reversePost = new Stack<>();

        marked = new boolean[G.V()];

        for (int v = 0; v < G.V(); v ++) {
            if (!marked[v]) dfs(G, v);
        }
    }

    private void dfs(Digraph G, int v) {
        pre.enqueue(v);

        marked[v] = true;
        for (int w: G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }

        post.enqueue(v);
        reversePost.push(v);
    }

    public Iterable<Integer> pre () { return pre; }

    public  Iterable<Integer> post() { return post; }

    public Iterable<Integer> reversePost() { return reversePost; }
}
```

Now, here comes an important conclusion: **reverse postorder in DAG is a topological sort**. It is easy to explain: in `post` order, the parent of one vertex would always appears after the vertex. Then, the reverse postorder is a topological order. Please note the prerequisite is **this digraph must be a DAG**. If not, the reverse postorder still exists though it is not a topological order.

In summary, we put everything in a class.

```java
public class Topological {
    
    private Iterable<Integer> order;
    
    public Topological(Digraph G) {
        DirectedCycle cycles = new DirectedCycle(G);
        if (!cycles.hasCycle()) {
            // then a topological order must exist
            DepthFirstOrder dfs = new DepthFirstOrder(G);
            order = dfs.reversePost();
        }
    }
    
    public Iterable<Integer> order() {
        return order;
    }
    
    public boolean isDAG() {
        return order != null;
    }
}
```
Typically, a job-scheduling application is typically a three-step process:

- Specify the tasks and precedence constraints;
- Make sure that a feasible solution exists, by detecting and removing cycles in the underlying digraph until none exit;
- solve the scheduling problem, using topological sort.

## Strong connectivity in digraphs

We say two vertices are **strongly connected** if theya re mutually reachable. A digraph is  **strongly connected** if all its vertices are strongly connected to one another.

It is not hard to reason: two vertices are strongly connected if and only if there exists a general directed cycle that contains them both.

Based on this definition, strong connectivity partitions the vertices into equivalence classes. The equivalence classes are maximal subsets of vertices that are strongly connected to one another, with each vertex in exactly one subset. We refer to these subsets as strongly connected components.

A **strongly connected digraph** only has one strongly connected component: itself. A DAG have `V` strongly connected components, where `V` is the number of vertex.

Here is the API for strongly connected components:

    public class SCC
    ----------------
    
            SCC(Digraph G)
    boolean stronglyConnected(int v, int w) // are v and w strongly connected?
        int count()  // number of strong components
        int id(int v)  // component identifier for v
        
### Kosaraju's algorithm

This algorithm is an extreme example of a method that is easy to code but hard to understand. It only modifies several lines of standard DFS algorithms.

From the code below, we find that the only difference from DFS is the vertex order to call `dfs()`. Here it uses **the reverse postorder of its reverse graph**.

```java
public class KosarajuSCC {
    
    private boolean[] marked;
    private int[] id;
    private int count;
    
    public KosarajuSCC(Digraph G) {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        DepthFirstOrder order = new DepthFirstOrder(G.reverse());
        for (int s: order.reversePost()) {
            if (!marked[s]) {
                dfs(G, s);
                count ++;
            }
        }
    }
    
    private void dfs(Digraph G, int v) {
        marked[v] = true;
        id[v] = count;
        for (int w: G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }
    
    public boolean stronglyConnected(int v, int w) {
        return id[v] == id[w];
    }
    
    public int id(int v) {
        return id[v];
    }
    
    public int count() {
        return count;
    }
}
```

Now we want to understand the nature behind the algorithm. In fact, the algorithm indicates the correctness of one proposition:

**In a DFS of a digraph G where marked vertices are considered in reverse postorder given by a DFS of the digraph's reverse G^R (Korsaraju's algorithm), the vertices reached in each call of the recursive methods from the constructor are in a strong component.**

We have to prove the two equivalent conclusions:

- Evert vertex `v` that is strongly connected to `s` is reached by the call `dfs(G, s)`. 
- Every vertex reached by the call `dfs(G, s)` in the constructor is strongly connected to `s`.

For the first one, we may prove it by contradiction: suppose `v` is strongly connected to `s` and is not reached by `dfs(G, s)`. Since there is a path from `s` to `v`, `v` must have been marked during the call `dfs(G, v)` and the `dfs(G, s)` would not be called by the constructor, a contradiction.

Let `v` a vertex reached by `dfs(G, s)`, indicating that there is a path from `s` to `v`. Now we are supposed to prove that there is also a path from `v` to `s` in G, i.e., a path from `s` to `v` in G^R . In summary, the question is equivalent to :
    
In G^R , there is a path from `v` to `s`:

_ _ _ _S_ _<_ _-_ _-_ _-_ _V_ _ _ _ 
(this order is used for DFS in G and G^R )
    
pleas note that `s` is in front of `v` in that order; if not so, `v` will be marked first, and `dfs(G, s)` would not reach `v`.
    
Then we also need to find a path from `s` to `v` in G^R .
    
In reserve postorder, the `dfs()` call on latter vertices would be finished before those of former ones: `dfs(G^R, v)` must have been done before `dfs(G^R, s)` during the DFS of G^R (Note: `dfs` of G^R is done in class `DepthFirstOrder`). Then, it only leaves two cases to consider for `dfs(G^R, v)`:

    case one:                   case two
    .                           .
    .                           .
    dfs(v)                      dfs(s)
    .                           .    
    .                           .
    v done                          dfs(v)
    .                               .
    .                               .   
        dfs(s)                      v done
        .                       .
        .                       .
        s done                  s done
    .                           . 
    .                           .
    
The first case is impossible as in G^R there is a path from `v` to `s`, thus only the second case is possible, which indicates there is a path from `s` to `v` in G^R , completing the proof.

Up to now, we have proved the correctness of this algorithm.

## Transitive closure

The **transitive closure** of a digraph G is another digraph with the same set of vertices, but with an edge from `v` to `w` in the transitive closure if and only if `w` is reachable from `v` in G. 

It means that, if `v` is reachable from `w` but there is no direct edge from `w` tp `v`, then in the transitive closure an additional edge from `w` to `v` is added.

A transitive closure could be very dense even though the original digraph is sparse. For example, the transitive closure of a V-vertex directed cycle that contains V directed edges is a complete digraph with V^2 directed edges. We normally use a matrix of boolean values to present the all-pairs reachability. Note every vertex is self-reachable.

It is easy to use the directed DFS to implement such a matrix as mentioned above.

```java
public class TransitiveClosure {
    
    private DirectedDFS[] all;
    
    TransitiveClosure(Digraph G) {
        all = new DirectedDFS[G.V()];
        for (int v = 0; v < G.V(); v++) {
            all[v] = new DirectedDFS(G, v);
        }
    }
    
    boolean reachable(int v, int w) {
        // is w reachable from v?
        return all[v].marked(w);
    }
}
```
In fact, this is not so efficient in terms of space and time. Any better ideas? Guess not.