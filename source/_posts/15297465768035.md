## 218 Skyline Problem 烦死人的cornor case


```java
class Solution {
    public List<int[]> getSkyline(int[][] buildings) {
        List<int[]> res = new ArrayList<>();
        int n = buildings.length;
        int[][] left = new int[n][2]; // left edge
        int[][] right = new int[n][2]; // right edge

        for (int i = 0; i < n; i++) {
            left[i][0] = buildings[i][0];
            left[i][1] = buildings[i][2];
            right[i][0] = buildings[i][1];
            right[i][1] = buildings[i][2];
        }

        // up to now the left is already sorted but right is not

        // sort the right array
        Arrays.sort(right, (a, b) -> {
            if (a[0] != b[0]) return a[0] - b[0];
            else return a[1] - b[1];
        });
        
        int l = 0, r = 0, preHeight = 0;
        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] - a[0])); // 注意这样才能保证最大的在前面

        while (l < n || r < n) {
            if (l < n && left[l][0] <= right[r][0]) { // we encounter the left edge 注意 = 在这里非常重要！
                pq.add(new int[] {buildings[l][2], buildings[l][1]});   // pq: [height, the end point]
                int height = getMaxHeight(pq, left[l][0]);
                if (height != preHeight) {
                    preHeight = height;
                    if ( res.size() != 0 && left[l][0] == res.get(res.size() - 1)[0]) res.get(res.size()-1)[1] = height;
                    else res.add(new int[]{left[l][0], height});
                }
                l ++;
                
            } else {
                int height = getMaxHeight(pq, right[r][0]);
                if (height != preHeight) {
                    preHeight = height;
                    res.add(new int[]{right[r][0], height}); // 
                }
                r ++;
            }
        }

        return res;
    }

    private int getMaxHeight(Queue<int[]> pq, int point) {
        while (pq.size() != 0 && pq.peek()[1] <= point) pq.poll();  // we have to update the queue now
        if (pq.size() != 0) return pq.peek()[0]; // return the max height at present 
        else return 0;
    }
}
``` 

在用java做的时候有几个点一定要思考：

1. Collections的排序，comparator怎么用lambda写；
2. 优先队列中的comparator用lambda怎么写；
3. 怎么避免这种情况：`[0,2,3],[2,5,3]`。也就是下面这么代码中等号的作用；

    ```java
    if (l < n && left[l][0] <= right[r][0])
    ```

4. `[0,1,2], [0,1,3],[0,1,4]`这种情况下怎么处理多余点？为什么只在左边要处理右边确不用？
    

    ```java
    if ( res.size() != 0 && left[l][0] == res.get(res.size() - 1)[0]) {
        res.get(res.size()-1)[1] = height;
    }
    else res.add(new int[]{left[l][0], height});
    ```


