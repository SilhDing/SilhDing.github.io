## 416 494 337 518 dp Target Sum/Subset Sum


最近在做题的时候，发现了一个非常典型的子序列题，总结了一下。

-

### 总结与提纲

- 416 一个set分成两部分，两部分的和是相等的
    - dp的解法：二维dp和一维dp。其中二维dp规定了从set的哪那个范围取子集，一维则是在整个set的范围内取子集。
    - dfs的解法:相当于给了两个容器，把set的元素依次放到容易，做dfs；
- 494 一串数字前面加`+`或者`-`，使其结果为`target`
    - dfs的解法是可以的，但是时间很慢；自己写了一个dfa在submission里面；
    - dp的解法仍然是类似的，要先把这个问题转为成target sum问题
- 337 combination sum
    - 这个题仍可以用这个dp，但是里面的循环顺序、方向要改变；
    - 这个题目启发可以得到所有的情况，这个情况基本cover了“pick元素达到目的”的所有可能问题。
- 518 Coin Change
    - We could look at a 2D DP solution and modify it into a 1D.
-

### 416. Partition Equal Subset Sum

Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

首先是第一个解法。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // firstly, we get the sum of nums
        int sum = 0;
        for (int num: nums) sum += num;
        
        if ((sum % 2) != 0) return false;
        
        sum = sum / 2;
        int n = nums.length;
        boolean [][] dp = new boolean[n+1][sum+1];
        dp[0][0] = true;
        
        // obviously dp[i][0] = true and dp[0][j] = false.
        // since all numbers in nums are positive and j could only be positive too
        // in the case, j is the sum of numbers is a subset (not empty) 
        for (int i = 1; i < n + 1; i ++) dp[i][0] = true;
        for (int j = 1; j < sum + 1; j ++) dp[0][j] = false;
        
        for (int i = 1; i < n + 1; i ++) {
            for (int j = 1; j < sum + 1; j ++) {
                dp[i][j] = dp[i-1][j];
                if (j >=nums[i-1]) {
                    dp[i][j] = (dp[i][j] || dp[i-1][j-nums[i-1]]); 
                    //please note that the real index of nums here is actully i-1
                }
            }
        }
        
        return dp[n][sum];
        
    }
}
```
可以看到，这是一个简单的DP解法。有这么几点说明：

- 如果存在，subset中元素的和一定是`nums`中元素和的一半。这个很明显。
- `dp[i][j]`的含义：**表示nums的前`i`个数中（这些数的index为`0~i-1`），可以拿出若干个数使得和为`j`的话，则`dp[i][j]=true`**。
- 对于一个固定的`dp[i][j]`，可以这样考虑其和`dp[i-1][j]`的关系，假如我们不用`nums[i-1]`作为subset的一个元素的话，那么很明显：`dp[i][j]=dp[i-1][j]`；假如用`nums[i-1]`作为subset的一个元素的话，那么`dp[i][j]=dp[i-1][j-nums[i-1]`。综上，传递函数应该为：

 ```java
 dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]
 ```
 
 当然，前提是`j>=nums[i-1]`。
 
- 请注意初始化的方式。首先`dp[0][0]`是肯定为`true`的；再其次，所有的`dp[i][0]`应该是`true`,因为对于前`i`个元素，全都不选那么和就是`0`；其次`dp[0][j]`应都是`false`，因为`j`作为sum，不能为`0`。

第二种解法实际上和第一种很像，在空间上做了优化。

```java
class Solution {
    public boolean canPartition(int[] nums) {
        
        // to optimize the solution above
        // BTW these two solution actully are really general solutio to subset sum problem.
        // It is still possile to find a faster solution.
        int sum = 0;
        for (int num: nums) sum += num;
        
        if ((sum % 2) != 0) return false;
        
        sum = sum / 2;
        int n = nums.length;       
        boolean[] dp = new boolean[sum+1];
        dp[0] = true;
        
        for (int num: nums) {
            for (int i = sum; i >0; i--) {
                if (i >= num) {
                    dp[i] = (dp[i] || dp[i - num]);
                } 
            }
        }
        
        return dp[sum];
        
    }
}
```

注意这几点：

- `dp[i]`表示是否有子集的元素和为`i`。
- 我们来看`dp[sum]`这个元素，对于某个`nums`中的元素`num`， 实际上可以知道`dp[i]=dp[i-num]`。所以后面要对`nums`做一个循环。再加上对`dp`的每一个值都要完成遍历，所以要对`dp`本身要有一个遍历。

一个常见的问题来了。在说明之前，请记住，**`dp[i]=dp[i-num]`中，代表的是，`dp[i-num]`是不选择`num`时的状态，假如这个时候`dp[i-num]`已经是考虑了`num`后的情况，那么就会出错**，请看下面：

有一点需要注意，就是，为什么在对`i`循环的时候，需要从后面往前面，而不是前面往后面呢？不妨来看一个例子，现在假如输入是`[1,2,5]`，我们考虑最外层的循环的第一轮，也就是`num`等于`nums`中第一个元素`1`时，那么在对`i`的循环中，假如是从前面开始的，那么循环会是下面的情况：

```python
// consider the loop (int num: nums), now num = 1
dp[1] = dp[1] || dp[0] = true;
dp[2] = dp[2] || dp[1] = true;
dp[3] = dp[3] || dp[2] = true;
dp[4] = dp[4] || dp[3] = true;
```

这个时候，问题来了！在`num=1`这个循环结束后，我们得到的`dp[i]`实际上应该是表示**是否有{1}这个集合的子集能够使其和为`i`**，所以`dp`应该是：

    [true, true, false, false, false]

所以，为什么`dp[2], dp[3], dp[4]`的值错了？这是因为，考虑对`i`循环中`dp[2] = dp[2] || dp[1]`，看似符合传递函数，但是实际上`dp[1]`如果是`true`的话，`1`实际上已经被选取了，这个时候`dp[2]`再选`1`就是不对的，所以出现了错误。后面的错误则是同理的。

所以，从前面开始的主要错误在于，在一次`num`的循环中，这个数字被使用了多次，这当然是不行的。

那为什么从后面开始循环的时候，就对了呢？从后面开始，可以有效避免上面所提到的**“重复选取”**的情况，比如，`dp[4] = dp[4] || dp[3]`，**这个时候的`dp[3]`的状态还在上一轮**，`dp[3]`还没有选取本轮循环中的`num`，而且在之后的循环中，由于传递函数的方向，`dp[4]`选取了`num`也不会影响到其他的元素。所以，应该从后面开始循环才对。

这样一想的话，思路清晰很多了！比如，上面`num = 1`的循环结构后，现在`num = 2`的循环开始，那么，从后面开始，`dp[4] = dp[4] || dp[2]`，这个时候`dp[2]`表示的尚为**是否有{1}这个集合的子集能够使其和为`2`**，并没有选取现在的`num = 2`！然后，按照同样的道理，后面的循环仍没有影响。

值得注意的是，但对于这个题来说，可能还会有更优的解法，比如使用DFS。但是这个解法是很general的一个情况，也牵扯到了第二个LeetCode题。在聊第二个题目之前，先来看看DFS的解法。

```java
class Solution {
    public boolean canPartition(int[] nums) {
    
        //dfs solution
        // O(2^N) where n is the length of nums
        int n = nums.length;
        int sum = 0;
        
        for (int num: nums) sum += num;
        if (sum % 2 != 0) return false;
        
        sum /= 2;
        return helper(nums, n-1, new int[] {sum, sum});
    }
    
    public boolean helper(int[] nums, int i, int[] sub){
        if (i < 0) return sub[0] == 0 && sub[1] == 0;
        
        for (int j= 0; j < sub.length; j++) {
            if (sub[j] < nums[i]) continue;
            sub[j] -= nums[i];
            if (helper(nums, i-1, sub)) return true;
            sub[j] += nums[i];
        }
        
        return false;
                    
    }
}
```

前面的都是一样的。`helper`函数的作用是把`nums`中的数依次放到sub的两个元素中去（就相当于要把`nums`中的元素分类，使得每一个类中的元素值和都是`sum`），并且分类的方法是从`sum`中减去该元素的值。具体做法：首先判断`sum`和`nums`中元素的值大小，如果前者小于后者则跳过去；否则，调用函数本身，把index的值`i`减小（即执行下一个`nums`中的元素），做一个recursive call。假如本次循环无法拿到`true`值，则`sum`值要复原。同时，一个元素可以放到`sub`中的每一个类别中，所以这里对`sub`做了循环。

### 494. Target Sum

You are given a list of non-negative integers, `a1`, `a2`, ..., `an`, and a target, `S`. Now you have 2 symbols `+` and `-`. For each integer, you should choose one from `+` and `-` as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target `S`.

    Input: nums is [1, 1, 1, 1, 1], S is 3. 
    Output: 5
    Explanation: 
    
    -1+1+1+1+1 = 3
    +1-1+1+1+1 = 3
    +1+1-1+1+1 = 3
    +1+1+1-1+1 = 3
    +1+1+1+1-1 = 3
    
    There are 5 ways to assign symbols to make the sum of nums be target 3.
    
解法如下：

```java
class Solution {
    public int findTargetSumWays(int[] nums, int s) {
        int sum = 0;
        for (int n : nums)
            sum += n;
        return sum < s || (s + sum) % 2 > 0 ? 0 : subsetSum(nums, (s + sum)>>1); 
    }   

    public int subsetSum(int[] nums, int s) {
        int[] dp = new int[s + 1]; 
        dp[0] = 1;
        for (int n : nums)
            for (int i = s; i >= n; i--)
                dp[i] += dp[i - n]; 
        return dp[s];
    } 
}

```

首先请注意，这个问题可以很容易转换成一个subset sum的问题，所以本质是一样的。新构建的dp则存的不是布尔值，而是整数，表示**“能够让`nums`中若干数组成一个subset其和为`sum`的方法数”**。所以，传递函数应为：

```java
for (int num: nums):
    dp[sum] += dp[sum-num]
```

然后我们再对sum对一个循环，也就是

```java
for (int num:nums) {
    for (int i = sum; i>0; i--) {
        if (i >= n) {
            dp[i] += dp[i-n]
        }
    }
}
```

事实上还可以更简化一步，对`i`的遍历中，当`i<n`时，其实什么都没有做，所以我们可以减小循环的次数，也就是解法中的形式。

当然了，这个题还有一个DFS的解答，写起来很简洁，但是很慢。

接下来，再来看一个变形：Leetcode 377

### 377. Combination Sum IV

Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

    nums = [1, 2, 3]
    target = 4
    
    The possible combination ways are:
    (1, 1, 1, 1)
    (1, 1, 2)
    (1, 2, 1)
    (1, 3)
    (2, 1, 1)
    (2, 2)
    (3, 1)
    
    Note that different sequences are counted as different combinations.
    
    Therefore the output is 7.
    
这里的区别在于，现在，我们要求可以重用，并且序列区分。dp的解法如下：

```java

class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0] = 1;
        
        for (int i = 1; i < target+1; i ++) { 
        //注意,两个循环的位置不能换！！！
        //否则不满足题干“different sequences are counted as different combinations.”
            for (int num: nums ) {    
            // 和target sum不同，这里是从前面到后面，这样的话，数据就会重用，
                if (i >= num) {
                    dp[i] += dp[i- num];
                }
            }
        }
        return dp[target];
        
        
    }
}
```

可以看到的是，实际上，解法仍然是相似的，但是对dp的循环中，我们是从前面开始的！这就是因为，在这里题目中元素可以重用所导致的。前面不是分析了为什么要从后面开始吗？这里我们再一次验证了之前的想法。

另一方面，序列要区分，怎么做呢？方法是把对`dp`的循环放在对`nums`循环的前面。这是因为，假如`num`在前面，那么这个循环的意义，在于，对于每一个在`nums`中的`num`，我们用这个`num`对`dp`做一次更新，那么在这个过程中，你可以发现，其实并没有区分这个`num`在序列中具体位置的，因为，这个时候，整个的循环是这样的：

    num = 1     i = 1   dp[1] = dp[1] + dp[0] = 1   [1,1,0,0,0]
                i = 2   dp[2] = dp[2] + dp[1] = 1   [1,1,1,0,0]
                i = 3   dp[3] = dp[3] + dp[2] = 1   [1,1,1,1,0]
                i = 4   dp[4] = dp[4] + dp[3] = 1   [1,1,1,1,1]
                
    num = 2     i = 1   -
                i = 2   dp[2] = dp[2] + dp[0] = 2   [1,1,2,1,1]
                i = 3   dp[3] = dp[3] + dp[1] = 2   [1,1,2,2,1]
                i = 4   dp[4] = dp[4] + dp[2] = 3   [1,1,2,2,3]
    
    num = 3     i = 1   -
                i = 2   -
                i = 3   dp[3] = dp[3] + dp[0] = 3   [1,1,2,3,4]
                i = 4   dp[4] = dp[4] + dp[1] = 4   [1,1,2,3,4]
                
这样考虑，比如我们现在的位置是刚好`num = 2`这个循环已经完毕了，此时得到的`dp`的结果是`[1,1,2,2,3]`，也就是说，这个结果是只考虑`[1,2,]`这两个元素的情况，那么现在由于还有一个`num = 3`的元素，所以还要对`dp`做一次更新，但是`num = 3`是刚刚出现的，在之前的循环中，没有出现过，所以，这里并没有在意`3`是在什么位置，也就是对序列不区分。

现在假如这两个循环换了位置呢？那就变成下面的情况了

    i = 1   num = 1     dp[1] = dp[1] + dp[0] = 1   [1,1,0,0,0]
            num = 2     -
            num = 3     -
    
    i = 2   num = 1     dp[2] = dp[2] + dp[1] = 1   [1,1,1,0,0]
            num = 2     dp[2] = dp[2] + dp[0] = 2   [1,1,2,0,0]
            num = 3     -
            
    i = 3   num = 1     dp[3] = dp[3] + dp[2] = 2   [1,1,2,2,0]
            num = 2     dp[3] = dp[3] + dp[1] = 3   [1,1,2,3,0]
            num = 3     dp[3] = dp[3] + dp[0] = 4   [1,1,2,4,0]
            
    i = 4   num = 1     dp[4] = dp[4] + dp[3] = 4   [1,1,2,4,4]
            num = 2     dp[4] = dp[4] + dp[2] = 6   [1,1,2,4,6]
            num = 3     dp[4] = dp[4] + dp[1] = 7   [1,1,2,4,7]
            
在这种情况下，我们先是把所有的`num`都考虑之后，再进行下一个的`dp`值的计算。那么，在计算一个`dp`中的值时，`nums`中的所有元素都要被再考虑一次，这个时候，序列就会被区分了。比如，现在`i = 3`的循环结束后，`dp[3]`的值是4，里面包含序列`[1,2]`，`dp[2]`中则有一个是`[1,1]`；现在在`i = 4`的循环中，考虑`num = 1`后，`dp[4]`中将包含由`dp[3]`中的`[1,2]`演变而来的`[1,2,1]`，而考虑`num = 2`后，会包含由`dp[2]`中包含的`[1,1]`演变而来的`[1,1,2]`，这个时候发现，他们是不同的序列，但是内容是一样的。

总结一下这个这些个循环位置和方向导致的不同结果：

|   | `dp`循环从前面开始 | `dp`循环从后面开始 |
| --- | --- | --- |
| **`nums`的循环在前** | `nums`中的元素可以重用，并且**不**区分序列（即顺序不同视为一个结果） | `nums`中的元素**不**可以重用，并且**不**区分序列（即顺序不同视为一个结果）|
| **`dp`的循环在前** | `nums`中的元素可以重用，并且区分序列（即顺序不同视为一个不同的结果）； | `nums`中的元素**不**可以重用，并且区分序列（即顺序不同视为一个不同的结果） |

### 518 Coin Change 2

You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

**Example 1**

    Input: amount = 5, coins = [1, 2, 5]
    Output: 4
    Explanation: there are four ways to make up the amount:
    5=5
    5=2+2+1
    5=2+1+1+1
    5=1+1+1+1+1
    
We can solve this problem with what we have above. But instead of doing this directly, we can look at one dp solution first.

We use `dp[i][j]` to present how many ways that we can use changes from the first `i` coins to make amount `j`. Thus, we have two cases for `dp[i][j]`:

1. Do not the current coin: `dp[i][j] += dp[i-1][j]`;
2. use the current coin: how can we make sure that we have to use this coin **at least** once? At first, `j` should be `j - coin`, and `i` is still `i` so we can make sure that this coin can be used more than once. `dp[i][j] += dp[i][j-coin]`.

```java
// 一个用来学习组合问题的最好例子！！！
// using dfs is too long
// this a typical knapsnack problem, remember the problem of target sum?
public int change2(int amount, int[] coins) {
    // dp[i][j]: use the first i coins to make amount j
    // for a coin, we can choose or not
    // dp[i][j] += dp[i][j-coin] + dp[i-1][j]
    int[][] dp = new int[coins.length+1][amount+1];
    dp[0][0] = 1;  // all other dp[0][i] would be 0, no need to visit them
    for (int i = 1; i <= coins.length; i++) {
        dp[i][0] = 1;
        for (int j = 1; j <= amount; j++ ) {
            dp[i][j] = dp[i-1][j];
            if (j >= coins[i-1]) dp[i][j] += dp[i][j-coins[i-1]];
        }
    }
    return dp[coins.length][amount];
}
```

In fact, we find that a entry's value of `dp` only depends on the current row and last row, so we can optimize this solution further:

```java
public int change(int amount, int[] coins) {
    // same idea, but we simplify the space usage!
    // dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
    // this means we only need the current row and last row
    // then: dp[i] = dp[i] + dp[i-coin]
    // right dp[i] is the "last row" and left is the current row
    int[] dp = new int[amount+1];
    dp[0] = 1;
    for (int coin: coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i-coin];
        }
    }
    return dp[amount];
}
```

`dp[i] += dp[i-coin]` might be confusing. In fact, the `dp[i]` is exactly the last row and `dp[i-coin]` is the current row as we go through the `dp` from left to right.

**This is exactly what we have discussed previously!!!**

Say we now want to only use one coin once. Then, in the 2D solution, we now have:

`dp[i][j] = dp[i-1][j] + dp[i-1][j-coin]`

This is much easier to understand compared with the previous one.

We can also optimize it into a 1D solution. Now, we know that the current entry would reply on the last row. Thus, we could go through the `dp` from right to the left.

```java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = amount; i >= coin; i--) {
            dp[i] += dp[i-coin];
        }
    }
    return dp[amount];
}
```

This example would help us understand the 1D DP.
