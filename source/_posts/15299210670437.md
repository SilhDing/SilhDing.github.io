## DP 大全

在此写一个dp的相关题目总结。


-

### 目录

<font color=green>**Easy**</font> 
<font color=orange>**Medium**</font> 
<font color=red>**Hard**</font>

**本文档中的题**

Problem | Notes | 自
------------ | ------------- |-------
<a href="#279">**279**</a> <font color=orange>**Medium**</font> Perfect Squares| 难度不大，思路对了基本可以写出来，和target sum很像 | <font color=green>**Easy**</font> 结构简洁，应该算一个很典型的dp
<a href="#764"> **764**</a> <font color=red>**Hard**</font> Largest Plus Sign | 二维矩阵的题，寻找最大的十字形。这里是一个**dp顺序很分散的过程，**不知道怎么理解才是问题的关键 | <font color=red>**Hard**</font> 难度还是很大的，建议先看一维的情况，再考虑二维。实际上的dp是在一维做
<a href="#139">**139**</a> <font color=orange>**Medium**</font> Word Break | 和279是很相似的，算是一个不难但是典型的dp题目 | <font color=green>**Easy**</font> 不难，但是是典型的dp思维，iteration的方式也是很清晰和常见的
<a href="#552"> **552**</a> <font color=red>**Hard**</font> Student Attendance Record II | 很难。真的很难。dp规律居然这么有数学的规律实在是叹为观止。然后还有一个优化的方法，更加抽象了。。。（改进的算法看看就好） | <font color=red>**Hard**</font> 难度非常大，主要把基本的方法做熟练就好
<a href="#673">**673**</a> <font color=orange>**Medium**</font> Number of Longest Increasing Subsequence| 找出最长的子序列的个数，但是不算是难题，可以当成dp的练手题做做（解析省略）。 | <font color=orange>**Medium**</font> 典型的dp，也很好理解，要做到一看到就有思路
<a href="#375">**375**</a> <font color=orange>**Medium**</font> Guess Number Higher or Lower II | 这个题目的描述非常的confusing，所以要正确把握好题意，同时dp也是关键。| <font color=orange>**Medium**</font> 题目比较confusing可能不太适合作为dp的典型题
<a href="#474">**474**</a> <font color=orange>**Medium**</font> Ones and Zeroes| 非常典型的dp题，难度也比较适中，是很有可能出现的面试题型，要好好练练。| <font color=orange>**Medium**</font> 这里可以用dfs做一次（比较简单的那种），但是时间长；dp的解法也可以有优化，但是这里给的更好理解
<a href="#750">**750**</a> <font color=orange>**Medium**</font> Number of Corner Rectangles| 非典型的dp题目，但是很有意思，可以多做做。| <font color=orange>**Medium**</font> 不是常见的一种dp形式，只看代码还真的看不出来dp是干嘛的。。。
<a href="#312">**312**</a> <font color=red>**Hard**</font> Burst Balloons| 谷歌经典的扎气球问题，很难，但是这个思维很不错| <font color=Red>**Hard**</font> 就是一个难度很大的题目，需要逆向思维去考虑，同时循环的时候需要注意该怎么写。
<a href="#322">**322**</a> <font color=Orange>**Medium**</font> Coin Change| 一个典型、难度低的dp题目，和前面的有些题目很像。同时有dfs的解法，快很多。| <font color=green>**Easy**</font> 这个题目不难用dp做，关键要用dfs做出来。
<a href="#975">**975**</a> <font color=red>**Hard**</font> Odd Even Jump| 这个题目用暴力解法是可以写的，但是时间不短，相反用DP时间会小非常多，非常神奇，可以多看下| <font color=Red>**Hard**</font> 方法和简单，从后面开始推，一个pass完成dp的遍历，不过有些细节需要注意，不要出错。
<a href="#72">**72**</a> <font color=Red>**Hard**</font> Edit Distance | 有一点难度，这个题目的dp和dfs的解法是有相似思路的，但是dp的解法明显是更容易理解的。| <font color=Red>**Hard**</font> 多想想递推的公式是怎么来的，这是个关键。

**其他DP的专题总结**

题号 | 概括 | 自评
------------ | ------------- |-------
**416 494 337** | target sum 问题的专题总结 | target sum的问题本身不难，但是可以衍生的问题很多，代码中的循环顺序和方向对应不同的problem，所以最后的结论很重要
**123 188 309 714** | 买股票问题 | 难度很高。主要的技巧在于怎么设置dp以及其含义，另外状态图非常有助于理解
-

### <a id="279">279 Perfect Squares</a>

Given a positive integer `n`, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to `n`.

数学上有证明只有可能有1，2，3，4中情况。在此不看这个思路，没有意思。看一个dp的解法。

```java
class Solution {
    public int numSquares(int n) {
        // 典型的dp题
        int[] dp = new int[n+1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            int j = 1, min = Integer.MAX_VALUE;
            while (j*j <= i) {
                min = Math.min(min, dp[i-j*j]+1);
                j ++;
            }
            dp[i] = min;
        }
        return dp[n];
    }
}
```

可以看到只要抓住了`dp[i] = dp[i-j*j] + 1`这个点就可以了。不在赘述。

-

### <a id="764">764 Largest Plus Sign</a>

In a 2D grid from `(0, 0)` to `(N-1, N-1)`, every cell contains a `1`, except those cells in the given list mines which are `0`. What is the largest axis-aligned plus sign of `1`s contained in the grid? Return the order of the plus sign. If there is none, return `0`.

An "axis-aligned plus sign of `1`s of order `k`" has some center `grid[x][y] = 1` along with 4 arms of length `k-1` going up, down, left, and right, and made of `1`s. This is demonstrated in the diagrams below. Note that there could be `0`s or `1`s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`s.

    Order 3:
    0000000
    0001000
    0001000
    0111110
    0001000
    0001000
    0000000


先看一个解法。
```java
class Solution {
    public int orderOfLargestPlusSign(int N, int[][] mines) {
        
        // 这道题思路不难，我们可以用四个N×N的矩阵分别表示一个点的上、下、左、右分支的最大值，再用一个单独的矩阵存这四个值的min
        // 下面的解法实际上是一个简化版本，理解起来又有一定的难度：
        // 1. 先看成对每一行进行循环，这个循环会遍历第i行和第列的每一个元素；
        // 2. 第i行的每一个元素会在l和r中分别遍历一次，那么grid的值就是左右臂的最小值；
        // 3. 第i列的每一个元素会在u和d中分别便利一次，那么grid的值就是上下臂的最小值；
        // 4. grid[i][j]这个时候作为交叉点，显然会被遍历四次，这个时候的grid值将会是最终的值，这个grid也不会在其他的循环中被访问到
        // 5. 尽管其他的元素只被访问了两次，但是在其他的循环中会完成剩下的遍历！最终，一个每个元素会被访问4次，分别是上下左右四个方向
        // 完美！
        
        int[][] grid = new int[N][N];
        
        for (int i = 0; i < N; i++) {
            Arrays.fill(grid[i], N);  // N可以是更大的值，但是在这里N足够了，因为order一定是小于N的。
        }
        
        for (int[] zero: mines) {
            grid[zero[0]][zero[1]] = 0;  // 挖坑
        }
        
        for (int i = 0; i < N; i++) {
            for (int j = 0, k = N - 1, l = 0, r = 0, u = 0, d = 0; j < N; j ++, k -- ) {
                grid[i][j] = Math.min(grid[i][j], l = (grid[i][j] == 0?0: l+1));
                grid[i][k] = Math.min(grid[i][k], r = (grid[i][k] == 0?0: r+1));
                grid[j][i] = Math.min(grid[j][i], u = (grid[j][i] == 0?0: u+1));
                grid[k][i] = Math.min(grid[k][i], d = (grid[k][i] == 0?0: d+1));
            }
        }

        
        int res = 0;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j ++) {
                res = Math.max(res, grid[i][j]);
            } 
        }
        
        return res;
    }
}
```
这个题目的难度，主要是在理解dp是怎么完成的。其实思路是很容易想到的：如果我们知道某一个点的上下左右四个方向的长度，那么取他们的最小值，这个值就是该点所能形成的十字阶数。所以，按照这个思路，做dp就可以。

但是，这个dp的循环过程该怎么完成呢？这似乎是一个不太好解决的问题。因为，这里的dp每次所需要的数据不仅仅是简单的前一个或者后一个，而是上下左右都要，那么相当于在做dp的时候，其他的数据都还不是完整的，也就是说，每次单独的dp循环无法保证真正取到了四个方向的完整值。所以，这是本题目的一个难点。

为了理解上面解法的内涵，先简化一些这个题目：现在我们假设我们只有一个一维的数组，其中元素都是1和0，现在要求长度为奇数的子序列最大长度是多少？

比如：

`[1,1,1,1,1]` 对应的结果应该是`5`，`[1,0,1,1,1]`对应的结果是`3`。为了解决这个问题，其实也是一个dp，dp的值代表**以这个点为对称点的最长序列长度**。在某个固定的点，分别求得左边和右边的长度，取最小值，那么久可以这样：

```java
int N = a.length; // the length of the input array
int[] grid = new int[N];
Arrays.fill(grid, N) // N是随便设置的，足够大就可以

for (int j = 0, l = 0; j < N; j ++) {
    grid[j] = Math.min(grid[j], l = (grid[j] == 0?0: l+1));
}

for (int k = N -1, r = 0; k >= 0; k--) {
    grid[k] = Math.min(grid[k], r = (grid[k] == 0?0: r+1));
}
```

第一个for就相当于把每个点左边的长度给这个点：从最左边开始数连续的`1`序列，一旦是0，置0重新开始数就可以，这样每个点就得到了自己的“左臂”可以有的长度。第二个for相当于把每个点右边的长度按照类似的方法传入，并且我们只取最小值。实际上这两个操作可以归在一个循环里面。

这个时候`grid`就已经完全dp完毕了，里面的最大元素就是我们的结果。现在考虑二维数组里面，其实不难，因为一维的情况实际上已经是比较了左右臂了，那么再比较一个上下手臂就好了啊！！

```java
// 每一行每一行循环，拿到左右手的
for (int i = 0; i < N; i++) {
    for (int j = 0, k = N - 1, l = 0, r = 0; j < N; j ++, k -- ) {
        grid[i][j] = Math.min(grid[i][j], l = (grid[i][j] == 0?0: l+1));
        grid[i][k] = Math.min(grid[i][k], r = (grid[i][k] == 0?0: r+1));   
    }
}

// 每一列每一列循环，拿到上下手的
for (int i = 0; i < N; i++) {
    for (int j = 0, k = N - 1, u = 0, d = 0; j < N; j ++, k -- ) {
        grid[j][i] = Math.min(grid[j][i], u = (grid[j][i] == 0?0: u+1));
        grid[k][i] = Math.min(grid[k][i], d = (grid[k][i] == 0?0: d+1));
    }
}
```

当然这四个都可以放一起，就是解答里面的情况。

所以，这个题目的难度，主要在于怎么完成这个dp过程，把其拆成一维的会好做很多。

-

### <a id="139">139 Word Break</a>

Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

    Input: s = "applepenapple", wordDict = ["apple", "pen"]
    Output: true
    Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
                 Note that you are allowed to reuse a dictionary word.

这个题目dp是最好的。`dp[i]`的含义是：字符串的前`i`个字符组成的子字符串是否能用`dict`中的元素拼接完成。这样一来，解法就好说了：

```java
public class Solution {
    public boolean wordBreak(String s, List<String> dict) {
        int n = s.length();
        boolean[] dp = new boolean[n+1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && dict.contains(s.substring(j,i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```
可以看到，这个题目的思路和第一个题目是很相似的。都是从前面到后面依次完成这个`dp`的补充。最主要的判断语句是：

    if (dp[j] && dict.contains(s.substring(j,i)))
    
当`dp[i]`一旦为`true`了，就可以停止这个循环了。思路不难，但是是典型的一个动态规划题目。    

-

### <a id="552">552 Student Attendance Record II</a>

Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 10^9 + 7.

A student attendance record is a string that only contains the following three characters:

1. 'A' : Absent.
2. 'L' : Late.
3. 'P' : Present.

A record is regarded as rewardable if it doesn't contain **more than one 'A' (absent) or more than two continuous 'L' (late).**

    Input: n = 2
    Output: 8 
    Explanation:
    There are 8 records with length 2 will be regarded as rewardable:
    "PP" , "AP", "PA", "LP", "PL", "AL", "LA", "LL"
    Only "AA" won't be regarded as rewardable owing to more than one absent times. 
    
这个题目非常难，先看一个很容易理解的做法。

```java
class Solution {
    public int checkRecord(int n) {
        int[] A = new int[n+1], L = new int[n+1], P = new int[n+1];
        int m = 1000000007;;
        
        if (n == 1) return 3;
        if (n == 2) return 8;
        
        A[1] = 1;
        A[2] = 2;
        A[3] = 4;
        L[1] = 1;
        L[2] = 3;
        P[1] = 1;
    
        for (int i = 2; i <= n; i++) {
            P[i] = ((A[i-1] + P[i-1])%m + L[i-1])%m;
            if (i > 2) L[i] = (((A[i-1] + P[i-1])%m + A[i-2])%m + P[i-2])%m;
            if (i > 3) A[i] = ((A[i-1] + A[i-2])%m + A[i-3])%m;
        }
        return ((A[n] + P[n])%m + L[n])%m;
    }
}
```

分析:

参照卖股票问题的做法，我们可以把行为按照时间顺序作为一个序列，那么每个序列的最后面一定是"A"或者"P"或者"L"三种。假设`T[i]`为第`i`天结束的时候，符合要求的序列个数，那么按照序列结尾的不同，可以分为三类：

1. `A[i]`;
2. `P[i]`;
3. `L[i]`;

很明显上面三者的和就是`T[i]`。现在考虑第`i`天和第`i-1`的关系。

1. `P[i]`表示最后一天出席，那么明显，以前的状态可以不管，所以：

        P[i] = A[i-1] + P[i-1] + L[i-1]
        
        
2. `L[i]`表示最后一天是迟到的，那么假如前一天不是迟到的，那么今天迟到没关系；假如前一天是迟到的，那么前前一天一定是不能迟到的，明显：

        L[n] = A[i-1] + P[i-1] + A[i-2] + P[i-2]
        
3. `A[i]`表示最后一天缺席。这个时候，会比较麻烦。因为不能从末尾判断出以前是不是有过缺席。现在在设置两个序列：

    - `noAP[i]`表示以P结尾但是之前都不含有A的序列；
    - `noAL[i]`表示以L结尾但是之前都不含有A的序列；

    那么，实际上有：
    
        A[i] = noAP[i-1] + noAL[i-1]
    
    这是显然的。现在要考虑这两个新序列的递进关系。这也很明显:
    
        noAP[i] = noAP[i-1] + noAL[i-1]
        noAL[i] = noAP[i-1] + noAP[i-2]
        
    上面的三个式子，很明显可以得到:
    
        noAP[i] = A[i]
        noAL[i] = noAP[i-1] + noAP[i-2] = A[i-1] + A[i-2]
        
    所以，最终有：
    
        A[i] = A[i-1] + A[i-2] + A[i-3]
        
那么三组关系就出来了：
    
    P[i] = A[i-1] + P[i-1] + L[i-1]
    L[n] = A[i-1] + P[i-1] + A[i-2] + P[i-2]
    A[i] = A[i-1] + A[i-2] + A[i-3]

    
有了这个关系之后，写出代码就不难了。
    
与其说这是一个算法题，可以看到这里跟多的是数学。其实很难想到在计算`A[i]`的时候还需要用更细分的序列种类，所以往往即使想到这个点也会放弃。
    
以上的解法是线性时间的，但是这里还有一个解法，可以简化到对数时间。非常神奇，但是很难理解，所以只是理解一下这个做法就好了。

首先我们看另外一种dp的形式。
    
```java
public int checkRecord(int n) {
    final int MOD = 1000000007;
    int[][][] f = new int[n + 1][2][3];

    f[0] = new int[][]{{1, 1, 1}, {1, 1, 1}};
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < 2; j++)
            for (int k = 0; k < 3; k++) {
                int val = f[i - 1][j][2]; // ...P
                if (j > 0) val = (val + f[i - 1][j - 1][2]) % MOD; // ...A
                if (k > 0) val = (val + f[i - 1][j][k - 1]) % MOD; // ...L
                f[i][j][k] = val;
            }
    return f[n][1][2];
}
```

请注意f的含义。`f[i][j][k]`表示的是**序列长度为`i`、最多有`j`个A在序列中、最多有`k`个连续的L在末尾**。

那么对于`f[i][j][k]`来说：

- 如果最后一个是P，那么去掉P的长度为`i-1`的所有序列，都是可以的，但是这个所有序列是多少呢？答案是`f[i - 1][j][2]`。首先，之前的A还是有效力的，所以`j`要保留下来；其次，既然已经加了P在后面，那么就算前面一个是L，这个L的效力也没有了，但是为什么是指定为`2`呢？**因为“最多有2个”实际上包含了“最多有0个”以及“最多有1个”的情况**（我也不知道这么理解对不对，总觉得怪怪的）；
- 如果最后一个是A，那么`j`一定要大于`0`，并且可以由`f[i - 1][j - 1][2]`添加而来；
- 如果最后一个是L，那么`k`要大于`0`，并且可以由`f[i - 1][j][k-1]`添加而来；比如`k`为2时，只要考虑`k = 1`而不用考虑`k = 0`，因为，和上面一样，**因为“最多有1个”实际上包含了“最多有0个”的情况了。

这个解法虽然很优雅，但是理解起来也是有难度的，这也是多维dp的特点所在吧。现在考虑优化。

我们可以把`f[i][][]`和`f[i-1][][]`看成两个向量，那么递进关系可以写成：

    f[i][0][0]   | 0 0 1 0 0 0 |   f[i-1][0][0]
    f[i][0][1]   | 1 0 1 0 0 0 |   f[i-1][0][1]
    f[i][0][2] = | 0 1 1 0 0 0 | * f[i-1][0][2]
    f[i][1][0]   | 0 0 1 0 0 1 |   f[i-1][1][0]
    f[i][1][1]   | 0 0 1 1 0 1 |   f[i-1][1][1]
    f[i][1][2]   | 0 0 1 0 1 1 |   f[i-1][1][2]

假设A为其中的那个矩阵，那么递进下去，有：`f[n][][] = A^n * f[0][][]`，其中`f[0][][] = [1,1,1,1,1,1]`。所以现在计算`A^n`是关键。

在这里有一个exponentiating by squaring的算法，最后的时间可以是O(6^3 * log n) = O(log n)。

如果`f[n][][] = F(n)`，那么最后的结果是`F(n)[5]`，其实就是`A^n`的最后一列和`[1,1,1,1,1,1]`的乘积。有意思的是，这个值恰好也是`A^(n+1)[5][2]`的值。

代码：

```java
final int MOD = 1000000007;
final int M = 6;

int[][] mul(int[][] A, int[][] B) {
    // 计算两个矩阵的乘积
    int[][] C = new int[M][M];
    for (int i = 0; i < M; i++)
        for (int j = 0; j < M; j++)
            for (int k = 0; k < M; k++)
                C[i][j] = (int) ((C[i][j] + (long) A[i][k] * B[k][j]) % MOD);
    return C;
}


int[][] pow(int[][] A, int n) {
    // 计算A^n的值
    int[][] res = new int[M][M];
    for (int i = 0; i < M; i++)
        // 单位矩阵
        res[i][i] = 1; 
    while (n > 0) {
        if (n % 2 == 1)
            res = mul(res, A);
        A = mul(A, A);
        n /= 2;
    }
    return res;
}

public int checkRecord(int n) {
    int[][] A = {
            {0, 0, 1, 0, 0, 0},
            {1, 0, 1, 0, 0, 0},
            {0, 1, 1, 0, 0, 0},
            {0, 0, 1, 0, 0, 1},
            {0, 0, 1, 1, 0, 1},
            {0, 0, 1, 0, 1, 1},
    };
    return pow(A, n + 1)[5][2];
}
```

-

### <a id="673">673 Number of Longest Increasing Subsequence</a>

Given an unsorted array of integers, find the number of longest increasing subsequence.

**Example 1:**
    
    Input: [1,3,5,4,7]
    Output: 2
    Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].

**Example 2:**
    
    Input: [2,2,2,2,2]
    Output: 5
    Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

解法如下（code is self-explanatory）:
```java
class Solution {
	//一个很有典型但是又不算很难的dp题，值得好好研究
    // count和int是两个dp的序列，index为i时分别表示以nums[i]结尾的最长子序列个数和长度
    public int findNumberOfLIS(int[] nums) {
    	int n = nums.length;
        int[] len = new int[n], count = new int[n];
        int max_length = 0, max_count = 0;

        for (int i =0; i < n; i++) {
        	count[i] = len[i] = 1;
        	for (int j = 0; j < i; j ++) {
                if (nums[j] < nums[i]) {
                    if (len[j] + 1 > len[i]) {
                        len[i] = len[j] + 1;
                        count[i] = count[j];
                    }
                    else if (len[j] + 1 == len[i]) {
                        count[i] += count[j];
                    }
                }
        	}
            
            if (max_length == len[i]) max_count += count[i];
            else if (max_length < len[i]) {
                max_count = count[i];
                max_length = len[i];
            }
        }
        
        return (nums == null) ? 0: max_count;
    }
}

```
-

### <a id="375">375 Guess Number Higher or Lower II</a>

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number I picked is higher or lower.

However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.

Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.

这个题目这么理解：现在出题人要在1~`n`里面出一个数字来开始游戏，可以任意出，为了完成这个游戏，你需要一定的资金，那么什么资金才能保证不管出题人怎么出，你都可以保证完成游戏呢？

在解释dp解法之前，先来看几个cornor case：

1. 被选的数字只有一个，那么明显，花费为0；
2. 被选的数组有两个，worst case就是第一次没有选对，那么第一次应该选择较小的那一个；
3. 被选的数组有三个，聪明的策略是选择中间那一个，worst case就是选错了，那也只会损失中间的钱；（如果第一次选择第一个或者最后一个，worst case则是猜了两次都没对，损失的钱肯定会大的多。）

上面的结论是可以很容易证明的。在dp解法中，我们用`table[i][j]`表示在`[i, j]`中guess number需要的最小花费。假如`j - i > 2`，也就是非cornor case的情况下，有:

    table[i][j] = s + max(table[i][s-1], table[s+1][j])
    
假设`s`是现在玩游戏人的当前guess，那worst case肯定是还没才对，而且进入的subgame肯定有更大的penalty in worst case，这就是我们为什么要在这里用`max`.注意，因为要求是最小的花费，所以我们是认定游戏者有足够聪明可以让每一步都最优化，也就是每一步之后的worst case都是locally minimal.

```java
class Solution {
    public int getMoneyAmount(int n) {
        // 按照testcase来说，实际上这里问的是，赢这种比赛需要花的最少的钱。
        int[][] table = new int[n+1][n+1];
        return dp(table, 0, n);
    }
    
    private int dp(int[][] table, int i, int j) {
        // table[i][j] means the minimum cost when we guess a number between [i, j]
        
        // when we have to guess in only one number then the cost is 0
        if (i >= j) return 0;
        
        // [i][j] is computed already (like it is visited)
        if (table[i][j] != 0) return table[i][j]; 
        
        // when we have to guess in 2 or 3 numbers
        if (j - i <= 2) table[i][j] = i + 1;
        
        // when we have to guess in more than 3 numbers
        int res = Integer.MAX_VALUE;
        
        for (int s = i; s <= j; s++) {
            int tmp = s + Math.max(dp(table, i, s-1), dp(table, s+1, j));
            res = Math.min(res, tmp);
        }
        
        table[i][j] = res;        
        
        return res;
    }
}
```

### <a id="474">474 Ones or Zeroes</a>

In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.

For now, suppose you are a dominator of m `0s` and n `1s` respectively. On the other hand, there is an array with strings consisting of only `0s` and `1s`.

Now your task is to find the maximum number of strings that you can form with given m `0s` and n `1s`. Each 0 and 1 can be used at most once.

这个题目可以用dfs做，这里的dfs并不是循环递归调用，所以比较简单。

```java
class Solution {
    int res = 0;
    
    public int findMaxForm(String[] strs, int m, int n) {
        helper(strs, 0, m, n, 0);
        return res;
    }
    
    private void helper(String[] strs, int index, int m, int n, int num) {
        
        if (index >= strs.length) {
            res = Math.max(res, num);   
            return;
        }
        // not choose this one
        helper(strs, index+1, m, n, num);
        
        // choose this once
        int[] data = getData(strs[index]);
        if (m >= data[0] && n >= data[1]) helper(strs, index +1, m-data[0], n-data[1], num+1);
    }
    
    private int[] getData(String string) {
        int[] data = new int[2];
        for (int i = 0; i < string.length(); i++) {
            if (string.charAt(i) == '0') data[0] ++;
            else data[1] ++;
        }
        return data;
    }
}
```
问题的关键在于，**选不选这个数**，所以每次dfs中有两次的递归。这个不难理解和写出来。但是问题在于，这个时间太长了。

dp的解法实际上也是很好理解的。构造dp数组：`dp[i][[j][k]`，含义应该是一目了然的。The code is self-explanatory then just post the code here.

```java
class Solution {
    
    public int findMaxForm(String[] strs, int m, int n) {
        int[][][] dp = new int[strs.length][m + 1][n + 1];
        
        for (int i = 0; i < strs.length; i ++) {
            int[] data = getData(strs[i]);
            
            for (int j = 0; j < m + 1; j++) {
                for (int k = 0; k < n + 1; k++) {
                    if (i == 0) {
                        // the first one 
                        if (j >= data[0] && k >= data[1]) dp[i][j][k] = 1;
                    } else {
                        // not the first one
                        if (j >= data[0] && k >= data[1]) 
                            dp[i][j][k]  = Math.max(dp[i-1][j][k], dp[i-1][j-data[0]][k-data[1]]+1);
                        else 
                            dp[i][j][k] = dp[i-1][j][k];
                    }
                }
            }
        }
        return dp[strs.length - 1][m][n];
    }
    
    private int[] getData(String string) {
        int[] data = new int[2];
        for (int i = 0; i < string.length(); i++) {
            if (string.charAt(i) == '0') data[0] ++;
            else data[1] ++;
        }
        return data;
    }
}
```

我们还可以发现，在`dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-data[0]][k-data[1]] + 1)`中，实际上在i这一层中，我们只依赖了i-1的状态，也就是上一层的状态，那么完全可以不要给`i`一个单独的维度；另外，由于要使用的是上一层的状态，所谓我们的循环要从后面开始。

```java
public int findMaxForm(String[] strs, int m, int n) {
    int[][] dp = new int[m+1][n+1];
    for (String str: strs) {
        int[] data = getNumbers(str);
        for (int j = m; j >= data[0]; j--) {
            for (int k = n; k >= data[1]; k--) {
                dp[j][k] = Math.max(dp[j][k], dp[j-data[0]][k-data[1]] + 1);
            }
        }
    }
    return dp[m][n];
}
```

这个逻辑很像subset sum里面的优化方法。


### <a id="750">750 Number Of Corner Rectangles</a>

Given a grid where each entry is only 0 or 1, find the number of corner rectangles.

A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.

Example 1:
    
    Input: grid = 
    [[1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1],
     [0, 0, 0, 1, 0],
     [1, 0, 1, 0, 1]]
    Output: 1
    Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].
    
先看一个稍微好一点的暴力解法。思路是固定两行，找那些列在这两行中都是1，然后用这个个数算出来所有的可能情况。

```java
public int countCornerRectangles3(int[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    int res = 0;
    for (int i = 0; i < row; i++) {
        for (int j = i + 1; j < row; j++) {
            int tmp = 0;
            for(int k = 0; k < col; k++) {
                if (grid[i][k] == 1 && grid[j][k] == 1) tmp ++;
            }
            if (tmp > 1) res += tmp * (tmp -1) /2;
        }
    }
    return res;
}
```

dp的解法很神奇。思路是：按照常规的办法找到一个1，然后在其所在的行往后找，找到一个1，也就是现在有一个pair，现在看这个pair在的列位置在其他行有没有这样的pair。如果有的话，就可以凑成矩形；如果有n个，那就是n个矩形。这个n就由dp保存。所以`dp[i][j]`就表示`i`列和`j`列有多少对pair，即在相同的行位置上均为1。

```java
public int countCornerRectangles(int[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    int res = 0;
    int[][] dp = new int[col][col];
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            if(grid[i][j] == 1) {
                for (int k = j + 1; k < col; k++) {
                    if (grid[i][k] == 1) {
                        res += dp[j][k];
                        dp[j][k] ++;
                    }
                }
            }
        }
    }
    return res;
}
```

### <a id="312">312 Burst Balloons</a>

Given `n` balloons, indexed from `0` to `n-1`. Each balloon is painted with a number on it represented by array `nums`. You are asked to burst all the balloons. If the you burst balloon `i` you will get `nums[left] * nums[i] * nums[right]` coins. Here left and right are adjacent indices of `i`. After the burst, the left and right then becomes adjacent.

Find the maximum coins you can collect by bursting the balloons wisely.

Example：

    Input: [3,1,5,8]
    Output: 167 
    Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
                 coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
                 
这个题目的难度是很大的，主要是都不知道用dp该怎么做。先把dp的解法p上来。

```java
class Solution {
    public int maxCoins(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int n = nums.length;
        int[][] dp = new int[n][n];
        
        for (int len = 1; len <= n; len++){
            for (int start = 0; start <= n - len; start ++) {
                int end = start + len - 1;
                // now we have define start and end, and need to get dp[start][end]
                for (int i = start; i <= end; i++) {
                    // i is the last ballon to burst if only consider start - end range
                    int coin = get(nums, i) * get(nums, start -1) * get(nums, end +1);
                    
                    // if i != start, we have left subrange coin to get
                    if (i != start) coin += dp[start][i-1];
                    
                    // if i != end, we have right subrange coin to get
                    if (i != end) coin += dp[i+1][end];
                    dp[start][end] = Math.max(dp[start][end], coin);
                }
                
            }
        }
        
        return dp[0][n-1];
        
    }
    
    private int get(int[] num, int i) {
        // deal with the out-of-index issue
        if (i < 0 || i > num.length -1) return 1;
        else return num[i];
    }
}
```

这个题目的主要思想是，我们先考虑哪一个气球是最后burst的。这么考虑的好处是，一旦确定了最后一个，那么两遍的情况是肯定可以确定了的，两者互不干扰。也就是说，左边子序列的最大coin是唯一确定了，右边也一样。基于这个思想，来做dp。

现在`dp[i][j]`表示的是在`i`和`j`范围下，最大的coin。那么主要思路为以下:
1. 从最短的长度开始，也就是1，那么现在相当于只考虑只有一个气球的情况；当长度为2时，类似；这么做的好处是，当做到一个很大的长度的时候，因为需要用到比其长度小的dp值作为数据来计算，所以长度递增做就保证数据是对的；
2. 在一个确定的范围，也就是`start`和`end`确定的时候，我们从`start`开始循环，把每一个都当成是最后burst的气球，来求最大的coin，并更新。
3. 这么一看，思路就非常清晰了。

另一个实现方式：

```java
class Solution {
    public int maxCoins(int[] nums) {
        // you can use backtracing + dp
        int n = nums.length;
        int[][] dp = new int[n][n];
        return getNum(nums, 0, n - 1, dp);
    }
    
    private int getNum(int[] nums, int i, int j, int[][] dp) {
        if (i > j) return 0;
        if (dp[i][j] > 0) return dp[i][j];
        int res = Integer.MIN_VALUE;
        for (int k = i ; k <= j; k++) {
            // why get(nums, i-1) and get(nums, j+1)
            // we assue k is the last one if we merge i~j
            // then the next step must be multiplying i - 1 and j + 1
            // very tricky!!!!
            int tmp = getNum(nums, i, k - 1, dp) + getNum(nums, k + 1, j, dp) + get(nums, k) * get(nums, i-1) *  get(nums, j+1);
            res = Math.max(res, tmp);
        }
        dp[i][j] = res;
        return res;
    }
    
    private int get(int[] nums, int index) {
        if (index < 0 || index >= nums.length) return 1;
        return nums[index];
    }
}
```

### <a id="322">322 Coin Change</a>

You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.

The code is self-explanatory.

```java
class Solution {
    
    // this is the dp solution
    public int coinChange2(int[] coins, int amount) {
        // just use the DP solution for this question
        // dp[i] returns the solution of the question where amount is i
        // dp[0] = 0
        // dp[i] = Math.min(dp[i], coins[j] + dp[i - coins[j]]) if i >= coins[j]
        // if i < coins[i] then just ignore
        int[] dp = new int[amount+1];
        Arrays.fill(dp, amount + 1); // the max value is no more amount
        dp[0] = 0;
        for (int i = 1; i < dp.length; i++) {
            for (int j = 0; j < coins.length; j ++)  {
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        // System.out.println(Arrays.toString(dp));
        if (dp[amount] == amount + 1) return -1;
        else return dp[amount];
    }
}
```
### <a id="975">975 Odd Even Jump</a>

You are given an integer array `A`.  From some starting index, you can make a series of jumps.  The (1st, 3rd, 5th, ...) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.

You may from index `i` jump forward to index `j` (with `i < j`) in the following way:

- During odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index `j` such that `A[i] <= A[j]` and `A[j]` is the smallest possible value.  If there are multiple such indexes `j`, you can only jump to the smallest such index `j`.
- During even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index `j` such that `A[i] >= A[j]` and `A[j]` is the largest possible value.  If there are multiple such indexes `j`, you can only jump to the smallest such index `j`.

(It may be the case that for some index `i`, there are no legal jumps.)
A starting index is good if, starting from that index, you can reach the end of the array (index `A.length - 1`) by jumping some number of times (possibly 0 or more than once.)

Return the number of good starting indexes.

这个题目可以用暴力解法做，参考LC上的代码。但是这里要介绍的是一种很好的dp方法。

用`high[i]`表示从`i`处开始往上跳的时候，能不能达到最后一个；同样地，用`low[i]`表示用`i`处开始往下跳的时候，能不能达到最后一个。并且，从最后一个entry开始往前推，就可以轻易完成dp的遍历。请注意如何使用`TreeMap`来实现寻找`lo`和`hi`。

```java
public int oddEvenJumps(int[] A) {
    // this is really impressive! Refer to MD for more detail if you cannot understand
    int len = A.length;
    boolean[] high = new boolean[len], low = new boolean[len];
    TreeMap<Integer, Integer> map = new TreeMap<>();
    high[len-1] = true;
    low[len -1] = true;
    map.put(A[len-1], len - 1);
    int count = 1;
    for (int i = len - 2; i >= 0; i--) {
        Integer lo = map.floorKey(A[i]), hi = map.ceilingKey(A[i]);
        if (lo != null) low[i] = high[map.get(lo)];
        if (hi != null) high[i] = low[map.get(hi)];
        if (high[i] == true) count ++;
        map.put(A[i], i);
    }
    return count;
}
```

### <a id="72">72 Edit Distance</a>

Given two words `word1` and `word2`, find the minimum number of operations required to convert `word1` to `word2`.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

Example:

    Input: word1 = "horse", word2 = "ros"
    Output: 3
    Explanation: 
    horse -> rorse (replace 'h' with 'r')
    rorse -> rose (remove 'r')
    rose -> ros (remove 'e')
    
This problem in indeed hard when you look at it at the first glance, as you may have no idea how to start with it.

How about the brute force? Well, the basic idea is to list all possible series of modifications that make such a conversion. Thus, a DFS solution is also possible. Now, we only consider a DP solution.

At first, we use `dp[i][j]` to present the least number of modification from `word1.substring(0,i)` to `word2.substring(0,j)`. **This is similar to typical DP problems**.

Now, consider two possible cases:

- If `word1.charAt(i) == word2.charAt(j)`, then trivial: `dp[i][j] = dp[i-1][j-1]`;
- else, we may have three possible modifications:
    - replacing, then `dp[i][j] = dp[i-1][j-1] + 1`;
    - inserting, then `dp[i][j] = dp[i][j-1] + 1` (**think why**);
    - deleting, then `dp[i][j] = dp[i-1][j]`.

Also note the base case. We get a DP solution:

```java
class Solution{

    public int minDistance2(String word1, String word2) {
        // it is indeed a hard problem
        // use dp
        // dp[i][j] i chars of word1 and j chars of word2
        int row = word1.length();
        int col = word2.length();

        int[][] dp = new int[row+1][col+1];
        for (int i = 0; i <= row; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= col; j++) {
            dp[0][j] = j;
        }
        
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (word1.charAt(i) == word2.charAt(j)) dp[i+1][j+1] = dp[i][j];
                else {
                    // replacing, inserting and deleting
                    dp[i+1][j+1] = 1 + Math.min(dp[i][j], Math.min(dp[i+1][j], dp[i][j+1]));
                }
            }
        }
        
        return dp[row][col];
    }
    
}
```