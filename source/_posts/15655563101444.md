### Tricky substring problem 

#### 395 Longest Substring with At Least K Repeating Characters

Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.

It seems to be a hard problem. Think it in this way: 
- Is it possible that the result is the string itself? Yes, we can get the most infrequent char and if this char still appears more than k times, the we get it.
- If a char appears less than k times, we then know this char cannot appear in the final substring. Thus, we could split the original string by these infrequent char and use recursion to solve this problem.

```java
class Solution {
    public int longestSubstring(String s, int k) {
        // System.out.println(s);
        if (s == null || s.length() == 0) return 0;
        // recursion!
        // find the infrequent chars, and split the string by them
        int[] map = new int[256];
        for (char c: s.toCharArray()) map[c] ++;
        
        boolean flag = true;
        for (int num: map) {
            if (num > 0 && num < k) {
                flag = false;
                break;
            }
        }
        if (flag) return s.length();
        
        int res = -1;
        int start = 0;
        for (int i = 0 ; i < s.length(); i++) {
            if (map[s.charAt(i)]  < k ) {
                res = Math.max(res, longestSubstring(s.substring(start, i), k));
                start = i + 1;
            }
        }
        res = Math.max(res, longestSubstring(s.substring(start), k));
        return res;
    }
}
```

#### 992. Subarrays with K Different Integers

Given an array `A` of positive integers, call a (contiguous, not necessarily distinct) subarray of `A` good if the number of different integers in that subarray is exactly `K`.

(For example, `[1,2,3,1,2]` has 3 different integers: 1, 2, and 3.)

Return the number of good subarrays of `A`.

Example:

    Input: A = [1,2,1,3,4], K = 3
    Output: 3
    Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].

Note:
- `1 <= A.length <= 20000`
- `1 <= A[i] <= A.length`
- `1 <= K <= A.length`

It is always easy to solve substring problem with sliding window (or two pointers). However, you will find it somewhat stuck if you use a standard two pointers solution.

Here is one solution. Recall the problem of **substring with at most K distinct characters**. In fact, atMost(k) - atMost(k-1) is what we need in this problem.

```java
public int subarraysWithKDistinct2(int[] A, int K) {
    // it coould be tricky to solve this problem using sliding window
    // atMost(K) - atMost(K-1)
    // but this is not so efficient as this would iterate the array two times.
    
    return atMostK(A, K) - atMostK(A, K - 1);
}
    
private int atMostK(int[] A, int K) {
    if (K == 0) return 0;
    int i = 0, j = 0;
    int res = 0;
    Map<Integer, Integer> map = new HashMap<>();
    while (j < A.length) {
        int num = A[j];
        map.put(num, 1 + map.getOrDefault(num, 0));
        
        while (map.size() > K) {
            int startNum = A[i];
            if (map.get(startNum) == 1) map.remove(startNum);
            else map.put(startNum, map.get(startNum) - 1);
            i ++;
        }
        res += j - i + 1;
        j++;
    }
    return res;
}
```

Please consider why `res += j - i + 1`.

This solution is still inefficient, as we have to iterate the array twice. Here is another smart solution.

**Intuition**: 

If the subarray `[j, i]` contains `K` unique numbers, and first prefix numbers also appear in `[j + prefix, i]` subarray, we have total `1 + prefix` good subarrays. For example, there are 3 unique numers in `[1, 2, 1, 2, 3]`. First two numbers also appear in the remaining subarray `[1, 2, 3]`, so we have `1 + 2` good subarrays: `[1, 2, 1, 2, 3]`, `[2, 1, 2, 3]` and `[1, 2, 3]`.

```java
public int subarraysWithKDistinct(int[] A, int K) {
    // sliding wiindow + tail (prefix)
    int i = 0, j = 0, res = 0, count = 0;
    int prefix = 0;
    int[] map = new int[A.length+1]; // we use it as a map as A[i] <= A.length
    while (j < A.length) {
        if (map[A[j++]] ++ == 0) count ++;
        
        // deal with count > K
        // the head char only appears once in the range of i - j
        if (count > K) {
            map[A[i++]] --;
            count --;
            prefix = 0;
        }
        
        while (map[A[i]] > 1) {
            map[A[i++]] --;
            prefix ++;
        }
        
        if (count == K) res += 1 + prefix;
    }
    return res;
}

```

Also review these question:
- Longest Substring Without Repeating Characters
    - This one is easy: just record the last index of each char
- Longest Substring with At Most Two Distinct Characters
- Longest Substring with At Most K Distinct Characters
