# Union Find 好题

Here I want to share an good example that uses UF in a smart way.

#### 947 Most Stones Removed with Same Row or Column

On a 2D plane, we place stones at some integer coordinate points.  Each coordinate point may have at most one stone.

Now, a move consists of removing a stone that shares a column or row with another stone on the grid.

What is the largest possible number of moves we can make?

```java
class Solution {
    
    // it is not hard to come up with the dfs solution 
    // but it is not effecient
    // here is an UF solution
    // BUT!!! The way using UF is not so intuitive
    // a normal way may treat every stone as an element and connect it with other
    // but a better way should be considered: once we get a 'x' and a 'y', we connect these two
    // in this way, all stones in a connected components would be connected
    // how to distinguish x and y? we may use y+1000 to replace y
    public int removeStones(int[][] stones) {
        int[] parent = new int[20000];
        int count = 0;
        // initialization
        // if parent[i] = -1, we say i is a root and has no parent
        // the number of node whos parent[node] == -1 is also the number of connected components
        
        // initialize the parent array
        for (int[] stone: stones) {
            parent[stone[0]] = -1;
            parent[stone[1]+10000] = -1;
        }
        
        for (int[] stone: stones) {
            union(parent, stone[0], stone[1] + 10000);
        }
        
        for (int i = 0; i < parent.length; i++) {
            if (parent[i] == -1) count ++;
        }
        
        return stones.length - count;
    }
    
    private void union(int[] parent, int x, int y) {
        int xr = find(parent, x);
        int yr = find(parent, y);
        
        if (xr != yr) parent[xr] = yr;
    }
    
    private int find(int[] parent, int i) {
        
        while (parent[i] != -1) {
            i = parent[i];
        }
        
        // now parent[i] == -1
        // which means there is no parent and the node itself is a root
        return i;
    }
}
```