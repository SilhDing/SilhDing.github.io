# File-Caching Proxy Design Protocol 

by Yihang Ding (Andrew ID: yihangd)

## Proxy Specifications

The proxy is implemented by `Proxy.java` and `Cache.java`.

### Basic Caching Protocol

Once a client wants to read a file, it would search in cache to find any possible cached files, and request the newest file information from server (i.e, the **check-on-use policy**). If there is no cached file or the cached file is stale, the proxy would fetch the **whole file** from the server. Some old and useless cached files (i.e., no clients are accessing it) should be removed.

The cached file stored on proxy follows the format:
    
    FILEPATH_read_<VERSION>

Note that any `/` in `FILEPATH` is replaced by `%%`, and version is the timestamp of the file.

If a client with file descriptor `FD` wants to write in a file, the proxy would create a copy for it, named as:

    FILEPATH_write:<FD>_<VERSION>

Once finished, proxy would write back date to server, and one copy of the file would also be saved on proxy with a standard cache file name. Such protocol ensures concurrent clients of one proxy and open-close semantics for each of them (see below for more detail).

### Concurrency

To support safe operations by multiples client in one proxy, the proxy uses `synchronized` identifier and some explicit locker objects to mark some pieces of codes and protect the shared variables in order to avoid race conditions. An explicit locker object is also used by proxy to avoid errors caused by concurrent access to cache.

In addition, to avoid collision between simultaneous readers and writers to a single file, the proxy guarantees there is always **only one reader instance but may be more than one writer instance**. Specifically, as mentioned above, reader clients have to directly read the same cached file (one reader instance); a writer client may get a copy of the file which is exclusive to this itself (multiple writer instances). Thus, multiple writers may work in parallel without any interference among them, and readers would not be affected as the reader instance is not changed during every read session.

### Consistency Model in Proxy

As mentioned in the caching protocol, reader clients would share a read-only instance and each writer client has its own copy. Thus, every client would have **a fixed view** of the file it operates on. Any modification to the server files would not affect such clients' behavior once the sessions begin. In other words, **open-close** semantics is implemented by this protocol as the **consistency model**.

### Policies in Cache

The size of cache is fixed, thus a replacement policy is needed. Here, a **LRU replacement policy** is implemented with a `HashMap` and a `Queue`. The `HashMap` manages all cache files, including their names, sizes and number of sessions that are currently accessing this file. The `Queue` is responsible for managing the order of all files. It dynamically updates to make sure the least recently used file is at the head of the queue and the most recently used file is at the tail of the queue. If eviction is required, only the files that **are closest to the head of queue and are not occupied by any session** would be removed. Besides, some stale and useless cached files, if found, would also be removed.

Since the cache uses a whole-file cache policy, it is also possible that a file from server cannot fit in the cache; or a write operation to a file would fail as the new data is too large to fit in the cache. In those case, an error code `EBUSY` would be returned.


## Server Specification

The RMI server is implemented by `Server.java` which implements the interface `RemoteFile.java`. It accepts requests from proxies and conduct operations on local files.

### Basic Features

To support cache's functionality, the server provides several basic operations:
1. Return information of one file with class `FileStats` and return file data with class `FileData`;
2. Once a proxy writes back data to server, the serve could update its local file; deleting a file is supported as well;
3. Multiple proxies that tries to write or read are supported (more details later).

### Concurrency & Atomicity

To avoid collisions reduced by multiple proxies, every file on server would be accompanied with an explicit locker `ReentrantReadWriteLock` instance. It allows multiple reader to read one file at the same time, without any writers being present; or support only one writer at a time, without any readers being present. This method provides a basis for **concurrency** on server side.

With the file lockers, we are able to make sure the **atomicity** of some operations. For example, we may have to make sure fetching file information and fetching file data happens sequentially, without any modification to the file by other threads during that session.

What if there are multiple proxies trying to write a same fileï¼Ÿ The idea here is each proxy or session trying to write a file would have its own copy which is exclusive to itself, following the format:
    
    FILEPATH_write_<version>
    
The `version` is determined by the session which is writing the file. The server would not update the master copy until one session is closed. Under such a method, each writer would work independently and the writer session which is the last to close wins (i.e., it determines the version of the master copy). This also corresponds to **open-close** semantics mentioned above.

## Others
 
There are some other supporting classes in the implementation.

1. `FileStats` and `FileData`: These two classes are used to store file information and file date, respectively, and both implement the interface `Serializable`. They are mainly used to fetch file information and file data between server and proxy. Please note that we may need more than one instance of `FileData` to transfer a big file in chunks.
2. `ProxyHelper`: this class contains some static helper functions used by proxy to deal with strings and files, most of which are stateless.