## Don't want to use Dijkstra's Algiorithm?

### 787 Cheapest Flights Within K Stops

There are `n` cities connected by `m` flights. Each fight starts from city `u` and arrives at `v` with a price `w`.

Now given all the cities and flights, together with starting city `src` and the destination `dst`, your task is to find the cheapest price from `src` to `dst` with up to `k` stops. If there is no such route, output -1.

![-w805](media/15567659135504/15668387788406.jpg)

This is a typical problem on weighted digraph, so it is common to use Dijkstra's algorithm to solve the SP problem. However, Dijkstra's algorithm would find shortest path between the source node to any other node in the graph, which is not necessary in some cases.

The solution here only tries to fins the shortest path between the source and the given destination node. It puts all "routes" in the pq rather than every edge in classic Dijkstra's algorithm.

How to prove the correctness? If we can find a path which is shorter than the answer, then this route must not be present in the current pq when the answer is present. Thus, this route must be generated by one of the elements in the pq, and certainly the route should be longer.

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        int[][] graph = buildGraph(n, flights);
        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>(){
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        // element in pq: [total_len, route_end, left_stops]
        pq.offer(new int[]{0, src, K});
        while (pq.size() > 0) {
            int[] cur = pq.poll();
            int len = cur[0];
            int last = cur[1];
            int leftStops = cur[2];
            if (last == dst) return len;
            
            if (leftStops >= 0) {
                // should include 0: as the next one might be the dst
                for (int i = 0; i < n; i++) {
                    if (graph[last][i] == 0) continue;
                    pq.offer(new int[]{len+graph[last][i], i, leftStops - 1});
                }
            }
        }
        return -1;
    }
    
    private int[][] buildGraph(int n, int[][] flights) {
        int[][] graph = new int[n][n];
        for (int[] f: flights) {
            graph[f[0]][f[1]] = f[2];
        }
        return graph;
    }
}
```
