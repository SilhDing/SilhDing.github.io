# One interesting "recursion"

### Leetcode 678 Valid Parenthesis String

Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.
An empty string is also valid.

If there only exits `(` and `)`, then this problem is trivial. What if when `*` is also present?

At first, please take a look at the self-explanatory code:


```java
class Solution {
    public boolean checkValidString2(String s) {

        return check(s, 0, 0);
    }
    
    private boolean check(String s, int start, int count) {
        // count: the number of '(';
        for (int i = start; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(') count ++;
            else if (c == ')') {
                count --;
                if (count < 0) return false;
            } else {
                // c == '*'
                return check(s, i+1, count) || check(s, i+1, count-1) || check(s, i+1, count+1);
            }
        }
        return count == 0;
    }
}
```

Every time when meeting with `*`, we could have three possible branches. Thus, this solution is sort of like DFS + back-tracing. 

But a simpler way would use much less time. Now take `s = "(**())"` as one example:

1. Step 0: `count == 1`;
2. Step 1: we may have three possible branches: -1, 0, +1; then `count` could be `0`, `1`, `2`;
3. Step 2: each branch would split into 3 branches:
    - for `count = 0`, it would be `-1`, `0`, `1`;
    - for `count = 1`, it would be `0`, `1`, `2`;
    - for `count = 2`, it would be `1`, `2`, `3`;
    Thus, `count` could be `0`, `1`, `2` and `3`. The negative value should be dropped.
4. Step 3: `count = 1,2,3,4`;
5. Step 4: `count = 0,1,2,3`;
6. Step 5: `count = -1,0,1,2`;

You may then find `count` could be `0`, thus should return `true`. The process indicates some simplification of the DFS code:

1. You may merger some branches;
2. All possible values of `count` are consecutive, thus we may need to keep track of two branches: treat `*` as `(`, and treat `*` as `)`.

The result would be `true` only when `0` is between these two values. Any negative value of the first branch should be dropped.