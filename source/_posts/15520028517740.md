# `contentserver` design

**Name**: Yihang Ding
**Andrew ID**: yihangd

## Usage

### Compile the Project

Simply run `make` command in the root directory of this project to compile. It will generate `.class` files for this project.

```sh
$ make
```

If you want to clear all `.class` file, run

```sh
$ make clean
```

### Run the Program

To run this program, simply run

```shell
$ java contentserver -c [CONF_FILE]
```

in the root directory of the project. Please **always** specify the path of configuration file for the current node.

### Test Suite

The directory `conf_files` contains 4 configuration files for testing locally. Node 1, Node 2 and Node 3 are mutually connected by specifying the connectivity in the files; while Node 4 has no neighbors. Command "addneighbor" would add neighbors for node 4 and test the connectivity of the network; and use "kill" to kill some nodes to check how the network would change correspondingly.

## Design Protocols

Here in the project, a distributed content server is implemented mainly by class `contentserver.java` and other supporting classes.

### "keepAlive" Message

One node would periodically send "keepAlive" message to its neighbors. The node would start to send this message every 10s after the `contentserver` instance has been running for 3s.

The `keepAlive` message include the `uuid` of the current node, the metric between the sender and receiver, the backend UDP server port of the current node. Though some information are sometimes not useful, they are still required in order to handle some special cases, as you may see later.

A node that receives a "keepAlive" message would parse it and update some server states, e.g., last alive time of the node which sends the message, or add a new neighbor if the sender is not a neighbor of the receiver. **If one node has not received the "keepAlive" message from one node within the recent 30s, that neighbor would become unreachable**, which, though, may still be a part of the network.

### Link-state Advertisements

In addition to "keepAlive" message, each node would also send "advertisements“ to each neighbor, with a period of 10s. This would begin when the `contentserver` instance has been running for 4s.

To help construct the map of the network for each node within it, the advertisement should include: 
- Identity of the node which generates the advertisement;
- Sequence number of the advertisement (to avoid loop);
- Neighbor information of the node.

Once a node receives an advertisement, the node would discard it if its version is too old; otherwise, it would parse and store it locally, **and then forward it to all its neighbors**. Every node would gradually receive advertisements from every node and be able to construct the whole map of the network. Please note that since each node would not immediately send advertisements when they just start to run, **it may take several seconds to completely construct the whole map**.

Since one node is possible to fail and leave the network, one node should be considered absent in the network **if its new advertisement does not come in 30s**. The absent node would not appear in "map" and "rank", **which, however, may need several seconds to take effect**. This method is similar to the one used for "keepAlive" message.

### UPD Server/Client

Each node is either a UDP server or client to receive and send data, respectively. For sending, it would initialize a `DatagramSocket` instance and send message with a random port; for receiving, it would use a assigned port, which is specified in configuration file. Two threads are specially issued to handle sending and receiving.

### Priority Selection

Given a node A, in order to determine the shortest distance from A to another node, we may use **Dijkstra's algorithm** in graph to generate a **minimal spanning tree(MST)** rooted at node A. Specifically, the map of the network would further be abstracted as a **weighted digraph**, which then may generates a MST rooted at node A via Dijkstra's algorithm. The path from A to another node in the tree is always the shortest path between these two nodes. In this way, we may calculate the shortest distances between A and all other nodes, and determine the priority selection.

In this implementation, class `Graph` and `DirectedEdge` are used to construct the graph. Dijkstra's algorithm is implemented in some methods of the `Graph` class.

### Neighbors of Node

Two nodes may become each other's neighbor with the command `addneighbor`. Suppose such a situation: node A and node B are not connected currently, now node A is added as a neighbor of B. In this implementation, if A is added as a new neighbor of B, B would start to send "keepAlive" message to A. Once A receives that message, though B is not A's neighbor at this point, **it would also add B as one of its neighbors and also start send "keepAlive" message to B**. Thus, the bidirectional connection between A and B are successfully issued.

Due to network variation and instability, connection between two nodes is also possible to break. In this implementation, **once the connection from A to B is broken, connection from B to A will also eventually disappear**. Specifically, once node B stops sending "keepAlive" messages to node A, node A would take node B as unreachable after about 30s, thus the bidirectional connection is totally broken. If at some time one connection is recovered, the bidirectional could be recovered as well, following the procedures above.

### Server is "lazy"

If we add a new neighbor to a node by command `addneighbor`, it would immediately update server states and send advertisement to neighbors (only once). However, the server would not explicitly check if a node is not reachable anymore. **Only when the server starts to send "keepAlive" or advertisement messages, it would check if a node has become unreachable or absent in the network**. In other words, the server is "lazy" when checking the invalid nodes.

The advantage of this method is **simplicity of implementation**. The server does not need to explicitly deal with the state of each node on the network. Conversely, an **eager version** is also possible: we may create a timer for each node in the network and delete this node once it reaches the timeout limit, but this implementation may run too many threads at some time, which may impair the performance of the server.

### Active Metric

Instead of using static metric, active metric would be exploited if `active_metric=1` is specified in configuration files. In this implementation, we use the **round-trip time (RTT) to compute the metric**:

    new_metric = n * old_metric + (1 - n) * new_RTT * 10
    
where `n` is a value between `0` and `1`. If active metric is required, in addition to transmission of "keepAlive" and advertisement messages, each node would also periodically (in this implementation the period is 10s) send a short message to each of its neighbors and wait for response; the neighbor which receives that message would immediately send back a short message. Thus, the waiting time could be considered as RTT between two nodes.

A newly added node would temporally get a metric value `-1`, and it would later get updated when a new RTT value is obtained. **So please wait for some seconds to have metric values get updated when a new node is launched or added**. Note that when sending messages for measuring RTT, the node would not wait for response permanently: it would stop waiting once it takes too long to get it (in this implementation the timeout limit is 5s). If this happens, the node would be assigned a metric value `50000`, which is also the maximal value for this metric. In this case, this node is regarded as "temporally unreachable" (this is different from being "unreachable"; a node would be unreachable only when no "keepAlive“ messages come in 30s). Thus, if a node fails or connection  breaks, it is possible to see a metric value equal to or larger than `50000` after typing "map" or "rank". If connectivity cannot restore in 30s, it would be totally unreachable and become invisible in the output of "map" or "rank".

Please note the the new RTT does not fully determine the new metric value. We still partially take the old metric value into consideration when updating that metric with a coefficient `n`, considering some sudden variations in the network. The value of `n` would also be tweaked to adopt the network environment. In addition, we multiply the RTT by 10 to achieve higher precision when calculating.  

Why RTT is better to describe the metric between two nodes? It in fact takes many factors into consideration: **the network latency between nodes, server computation load, I/O usage or any other factors that may cause the latency of transmission**. In other words, it is a dynamic metric value that could promptly reflect the current state of the network and the node.


## Reference

The implementation exploits some sources as follows:

- Implementation of Graph and Dijkstra's algorithm: *Algorithms, 4th Edition* by Robert Sedgewick and Kevin Wayne;
- Java multi-thread programming: *Java: The Complete Reference, Tenth Edition* by Herbert Schildt and official documentation;
- Debugging and other issues: StackOverFlow and other forums.