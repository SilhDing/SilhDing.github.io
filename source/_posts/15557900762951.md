# Design Protocol of Group Photo Collage

by Yihang Ding (yihangd)

## Implementation Overview

The system, which implements two-phase commit protocol and logging recovery, is mainly implemented by the following classes:
- `Server` and `UserNode`: classes for main server and users, respectively;
- `Commit`: class for a single commit task. Server would **create one instance of this class for a single commit task**. This class implements all procedures for two-phase commit. Please note the commit task would be a new commit task or a old one restored from logging.
- `Log`: each node (server or user) would have an instance of this class. It helps server or users write log entries with different types.
- `SerialMessage`: a message template. **Instance of this class could be viewed as any type of message** between server and users, by setting the `type` field. In most cases, instances of this class would be serialized as a byte array and be the body of Message class.
- Other helper classes, including `ConvertHelper` and `MessageCallBack`. The first one provides methods on serialization and the latter on message callback handling. The callback hander simply **maintain multiple queues**, each of which corresponds to a single commit task.

## Protocol Between Server and User

The protocol is mostly implemented on the idea of two-phase commit protocol.

- A new commit task is proposed by someone. Server would at first send vote requests to all users in order to know if they are happy with the collage;
- Server collects all response from users. If all users are happy with the collage then a global decision `SUCCESS` is made. If anyone disagrees with it or server has waited so long that timeout has occurred, then global decision is `FAILURE`.
- Server then distributes the global decision to everyone and waits for ACK. If some ACKs are not received after timeout, then resend the global decision to unacknowledged users, until all ACKs are received.

**The timeout threshold is set as 3000 ms**, assuming a message that is not lost is guaranteed to arrive within 3 seconds of being sent.

A special rule here is we always make sure that one source file only appears at most one commit task. We use a **in-use picture set** to record files which are currently in commit tasks. If we find a picture from a commit task is  already in the set, then tell the server `DISAGREE` with the current commit task.

## Lost Messages

Messages could be lost anytime. Though it is hard to figure out which specific message is lost, we may just focus on possible consequences caused by lost messages. They are generalized as follows:

- After server sends the vote requests, **some responses are not received**. This might be due to loss of server's message or loss of user's response. In this case, we simply think the commit fails and the global decision is `FAILURE`;
- After server sends the global decision, **some ACKs are not received**. This might be due to the loss of server's decision or user's ACK. In this case, sever resends the decision to unacknowledged users until success.

## Recovery from Failure

To make the server and user able to recover from node failure, we would log some operations while running. Recovery for server and user slightly differ in log recoding and recovery policy.

### Server Log and Recovery

Three types of log entry are used by server:
1. `START [filename] [source_1] [source_2] ... [source_N]` logged when a new commit task starts;
2. `GLOBAL_COMMIT [filename] [global_decision]` logged when a global decision is made;
3. `END [filename]` logged when the tasks completely finishes.

For each commit task, it only has up to three log entries (one for each type). If the server fails, it would recover from the log file. For each commit task found in log file, if it:
1. Only has `START` log entry, then **we regard that the task fails**, and then server distributes the global decision;
2. has `START` and `GLOBAL_COMMIT` log entries, server just **distributes the global decision**, which is logged in log file, to all users;
3. has all three log entries, then **do thing**, as the commit task has correctly finished.

### User Log and Recovery 

There are also three types of log entry for user:
1. `START [filename] [source_file]` logged when a new commit task starts;
2. `GLOBAL_COMMIT [source_file] [global_decision]` logged when a global decision is received from server;
3. `END [source_file]` logged when a commit task completely finishes.

Please note that **each source file in a commit task would have its corresponding log entries** (unlike server log where one log entry always corresponds to a commit task rather than a source file). Thus, a commit task may have more than 3 log entries for one commit task. 

When recovering from log file, we have following rules:
 
1. If file only has `START` entry, **add the file into the in-use set**;
2. If file has `START` and `GLOBAL_COMMIT` entries, **try to remove it from in-use set and delete them locally** (if the global decision is recorded as `SUCCESS`);
3. If file has all three types of entry, **do nothing**, as the commit task has correctly finished.
