## DFS 大全

在此写一个dfs的相关题目总结。
 
-

### 目录

<font color=green>**Easy**</font> 
<font color=orange>**Medium**</font> 
<font color=red>**Hard**</font>

Problem | Notes | 自评
------------ | ------------- |-------
<a href="#753">**753**</a> <font color=red>**Hard**</font> Cracking the Safe (De Bruijn Sequence)| 这个题的难度主要在于理解题目的意思，但是就解法而言是一个非常典型的dfs | <font color=green>**Easy**</font> 结构简洁，应该算一个很典型的dfs
<a href="#301">**301**</a> <font color=red>**Hard**</font> Remove invalid parenthess | 也是一个典型的dfs，非常灵活，是一个难度很高的题目 | <font color=red>**Hard**</font> 难看懂，但是看懂了就知道像是一个backtracing的dfs，每次循环是看前面的内容，而不是后面（给出了一个易懂的代码结构）
<a href="#329">**329**</a> <font color=red>**Hard**</font> Longest Increasing Path in a Matrix| 很典型的dfs，也很灵活，这里要和dp一起做 | <font color=orange>**Medium**</font> 说实话不难想到思路，但是很容易陷入一个误区，这个题很好展示了怎么控制dfs的收敛，非常值得一试
<a href="#417">**417**</a> <font color=orange>**Medium**</font> Pacific Atlantic Water Flow| 和上面的**329**是非常类似的，但是可以发现这两个题解法的神坑！！！ | <font color=orange>**Medium**</font> 一定要做！实际上dp和dfs在这种矩阵的题里常用，但是怎么控制dfs是很重要的，这个题目单纯套用329的做法是有严重问题的，一定要仔细分析一下
<a href="#401">**401**</a> <font color=green>**Easy**</font> Binary Watch | 实际上是一个排列组合题。这个题可作为dfs的基础训练一定掌握！| <font color=orange>**Medium**</font> 一定要掌握！！（涉及到dfs的怎么会是easy呢？）
<a href="#679">**679**</a> <font color=red>**Hard**</font> 24 Game | 24点的题目。实际上很好懂，并没有那么难的 | <font color=orange>**Medium**</font> 这里实际上脱离了大部分dfs的模式，更像是一个递归的应用，也就是backtracing
<a href="#79">**79**</a> <font color=orange>**Medium**</font> Word Search | 典型题但是这个题目，主要是visited操作容易出问题！！多看看，和328对比 | <font color=orange>**Medium**</font> 主要研究visited应该怎么操作！题目本身不是很难的题
<a href="#133">**133**</a> <font color=orange>**Medium**</font> Clone Graph | 实际上就是一个graph的遍历问题，还是很简单的。其中又一些小trick可以再注意一下。 | <font color=green>**Easy**</font> 这里的结构和算法书中的非常相似了，是一个dfs或者bfs的典型。
<a href="#542">**542**</a> <font color=orange>**Medium**</font> 01 Matrix | 二元矩阵的dfs问题，实际上和上面的做法可能是很相似的，但是又不一样，第一次见到这样的解法。同时这个题目还有bfs的解法，也要学会。| <font color=orange>**Medium**</font> 非常tricky的题目！这里的每一次dfs保证的是当前的最优值，并不是最终值，而且每个cell可能会被dfs多次！
<a href="#37">**37**</a> <font color=red>**Hard**</font> Sudoku Solver |经典的数独游戏，但是不算太难，是一个backtracing的dfs| <font color=orange>**Medium**</font> 很典型的dfs问题，但是属于backtracing的范畴，和24点游戏非常相似！！
<a href="#681">**681**</a> <font color=orange>**Medium**</font> Sudoku Solver |看起来很可怕，但是其实上确实不难！典型的dfs的问题实际上！| <font color=orange>**Medium**</font> 不要被题目吓到，这个题目可以多做几次。元素由于可以复用，所以实际上会简单很多
<a href="#489">**489**</a> <font color=red>**Hard**</font> Robot Room Cleaner|还是一个很典型的二维数组的题目但是很有意思!思维也不太一样!| <font color=red>**Hard**</font> 很好玩的一个题目，但是理解好题目的意思是关键，可以多多思考backtracing在这里的作用（往回走是怎么实现的？）
<a href="#322">**322**</a> <font color=orange>**Medium**</font> Coin Change|一个中等难度的典型dfs题。并不难实现，关键在于剪枝。同时也有dp解法，虽然慢一些，但是很容易写出来。| <font color=orange>**Medium**</font> 这个题目一定要会做。有点类似于backtracing的想法，但是又不全是。实际上dfs的想法并不难实现，但是关键在于怎么用循环写出来。一定要会！
<a href="#72">**72**</a> <font color=red>**Hard**</font> Edit Distance|用DP会更加容易理解，但是用dfs则是岁思维挑战更大。不过这两个解法基本思路是相同的| <font color=red>**Hard**</font> 比较非常规思路，建议还是用DP来理解这个解法的思路，但是用dfs会快很多
-

### <a id="753">753 Cracking the Safe</a>

There is a box protected by a password. The password is `n` digits, where each letter can be one of the first `k` digits `0, 1, ..., k-1`.

You can keep inputting the password, the password will automatically be matched against the last `n` digits entered.

For example, assuming the password is `"345"`, I can open it when I type `"012345"`, but I enter a total of 6 digits.

Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.

    Input: n = 2, k = 2
    Output: "00110"
    Note: "01100", "10011", "11001" will be accepted too.

这个题目的难点，在于理解是什么意思。

1. 题目的意思是，现在有一个密码，`n`位，然后每一位可能是`0-k`之间的某一个，那么，显然，总共有`k**n`种密码。
2. 现在的问题是，我用一个序列来表示上面的密码，这个序列就是**De Bruijn Sequence**。这个序列等于把所有的可能密码都串联在了一起。比如上面的例子中，共有四种密码：`00，01，10，11`，那么按照overlapping的方法，穿起来，就是`00110`或者`11001`等等。
3. 事实上序列的个数是可以计算出来的，然后具体怎么操作也是有规律的，可以参考[一个视频](https://www.youtube.com/watch?v=iPLQgXUiU14)来了解更加深层次的东西。

现在，很显然我们要做什么了，先看解法：


```java
class Solution {
    public String crackSafe(int n, int k) {
        StringBuilder sb = new StringBuilder();
        int total = (int) Math.pow(k, n);
        Set<String> visited = new HashSet<String>();
        
        for (int i = 0; i < n; i ++) sb.append("0"); // the first one is set to be 000...00 (number of n)
        visited.add(sb.toString());
        
        dfs(sb, total, visited, n, k);
        return sb.toString();
    }
    
    public boolean dfs(StringBuilder sb, int total, Set<String> visited, int n, int k ) {
        if (total == visited.size()) return true;
        String pre = sb.substring(sb.length() - n + 1,sb.length());   // we use the last n - 1 digit in the sb
        for (int d = 0; d < k; d++) {
            String cur = pre + d;       // 新的密码
            if (!visited.contains(cur)) {
                visited.add(cur);
                sb.append(d);
                if (dfs(sb, total, visited, n, k)) return true; // this path is what we want
                else {
                    visited.remove(cur);
                    sb.delete(sb.length() - 1, sb.length());
                }
            }
        }
        return false;
    }
}
```

说明：

1. 只需要得到一个这样的序列，那么就设定从`000...00`（共`n`个`0`）开始。
2. 用visited来所有拿到过的密码，visited的大小和总个数一样的话就可以完成dfs了。
3. dfs中的经典结果：**循环+下一级dfs**。其中加判断条件。

-

### <a id="301">301 Remove invalid parenthess</a>

Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

**Example:**

    Input: "()())()"
    Output: ["()()()", "(())()"]
    
如果说上面一个题是典型的dfs且难度不大的话，这个题就非常有难度了。虽然答题看来，还是一个典型的dfs题目。

首先看解法（标准解法写的非常费解，这里是一个改良版的，非常容易懂）：

```java
class Solution {
    public static List<String> removeInvalidParentheses(String s) {
        List<String> res = new ArrayList<>();
        char[] check = new char[]{'(', ')'};
        dfs(s, res, check, 0, 0);
        return res;
    }

    public static void dfs(String s, List<String> res, char[] check, int last_i, int last_j) {
        int count = 0;
        int i = last_i;
        while (i < s.length() && count>= 0) {

            if (s.charAt(i) == check[0]) count ++;
            if (s.charAt(i) == check[1]) count --;
            i ++;
        }

        if (count >= 0)  {
            // no abnormal ')' is detected. We have to detect abnormal '(' now.
            String reversed = new StringBuffer(s).reverse().toString();
            if (check[0] == '(') dfs(reversed, res, new char[]{')', '('}, 0, 0);
            else res.add(reversed);

        }

        else {
            i -= 1; // 'i-1' is the index of abnormal ')' what makes count<0
            for (int j = last_j; j<= i; j++) {
                if (s.charAt(j) == check[1] && (j == last_j || s.charAt(j-1) != check[1])) {
                    dfs(s.substring(0, j) + s.substring(j+1, s.length()), res, check, i, j);
                }
            }
        }
    } 
```

为了更好地理解这个，我们拿一个例子`"())())"`来画一个树。每个方块和数字代表dfs函数开始执行时的状态。两个数字分别代表`i`和`j`的值。


![Picture5-w700](media/15293104900715/Picture5.png)

从上面可以看到，这个树就代表了整个的过程。这里，我们只处理了多余的`)`，而没有多余的`(`。实际上，由于对称性，我们可以先只看一边。

1. 现在假设只有多余的右括号。
2. 这一类题目的思想是显然的，就是利用stack的思想，来找出异常的右括号。
3. 按照dfs的思想，找到异常的右括号之后，去掉这个括号，此时`i`的位置为异常位置后一个，那么`i`之前的可以说是没有异常了，这个是显然的；那么接下来，假如又碰到多余的右括号，该怎么办呢？
4. 事实上，当`i`再一次碰到了多余的右括号时，这个时候，**`i`前面的右括号还是可以去掉的！**这就是这个题目的难点。因为就算去掉前面的右括号，整个表达式还可以是合法的。
5. 但是，现在的问题来了：既然前面的内容也可以改，那会不会有重复的情况出现呢？`last_j`就是为了这个作用。为了说明这个作用，现在给五个右括号编号，分别是1~5。现在我们考虑
    - 四条路径拿走的右括号分别是：1-2，1-4，2-3，2-4，可以看到没有重复。
    - **可以看到，每次往下递归时，拿走的右括号编号是依次增大的**，这个是由`last_j`保证的；
    - 假如现在对`j`的循环并不是从`last_j`开始而是从0开始的，那么第三条路径就变成了2，1，这样就出现重复了。
6. 总结来看，每次dfs的循环不是从当前位置往后看的，而是往前看的。可以在脑海里想一个动态图，其实也好理解很多了。

另外，这个题目还有一个很聪明的bfs解法，虽然时间上可能会差很多。

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> res = new ArrayList<>();
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();
        
        visited.add(s);
        queue.offer(s);
        int numDel = 0; 
        int length = s.length();
        
        while (!queue.isEmpty()) {
        	
        	if (queue.peek().length() < length - numDel) break;
            
            int size = queue.size();
            for (int k = 0; k < size; k++) {
            	String cur = queue.poll();

            	if (isValid(cur)) {
            		if(res.size() == 0) numDel = length - cur.length();
                    res.add(cur);
            	}

            	// 如果现在还没有任何的结果，那么numDel就是当前的层数
            	if (res.size() == 0) numDel ++;
                else continue;  // 如果已经存在结果了，那么numDel不需要更新并且queue不需要新的元素了

	            for (int i = 0; i < cur.length(); i++) {
	                if (cur.charAt(i) != '(' && cur.charAt(i) != ')') continue;
	                String s_new = cur.substring(0, i) + cur.substring(i+1);
	                if (!visited.contains(s_new)) {
	                    visited.add(s_new);
	                    queue.offer(s_new);
	                }
	            }
	        }
        }
        
        return res;
    }
    
    private boolean isValid(String s) {
        
        int i = 0;
        for (char c: s.toCharArray()) {
            if (c == '(') i ++;
            if (c == ')') i --;
            if (i < 0) return false;
        }
        
        return i == 0;
    }
}
```

其实bfs就好理解很多，就像是层序遍历一样，不过值得注意的是这里控制for支不执行的方法：当res还没有任何结果的时候，我们还不知道要删多少个`(`或者`)`才行，所以前面所有的出队列内容，我们都要继续删除，并且入队列。一旦有了结果，我们就知道此时所有的结果只会出现在本层，**因为每一层代表了一个删除个数，只有本层才有可能输出想要的所有结果**。所以本层循环结束后，可以结束程序输出最后的结果了，在这里我们通过比较当前层第一个元素（也就是队列的头）的长度和已有结果的长度。

-

### <a id="329">329 Longest Increasing Path in a Matrix</a>

接下来这个题目很有意思，虽然不难想到思路，但是容易有误区，而且标准的解答非常优美。

Given an integer matrix, find the length of the longest increasing path.

From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).

    Input: nums = 
    [
      [9,9,4],
      [6,6,8],
      [2,1,1]
    ] 
    Output: 4 
    Explanation: The longest increasing path is [1, 2, 6, 9].

思路：做一个同等大小的`dp[][]`，`dp[i][j]`表示从这个点出发能够得到的最长路径。而且`dp[i][j]`的值，等于周围四个数的最大值加上一（当然这里要用matrix做一个条件语句因为要求是单调性的path）。很简单是吧？看我自己的解法：

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        // dp[i][j]用来存这个开始的path的长度，当然最小是1
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
        int[][] dp = new int[matrix.length][matrix[0].length];
        int res = 1;
        
        for (int i = 0; i < matrix.length;i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                int length = dfs(matrix, dp, i, j);
                res = Math.max(res, length);
            }
        }
    }
    
    public int dfs(int[][] matrix, int[][] dp, int i, int j) {
        
        if(i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length) return -1;
        if(dp[i][j] != 0) return dp[i][j];
        
        dp[i][j] = 1;
        int res = 0
        int left = dfs(matrix, dp, i, j - 1) + 1;
        int right = dfs(matrix, dp, i, j + 1) + 1;
        int up = dfs(matrix, dp, i - 1, j) + 1;
        int down = dfs(matrix, dp, i + 1, j) + 1;
        
        if (left != 0 && matrix[i][j] > matrix[i][j-1]) res = Math.max(res, left) ;
        if (right != 0 && matrix[i][j] > matrix[i][j+1]) res = Math.max(res, right) ;
        if (up != 0 && matrix[i][j] > matrix[i-1][j]) res = Math.max(res, up) ;
        if (down != 0 && matrix[i][j] > matrix[i+1][j]) res = Math.max(res, down) ;

        dp[i][j] = res;
        return dp[i][j];
        
    }
}
```
其实看起来还是很简洁，但是dfs真的对吗？

1. 首先并没有加`dp[i][j] = 1`这个语句，一运行便栈溢出了。这是容易分析到原因的，比如，在dfs`dp[i][j]`时，我们要递归一个`dp[i][j+1]`的dfs，但是在dfs`dp[i][j+1]`时，又会递归`dp[i][j]`的dfs。这个时候，越来越膨胀，自然就死了，栈会很快溢出。
2. 然后想到因为dfs一开始有一个判断条件`if(dp[i][j] != 0) return dp[i][j]`，于是在每次的dfs中首先让`dp[i][j] = 1`。这样的话确实可以收敛了，但是又有了新的问题：假如对于一个`dp[i][j]`，如果旁边有一个的值已经是1了（但是实际上可能1并不是这个点的真实值，只是为了栈溢出的一个设置），那么就会直接跳过去了，显然，答案有可能是错的。

所以，现在，问题在于，怎么选择一个方法来控制收敛且答案正确？看下面这个解法：

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        // dp[i][j]用来存这个开始的path的长度，当然最小是1
        // 自己写了一个解法但是不能过测试，看笔记总结
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
        int[][] dp = new int[matrix.length][matrix[0].length];
        int res = 1;
        
        for (int i = 0; i < matrix.length;i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                int length = dfs(matrix, dp, i, j);
                res = Math.max(res, length);
            }
        }
        
        for (int[] a: dp) {
            System.out.println(Arrays.toString(a));
        }
        return res;
    }
    
    public int dfs(int[][] matrix, int[][] dp, int i, int j) {
        int[][] dirs = new int[][]{{0,-1},{0,1},{-1,0},{1,0}};
        if(dp[i][j] != 0) return dp[i][j];
        int res = 1;
        
        for (int[] dir: dirs) {
            int x = i + dir[0], y = j + dir[1];
            if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[i][j] <= matrix[x][y]) continue;
            int len = 1 + dfs(matrix, dp, x, y);
            res = Math.max(res, len);
        }
        
        dp[i][j] = res;
        return dp[i][j];
        
    }
}
```

现在可以看到的是，我们控制收敛的方法是`matrix[i][j] <= matrix[x][y]`。这样的话就非常合乎情理了，既然`matrix[i][j]`比旁边的点小或者相等了（我们默认为递增的），那么显然这个邻居点已经不用继续下去了。这样的dfs，才是真正深度了的。

-

### <a id="417">417 Pacific Atlantic Water Flow</a>

Given an `m` x `n` matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.

Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.

Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.

    Given the following 5x5 matrix:
    
      Pacific ~   ~   ~   ~   ~ 
           ~  1   2   2   3  (5) *
           ~  3   2   3  (4) (4) *
           ~  2   4  (5)  3   1  *
           ~ (6) (7)  1   4   5  *
           ~ (5)  1   1   2   4  *
              *   *   *   *   * Atlantic
    
    Return:
    
    [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).

一看到这个题目，哇，和上面这个increasing path的好像，马上用dfs和dp写起来：

```java
class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
        
        List<int[]> res = new ArrayList<>();
        if (matrix.length == 0 || matrix[0].length == 0 || matrix == null) return res;
        
        int row = matrix.length;
        int col = matrix[0].length;
        int[][] dp = new int[row][col];
        
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {              
                int cur = dfs(dp, matrix, i, j);
                if (dp[i][j] == 7) res.add(new int[]{i,j});
            }
        }
        
        return res;
        
    }
    
    public int dfs(int[][]dp, int[][] matrix, int i, int j) {
        if ((dp[i][j] & 4) != 0) return dp[i][j];  // 1XX & 100 = 4, 0XX & 100 = 0
        
        dp[i][j] |= 4;    // set the highest as 1, which means this site is visited
        int row = matrix.length, col = matrix[0].length;
        if (i == 0|| j == 0) dp[i][j] |= 2; // '010' means could flow into the pacific
        if (i == row - 1 || j == col - 1) dp[i][j] |= 1;  // '001' means could flow into the atlantic
        
        int[][] dirs = new int[][]{{0,-1},{0,1},{-1,0},{1,0}}; // left, right, up, down
        for (int[] dir: dirs) {
            int x = i + dir[0], y = j +dir[1];
            if (x <0 || x >= row || y < 0 || y >= col || matrix[x][y] > matrix[i][j] ) continue;
            int tmp = dfs(dp, matrix, x, y);
            dp[i][j] |= tmp;
        }
        return dp[i][j];
    }
}
```

每个dp里面的整数看成一个3位的二进制，第一位表示是否遍历，第二位表示可否流向左边的，第二位表示可否流向右边的。

确实是可以输出一些结果，但是在某些情况下，却遗漏了一些结果。现在分析。

首先，请注意，这里，**在高度相同的时候**，水也可以流过去。这样看起来好像没啥影响，只要在递归调用dfs函数的时候加一个条件就好，但是事实真的是这样吗？事实上，在上一个increasing path的例子中，我们规定了要是元素相同，是不可以的，所以再dfs调用时，只要当旁边的元素要大于其时，才能进行下一步的dfs，因此，**这个dfs是绝对不会再回来的**。但是在这里，还是保证了不会再回来吗？

举个例子：现在`matrix[x][y]`、`matrix[x][y+1]`高度相同，那么前者的dfs中，会调用到后者，并且这个时候，`dp[x][y]`可能还没有得到完整的结果；然后，调用dfs作用`matrix[x][y+1]`的时候，又会回来调用dfs作用`matrix[x][y]`，这个时候我已经设置`[x,y]`这个点已经遍历，所以`dp[x][y+1]`直接取`dp[x][y]`的值完成这一轮dfs，并设置`[x,y+1]`已遍历。但是前面说了，`dp[x][y]`还没有得到完整的结果，所以`dp[x][y+1]`的结果可能也并非是完整的。然后，在我们程序循环到了`matrix[x][y+1]`时，因为已经设置了已遍历，所以，直接读取，但是结果却不是完整的，因此就出现了错误。

通过上面的例子可以看到，这个时候，dfs出现了一个回溯的问题，即相互调用，本来相互调用也没问题，但是和这里控制已遍历的条件却发生了冲突，导致结果错误。由于dfs里面经常是环环紧扣的，所以错误可能是一连串的。

想了一连串的解决，比如在上下左右的循环中，先dfs完不相等的情况，再遍历完相等的，但是这个不适用于一个元素出现两个及以上相邻相等元素的情况，仅仅这样还是不能完全解决问题。其他的方法反而越想越复杂。

现在，我们改变一下思路：既然是要流进海洋的，那么不妨从边开始，找非递减的序列。还是用一个dp来存储一个两位的二进制数，第一个表示可以进P，第二个表示可以进A。那么，从四个边开始循环。


```java
class Solution {
    
    public List<int[]> pacificAtlantic(int[][] matrix) {
        List<int[]> res = new ArrayList<>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;
        
        int rows = matrix.length, cols = matrix[0].length;
        int[][] dp = new int[rows][cols];
        
        for (int r = 0; r < rows; r++) {
            dfs(matrix, dp, r, 0, 'P');
            dfs(matrix, dp, r, cols - 1, 'A');
        }
        
        for (int c = 0; c < cols; c++) {
            dfs(matrix, dp, 0, c, 'P');
            dfs(matrix, dp, rows - 1, c, 'A');
        }

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j ++) {
                if (dp[i][j] == 3) res.add(new int[]{i, j});
            }
        }
        
        return res;
    }
    
    public void dfs(int[][] matrix, int[][]dp, int i, int j, char ch) {
        int rows = matrix.length, cols = matrix[0].length;
        if (ch == 'P') dp[i][j] |= 2;
        else dp[i][j] |= 1;
        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int[] dir : dirs) {
            int x = i + dir[0],y = j + dir[1];
            
            if (x >= 0 && x < rows && y >= 0 && y < cols  && matrix[x][y] >= matrix[i][j]) {
            
                // to makr sure it is not visited
                int cur = ch == 'P'? dp[x][y] >>1: dp[x][y] & 1;
                if (cur != 0) continue;  // it is visited
                
                dfs(matrix, dp, x, y, ch);
            }
        }
    }
} 
```

请注意在递归dfs时，我们要检查这个点是不是已经visit了，那么只看对应位是不是为1。可以看到，这个方法非常好，而且很清晰，dfs控制的条件是先看高度符合要求，再看是否已经遍历，可以看成一个水流的流动（这里是从低到高流）。忘掉之前的错误解法吧。

上面的解法还可以简化一下，代码稍微会难懂一点。这个解法想相当于我们先把一个ocean的遍历完，然后再遍历另一个，要是碰到了一个已经能够flow上一个ocean的点，就输出。

```java
class Solution {
    public List<int[]> pacificAtlantic(int[][] matrix) {
        List<int[]> res = new LinkedList<>();
        if ( matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;
        
        int row = matrix.length, col = matrix[0].length;
        int[][] dp = new int[row][col];
        for (int i = 0; i < row; i++) dfs(matrix, dp, i, 0, 'P', res);
        for (int j = 0; j < col; j++) dfs(matrix, dp, 0, j, 'P', res);
        for (int i = 0; i < row; i++) dfs(matrix, dp, i, col-1, 'A', res);
        for (int j = 0; j < col; j++) dfs(matrix, dp, row-1, j, 'A', res);
        return res;
        
    }
    
    public void dfs(int[][] matrix, int[][] dp, int i, int j, char oce, List<int[]> res) {
        if (dp[i][j] == 'P' && oce == 'A') res.add(new int[]{i, j});
        dp[i][j] = oce;
        int row = matrix.length, col = matrix[0].length;
        int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};
        for (int[] dir: dirs) {
            int x = i + dir[0], y = j + dir[1];
            if (x < 0 || x >= row || y <0 || y >= col || dp[x][y] == oce || matrix[x][y] < matrix[i][j] ) continue;
            dfs(matrix, dp, x, y, oce, res);
        }
    }                                                                     
}
```

-

### <a id="401">401 Binary Watch</a>

A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).

Each LED represents a zero or one, with the least significant bit on the right.

Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.

    Input: n = 1
    Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
    
这个题目的主要核心在于一个排列组合问题。我们不考虑给出这个问题的具体解法，而是只考虑这么一个问题：给定一个`n`位的二进制数，其中的`k`位为`1`，其余的均为`0`，那么可能有多少种不同的数字？请输出。

这是一个非常典型的“pick or not”题，只是我们放在了一个二进制数的情境下描述了。在之前的target sum里面，也碰到了这种类型的，在那里用dp做的，因为那个问题里面我们求解的是“是否可以”，而不是“输出结果”。对于后者，用dfs很直观。而且这应该是dfs一个最简单的情景了，一定要学会怎么做。直接post解法：

```java
class Solution {
    public List<Integer> getNumber (int n, int k) {
        List<Integer> res = new ArrayList<>();
        int[] data = new int[n];
        data[0] = 1;
        for (int i = 1; i < n; i ++) data[i] = data[i-1] * 2;
        dfs(data, res, k, 0, 0);
        return res;
    }

    private void dfs(int[] data, List<Integer> res, int nums, int curr, int pos){
        if (nums == 0) {
            res.add(curr);
            return; // 这个return可以不加，但是既然nums已经是0了，自然不用继续了，否则会浪费时间
        }

        for (int i = pos; i < data.length; i ++){
            dfs(data, res, nums - 1, curr + data[i], i + 1);
        }
    }
}
```

dfs的结构其实并不难，请记住一下几个要点：

1. **循环+递归是dfs的典型结构；**
2. 循环中需要记录当前结果，比如这里的`curr`就是用来记录结果的；
3. 对于循环而言，每一个调用dfs的过程中循环的七点都是不一样的，一般不会贸然从常数开始。这里的`pos`就是用来控制循环的；
4. 参数中有判断递归结束的语句。比如这里的`nums`就是这个作用。也有用其他参数来达到这个目的的，视具体情况而定。

这是一个很基本的dfs，一定要掌握。在理解的时候，可以看成“把原来的问题分解成了很多小问题来解决”。

-

### <a id="679">679 24 Game</a> 

24点游戏。经典的算法题目。先看解法：

```java
class Solution {
    
    public boolean judgePoint24(int[] nums) {
        double[] data = new double[nums.length] ;
        for (int i = 0; i < nums.length; i++) data[i] = (double) nums[i];
        return helper(data);
    }
    
    private boolean helper(double[] nums) {
        
        if (nums.length == 1) return Math.abs(nums[0]- 24.0) < 0.0001;
        
        // create a new double[] whose length is 1 smaller than that of nums
        int n = nums.length;
        for (int i = 0; i < n-1; i++) {
            for (int j = i+1; j < n; j++) {
                
                // initialize double[] for dfs and set its part of entries
                double[] next = new double[n-1];
                for(int k = 0, index = 0; k < n; k++) {
                    if (k != i && k != j) next[index++] = nums[k];
                }
                
                double d1 = nums[i], d2 = nums[j];
                
                // get all possible operation results from nums[i] and nums[j] then dfs
                // the last entry in 'next' is next[n-2]
                double[] dirs = new double[]{d1 + d2, d1 - d2, d2 - d1, d2 * d1};
                for (double dir: dirs) {
                    next[n-2] = dir;
                    if (helper(next)) return true;
                }
                
                if (d1 > 0.0001) {
                    next[n-2] = d2 / d1;
                    if (helper(next)) return true;
                }
                
                if (d2 > 0.0001) {
                    next[n-2] = d1 / d2;
                    if (helper(next)) return true;
                }
            }
        }
        
        return false;
    }
}
```

实际上可以看到，这里的dfs更加容易理解。因为这里在递归调用dfs函数的时候，参数只有一个，也就是说递归后的独立性非常好，每次递归调用dfs函数的时候，相当于重新执行了这个函数，和上级函数没有太多的纠葛。

其实思路很简单，就是依次把操作数减少，看只剩一个数时，这个数为不为0。从思想上来说，这还是一个dfs的策略。注意，这里判断为0的方法，因为小数无法精确处理，所以要和0.0001之类的小数比而不是直接和0比。

-

### <a id="79">79 Word Search</a>

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
    
    board =
    [
      ['A','B','C','E'],
      ['S','F','C','S'],
      ['A','D','E','E']
    ]
    
    Given word = "ABCCED", return true.
    Given word = "SEE", return true.
    Given word = "ABCB", return false.

这是一个很典型的dfs，其实不难做出来，但是在做的时候发现了一个错误，然后很久没有发现。下面是原始的解法：

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int height  = board.length;
        int width = board[0].length;
        for(int i =0; i < height; i++) {
            for (int j=0; j < width; j++) {
                if (exist_helper(board, i, j, word, 0, new boolean[height][width])) return true;
            }
        }      
        return false;
    }
    
    public boolean exist_helper(char[][] board, int i, int j, String word,int index, boolean[][] visited) {
        if (index == word.length()) return true;
        if (i < 0 || j < 0 || j == board[0].length || i == board.length || visited[i][j]) return false;
        if (board[i][j] != word.charAt(index)) return false;
        visited[i][j] = true;   
        boolean exist = exist_helper(board, i+1, j, word, index+1, visited) || 
                        exist_helper(board, i, j-1, word, index+1, visited) ||
                        exist_helper(board, i, j+1, word, index+1, visited) ||
                        exist_helper(board, i-1, j, word, index+1, visited);
        return exist;
        
    }
}
```

思路很清晰：从每一个点开始dfs，用visited表示遍历。但是，某些test却通不过，这是怎么回事？原来是这样的：

首先请明确，在dfs的时候，可能上下左右多个路径都是会去尝试的，比如这个：

    [A, B, C, E]
    [S, F, E, S]
    [A, D, E, E]
    
    "ABCESEEEFS"
    
前面的`"ABE"`是只有一个方向，但是后面的第一个`E`就有两个方向了了，要是从下面走，那么走到`"ABCESEE`就没有了，**同时在这个过程中，所有的点都标注了visited的了**，从右边走的话，是可以的，但是右边的路线中，因为往下面走的dfs先执行，所以等右边路线的dfs开始执行时，某一些要经过的点已经被标记为visited了，所以就发生了错误。也就是说，前一个不成功的dfs实际上影响到了当前这个。

解决方法简单，在`return exist`前面加上：

    visited[i][j] = false;
    
即可。这就相当于四个方向的dfs不会相互影响。

这个时候就可以发现，实际上不需要单独的visited，对board直接改动就可以的：

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        int height  = board.length;
        int width = board[0].length;
        for(int i =0; i < height; i++) {
            for (int j=0; j < width; j++) {
                if (exist_helper(board, i, j, word, 0)) return true;
            }
        }      
        return false;
    }
    
    public boolean exist_helper(char[][] board, int i, int j, String word,int index) {
        
        if (index == word.length()) return true;
        if (i < 0 || j < 0 || j == board[0].length || i == board.length) return false;
        if (board[i][j] != word.charAt(index)) return false;
        // 也可以设置二维的visited数组表示visited但是没有必要，时间会更长
        board[i][j] = '#';  
        boolean exist = exist_helper(board, i+1, j, word, index+1) || 
                        exist_helper(board, i, j-1, word, index+1) ||
                        exist_helper(board, i, j+1, word, index+1) ||
                        exist_helper(board, i-1, j, word, index+1);
        board[i][j] = word.charAt(index);
        return exist;
        
    }
}
```

这样不需要多次开辟空间给visited，时间会快很多。

这个题目不是难题，但是自己却入了泥潭很久，这种题型就一定要理清思路。可以和328的increasing path对比一下，就可以明白我们这里的dfs目的是不同的。

328里面的dfs，本质是来做dp用的，一旦这个点不为0了，那么这个点就不再需要遍历了，实际上清晰很多。

-

### <a id="133">133 Clone Graph</a>

Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


**OJ's undirected graph serialization:**
Nodes are labeled uniquely.

We use `#` as a separator for each node, and `,` as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph `{0,1,2#1,2#2,2}`.

The graph has a total of three nodes, and therefore contains three parts as separated by `#`.

1. First node is labeled as `0`. Connect node 0 to both nodes `1` and `2`.
2. Second node is labeled as `1`. Connect node `1` to node `2`.
3. Third node is labeled as `2`. Connect node `2` to node `2` (itself), thus forming a self-cycle.

Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/

上面的解释不用理会（什么鬼？）。

实际上这就是一个遍历的过程，当然由于是clone，也要注意一下小的细节。Code here is self-explanatory.

```java
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if (node == null) return null;
        // 就是一个类似于遍历的问题
        HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
        UndirectedGraphNode res = new UndirectedGraphNode(node.label);
        map.put(node, res);
        dfs(res, node, map);
        return res;
        
    }
    
    private void dfs(UndirectedGraphNode node1, UndirectedGraphNode node2, HashMap<UndirectedGraphNode, UndirectedGraphNode> map) {
        // node1 is the new node and node2 is the old
        for (int i = 0; i < node2.neighbors.size(); i++) {
            UndirectedGraphNode node = node2.neighbors.get(i);
            if (map.containsKey(node)) {
                // if the node is established then we do not create a new one
                node1.neighbors.add(map.get(node));
            } else {
                UndirectedGraphNode new_node = new UndirectedGraphNode(node.label);
                map.put(node, new_node);
                node1.neighbors.add(new_node);
                dfs(new_node, node, map);
            }
        }
    }
}
```

### <a id="542">542 01 Matrix</a>

Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.

The distance between two adjacent cells is 1.

Example: 
Input:
    
    0 0 0
    0 1 0
    1 1 1
Output:

    0 0 0
    0 1 0
    1 2 1

在看这个题目之前，实际上最先想到的就是一个bfs解法。因为bfs是直接可以找到最短路径的。那么，首先，我们可以把这个矩阵转换成一个graph，这样有利于理解。首先我们把所有的`1`转换成很大的数，表示离`0`无限远。

这么描述这个图：**每一个cell都是一个v，每个cell的四周，假如`matrix[x][y]`的值满足`matrix[x][y] > matrix[i][j] +1`，那么我们就认为从`matrix[i][j]`到`matrix[x][y]`有一个edge。**也是说，在这里graph整个是动态的，因为matrix的entry本身会变。

为什么这么做？首先，假如有`matrix[x][y] > matrix[i][j] +1`的情况出现，那么很显然，就等于有一个更好的距离，那么`matrix[x][y]`就需要更新，也就是`matrix[x][y] = matrix[i][j] + 1`这个地方。相反，假如不满足上面的条件，那么对`matrix[i][j]`就不会有影响。

在算法书中的bfs，通常是用来简单的遍历，这样的整个graph是静态的；并且我们还有`marked[]`来表示v是不是已经访问。在这里，我们也要怎么相同的问题：怎么构造图？怎么表示已经访问（或者说不需要访问），这些都是按照题目的思路和逻辑来找对应的。这个题目是bfs应用的典范。

```java
class Solution1 {
    public int[][] updateMatrix(int[][] matrix) {
        int row = matrix.length, col = matrix[0].length;
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 0) queue.add(new int[]{i, j});
                else matrix[i][j] = Integer.MAX_VALUE;
            }
        }
        
        while (queue.size() > 0) {
            int[] cell = queue.poll();
            int i = cell[0], j = cell[1];
            int[][] dirs = new int[][]{{-1,0}, {1,0},{0,-1},{0,1}};
            for ( int[] dir: dirs) {
                int x = i + dir[0], y = j + dir[1];
                if (x < 0 || x >= row || y < 0 || y>= col ||
                   matrix[x][y] <= matrix[i][j]+1) continue;
                queue.add(new int[]{x, y});
                matrix[x][y] = matrix[i][j] + 1;
            }
        }
        return matrix;
    }
}
```

当然了，用bfs做完，肯定还有dfs，并且，dfs可能会更好。但是，应用dfs也在于这些问题：1. 怎么划分图? 2. 怎么表示`marked[]`（或者说是否需要往此方向递归dfs）？

在前面的几个二维矩阵的dfs题中，我们都能把marked控制很好，比如increasing string里面，从一个点A的dfs到邻近的B，B的dfs肯定不会回到，这是因为题目的直接要求，这里当然好理解。假如没有做好这一块，那么两者想回dfs就Overflow了。这里该怎么做？

实际上这里的dfs是有点tricky的。

1. 对于另一个点，取四周的最小值+1，作为临时的结果。**请注意，这并不是一个最终的结果！**
2. 当发现某个点更新了之后，需要明白的是，**某个点的更新对周围的点也会直接影响**，所以我们dfs四周。
3. 假如没有更新，那么不用调用任何的dfs，这等于就是一个收敛。比如，A点的值更新，dfs到了邻居B，但是B其实并不用更新，那么也就不用dfs了，因为B的邻居（除A以外）并不会受到A直接的影响。

通过上面的两个解法，对于二维的矩阵dfs，需要明确的是这么几个问题：

- 怎么把这个矩阵和图对应起来？
- 完成上一步之后，怎么实现标准遍历中的`marked[]`？或者说，怎么控制dfs的流向不会回来？或者说，怎么控制哪些点是不用再dfs的？

按照这个思路，所有的二维dfs都不会难。

```java
public class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        int row = matrix.length, col = matrix[0].length;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                dfs(matrix, i, j);
            }
        }
        return matrix;
    }
    
    private void dfs(int[][] matrix, int i ,int j) {
        if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length || matrix[i][j] == 0) return ;
        int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};
        int min = Integer.MAX_VALUE;
        for (int[] dir: dirs) {
            int x = i + dir[0], y = j + dir[1];
            if (x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length) {
                min = Math.min(min, matrix[x][y]);
            }
        }
        int old = matrix[i][j];
        matrix[i][j] = min + 1;
        
        if (old != matrix[i][j]) {
            dfs(matrix, i, j-1);
            dfs(matrix, i, j+1);
            dfs(matrix, i-1, j);
            dfs(matrix, i+1, j);
        }
    }
}
```

### <a id="37">37 Sudoku Solver</a>

Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits `1-9` must occur exactly once in each row.
Each of the digits `1-9` must occur exactly once in each column.
Each of the the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.
Empty cells are indicated by the character `'.'`.

这个数独的题目，实际上并不难，code is self-explanatory here.

```java
class Solution {
    public void solveSudoku(char[][] board) {
        if (board == null || board.length == 0) return ;
        helper(board);
    }
    
    private boolean helper(char[][] board) {
        int row = board.length;
        int col = board[0].length;
        
        for (int i = 0; i < row; i ++) {
            for (int j = 0; j < col; j++) {
                if (board[i][j] == '.') {
                    for (char c = '1'; c <= '9'; c++) {
                        if (isValid(board, i, j, c)) {
                            board[i][j] = c;
                            if (helper(board)) return true;
                            else board[i][j] = '.';
                        }
                    }
                    // 1-9 全部试完了还不行，就false了
                    return false;
                }
            }
        }
        return true;
    }
    
    private boolean isValid(char[][] board, int i, int j, char c) {
        // if we fill board[i][j] = num, is valid?
        // we have to check every row, every col and the block
        
        for (int a = 0; a < 9; a++) {
            if (board[i][a] == c) return false;
            if (board[a][j] == c) return false;
        }
        
        int x = (i / 3) * 3, y = (j / 3) * 3;
        for (int m = 0; m < 3; m++) {
            for (int n = 0; n < 3; n++) {
                if (board[x+m][y+n] == c) return false;
            }
        }
        
        return true;
    }
}
```


### <a id="681">681 Next Closest Time</a>

Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.

You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.

    Input: "19:34"
    Output: "19:39"
    Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.
     
    Input: "23:59"
    Output: "22:22"
    Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.

这个题目，看起来很复杂，但是实际上并不难。这么解析:

要找到和当前时间最短的这个点，那么直接把所有的情况列出来比较就好。那么问题就等于要找到所有的这样的组合情况，那么久成了一个典型的bfs问题了。另一方面，这里面的元素是可以复用的，所以，实际上bfs的循环并不复杂。

```java
class Solution {
    
    // 非常有意思的一个题目
    // 思路其实简单：全部打出来呗 dfs
    String res = "";
    int diff = Integer.MAX_VALUE;
    
    public String nextClosestTime(String time) {
        
        Set<Integer> set = new HashSet<>();
        set.add(Integer.parseInt(time.substring(0,1)));
        set.add(Integer.parseInt(time.substring(1,2)));
        set.add(Integer.parseInt(time.substring(3,4)));
        set.add(Integer.parseInt(time.substring(4,5)));
        
        if (set.size() == 1) return time;
        
        List<Integer> list = new ArrayList<>(set);
        int target = Integer.parseInt(time.substring(0,2)) * 60 + Integer.parseInt(time.substring(3,5));
        
        dfs(list, 0, "", target);
        
        return res.substring(0,2) + ":" + res.substring(2,4);
    }
    
    private void dfs(List<Integer> list, int posi, String cur, int target) {
        // posi当前要添加的是那个位置的
        // cur已经构造好的string
        if (posi == 4) {
            // now the string is created alreay we have to update the result
            
            int min_cur = Integer.parseInt(cur.substring(0,2)) * 60 + Integer.parseInt(cur.substring(2));
            
            // if they are the same, we skip this result
            if (min_cur == target) return ;
            
            if (min_cur < target) min_cur += 1440;
            int d = min_cur - target;
            if(d < diff) {
                diff = d;
                res = cur;
            }
            return ;
        }
        
        for (int i = 0; i < list.size(); i++) {
            if (posi == 0) {
                if (list.get(i) > 2) continue;   
            }
            else if (posi == 1) {
                if (Integer.parseInt(cur)*10 + list.get(i) > 23) continue;
            }
            else if (posi == 2) {
                if (list.get(i) > 5) continue;
            }
            // else if (posi == 3) 
            
            dfs(list, posi +1, cur+list.get(i), target);
        }
    }
}
```

### <a id="489">489 Robot Room Cleaner</a>

Given a robot cleaner in a room modeled as a grid.

Each cell in the grid can be empty or blocked.

The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.

When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.

Design an algorithm to clean the entire room using only the 4 given APIs shown below.

    interface Robot {
      // returns true if next cell is open and robot moves into the cell.
      // returns false if next cell is obstacle and robot stays on the current cell.
      boolean move();
    
      // Robot will stay on the same cell after calling turnLeft/turnRight.
      // Each turn will be 90 degrees.
      void turnLeft();
      void turnRight();
    
      // Clean the current cell.
      void clean();
    }
    
这个题目非常有意思。实际上二维的矩阵bfs问题并不是一个很难的问题，因为做bfs的时候比较直观，容易有清晰的思路。但是这里明显有难度。一般来说，我们在这道题的bfs思路就是，在一个点clean完毕后，就可以上下左右再去开始新一轮的bfs了，但是现在有这几个问题：
1. 这里只给了了一个robot的API，我们无法知道初始状态，同时也无法通过两个loop做这样的循环，所以前面所有的二维的问题，可能都无法套模板。这里只能通过robot的方法来控制，非常灵活。
2. 没有坐标，怎么实现visited的问题？其实不难解决，我们只要记录相对位置就好了。
3. 现在一个可能的情况是，要是左边dfs完毕后，需要回到原点，这个怎么做？做完dfs后robot的方向怎么弄？这也是要考虑的问题。

先上code

```java
/**
 * // This is the robot's control interface.
 * // You should not implement it, or speculate about its implementation
 * interface Robot {
 *     // Returns true if the cell in front is open and robot moves into the cell.
 *     // Returns false if the cell in front is blocked and robot stays in the current cell.
 *     public boolean move();
 *
 *     // Robot will stay in the same cell after calling turnLeft/turnRight.
 *     // Each turn will be 90 degrees.
 *     public void turnLeft();
 *     public void turnRight();
 *
 *     // Clean the current cell.
 *     public void clean();
 * }
 */
class Solution {
    
    // 非常有趣的题目
    int[][] directions = {{-1,0}, {0,1}, {1,0},{0,-1}};
    Set<String> visited = new HashSet<>();
    
    public void cleanRoom(Robot robot) {
        dfs(robot, 0, 0, 0);
    }
    
    private void dfs(Robot robot, int i, int j, int dirDegree) {
        String str = i+"-"+j;
        
        // System.out.println(str);
        visited.add(str);
        robot.clean();
        
        for (int k = 0; k < 4; k++) {
            
            // 我们可以把上次的方向拿来，因为recursive的dfs里面，方向不变的
            // 
            int x = i + directions[dirDegree][0]; 
            int y = j + directions[dirDegree][1];
            
            if (!visited.contains(x+"-"+y) && robot.move()) {
                // this robot can move and is moved
                
                dfs(robot, x, y, dirDegree);
                
                // come back
                robot.turnLeft();
                robot.turnLeft();
                robot.move();
                robot.turnRight();
                robot.turnRight();
            }
            robot.turnRight();
            dirDegree += 1;
            dirDegree %= 4;
        }
    }
}
```

几点解释一下：
- 每次dfs进来时（在dfs之前我们就认为这一点是没有visited过的），先保存左边，clean，再进入dfs的环节；这是一个很标准的流程。
- 进入循环后，我们首先判断一下下一步的坐标是啥，这个方向和上一级的方向是一致的；比如说当前点是右边的点左移过来的，那么现在我在这个点也左移。
- 接上面的例子，要是上面那个点的dfs完成了（请注意，dfs里面会有四个方向），那么，**此时robot的指向和刚进入其dfs的时候是一样的！**，然后我们直接回到上一级就好了。这里非常有意思的地方在于，我们在这里需要自己写代码回到上一级（不仅仅只靠调用栈）。
- 当一个方向的dfs完成或者这个方向不能dfs后，我们跳转方向就可以了，这里用`k`表示方向。

这个题目的主要特点是抽象，然后dfs的形式有点不太一样，但是不管怎么样，还是一个很典型的dfs题，个人觉得挺有意思的。

### <a id="322">322 Coin Change</a>


You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.

    Input: coins = [1, 2, 5], amount = 11
    Output: 3 
    Explanation: 11 = 5 + 5 + 1
    
这个题目实际上最容易想到的首先是dp的解法。请参考dp笔记中的代码。但是dp史上速度不快。这是因为对于每一个`dp[]`的entry，我们都要把`coins`循环一次。

在讨论dfs之前，实际上有一个很容易想到的方法。要想最终的数字最小，那很显然，每次我们可以取尽可能大的coin，然后再取小的。当时想到这个点的时候，有一点没有想好怎么解决，因为尽可能取小的并不能保证能够找到解，这个时候，就可以用到dfs了。

具体的解决办法就是，首先取尽可能大的，再dfs看能不能拿到解，要是不行的话，**松弛当前拿的数目**，再按照相同的办法做dfs。

```java
class Solution {
    
    int res = Integer.MAX_VALUE;
    
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        helper(coins, coins.length-1, 0, amount);
        return res == Integer.MAX_VALUE? -1: res;
    }
    
    private void helper(int[] coins, int index, int times, int amount) {
    
        if (amount == 0) {
            res = Math.min(res, times);
            return ;
        }
        
        if (index < 0) return ;
        
        int coin = coins[index]; // the current coin number to use
        for (int i = amount / coin; i >= 0; i--) {
            
            // removing this line will not affect the correctness of this algorithm
            // but removing this would greatly increase the efficiency
            // we already know that the new "times" will be larger than the current res
            // then no need to continue
            
            if (times + i >= res) break;
            helper(coins, index - 1, times + i, amount - i * coin);
        }
    }
}
```

请注意这里有一个剪枝的动作。

    if (times + i >= res) break;
    
这里可以剪枝是因为一旦此条件出现，那么就算后面可以找到解，也不会比当前的res小了，所以不必继续。

### <a id="72">72 Edit Distance</a>

Given two words `word1` and `word2`, find the minimum number of operations required to convert `word1` to `word2`.

You have the following 3 operations permitted on a word:

1. Insert a character
2. Delete a character
3. Replace a character

Example:

    Input: word1 = "horse", word2 = "ros"
    Output: 3
    Explanation: 
    horse -> rorse (replace 'h' with 'r')
    rorse -> rose (remove 'r')
    rose -> ros (remove 'e')

如果还是看不懂，请参考DP里面的解法。

这个题目实际上用DFS的话，思路也没有那么难理解。考虑两个pointer，从字后面开始扫描，假如两个位置的字符串匹配，那两个pointer就可以往前走，问题就变成了一个子问题，简单；但是如果不匹配的话，那就有三个分支可以考虑；这个时候就应该调整recursive call的相关参数。

以上是基本思路，更详细的说，这本质上也是一个DP的方法，只不过我们是从矩阵最后一个点开始的，所以在整个过程中，为了栈溢出，需要记录dp的值，也就是为什么下面的解法中要用`dp[][]`来存储结果。

```java
class Solution {
    
    public int minDistance(String word1, String word2) {
        // a dfs method
        int len1 = word1.length();
        int len2 = word2.length();
        int[][] dp = new int[len1][len2];
        return helper(word1, word2, len1-1, len2-1, dp);
    }
    
    private int helper(String w1, String w2, int i, int j, int[][] dp) {
        // given two words w1 and w2 (only substring at i and j respectively)
        // return the result
        // sort of like backtracing
        if (i == -1) return j + 1 ;
        if (j == -1) return i + 1;
        
        if (dp[i][j] > 0) return dp[i][j];
        
        if (w1.charAt(i) == w2.charAt(j)) {
            dp[i][j] = helper(w1, w2, i-1, j-1, dp);
            return dp[i][j];
        }
        
        int res = Integer.MAX_VALUE;
        res = Math.min(res, helper(w1, w2, i-1, j-1, dp) + 1); // consider replacing
        res = Math.min(res, helper(w1, w2, i-1, j, dp) + 1); // consider deleting
        res = Math.min(res, helper(w1, w2, i, j-1, dp) + 1); // consider inserting
        
        dp[i][j] = res;
        return res;
        
    }
}
```
