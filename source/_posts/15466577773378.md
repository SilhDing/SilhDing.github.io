5 Edge-weighted Digraph and Shortest Paths

[TOC]

## Introduction

In this section, we consider the following problem:

### Shortest paths

**Single-source shortest paths**. Given an edge-weighted digraph and a source vertex `s`, support queries of the form *Is there a directed path from `s` to a given target vertex `t`*? If so, find a shortest such path.

At the same time, please also note some important properties of shortest paths:
- Negative weights introduce complications. In the first part of this section, we will present the **Dijkstra's algorithm** to handle this case. 
- Shortest paths are normally simple. They will find no cycles.
- Shortest paths are not necessarily unique. We are content to find any of them.
- Parallel edges and self-loops may be present. Only the lowest-weight among a set of parallel edges will play in a role. No shortest path contains a self-loop.

### Shortest-paths tree

We focus on the single-source shortest-paths problem, where we are given a source vertex `s`. The result of the computation is a tree known as the **shortest-paths tree (SPT)**, which gives a shortest path from `s` to every vertex reachable from `s`. Such a tree roots at `s`.

This may rise a question by some readers: if the shortest path from `s` to `w` contains `t`, is the part of the path, which starts at `s` and ends at `t` also a shortest path in SPT? The answer if yes. If not, there there must be a shorter path from `s` to `t`, we call is as `L`; and for `s` to `w`, we could also find a shorter path: `L + t->w`, a contradiction.

## Data types

### `DirectedEdge`
API for directed edge class:

    public class DirectedEdge
    -------------------------
           DirectedEdge(int v, int w, double weight)
    double weight()
       int from()
       int to()
    String toString()

Implementation:

```java
public class DirectedEdge {
    
    private final int v;
    private final int w;
    private final double weight;
    
    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }
    
    public double weight() {
        return this.weight;
    }
    
    public int from() {
        return this.v;
    }
    
    public int to() {
        return this.w;
    }

    @Override
    public String toString() {
        return String.format("%d-%d %.2f", v, w, weight);
    }
}
```

### `EdgeWeightedDigraph`

API for edge-weighted directed graph class:

    public class EdgeWeightedDigraph
    --------------------------------
                           EdgeWeightedDigraph(int V)
                       int V()
                       int E()
                      void addEdge(DirectedEdge e)
    Iterable<DirectedEdge> adj(int v) 
    Iterable<DirectedEdge> edges()
                    String toString()

Implementation:

```java
public class EdgeWeightedDigraph {
    
    private final int V;
    private int E;
    private Bag<DirectedEdge>[] adj;
    
    public EdgeWeightedDigraph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<DirectedEdge>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<>();
        }
    }
    
    public int V() {
        return this.V;
    }
    
    public int E() {
        return this.E;
    }
    
    public void addEdge(DirectedEdge e) {
        adj[e.from()].add(e);
        E ++;
    }
    
    public Iterable<DirectedEdge> adj(int v) {
        return adj[v];
    }
    
    public Iterable<DirectedEdge> edges() {
        Bag<DirectedEdge> bag = new Bag<>();
        for (int v = 0; v < this.V; v++) {
            for (DirectedEdge e: adj[v])
                bag.add(e);
        }
        return bag;
    }

}
```
### `SP`

And the shortest-paths API:

    public class SP
    ---------------
                           SP(EdgeWeightedDigraph G, int s)
                    double dostTo(int v)
                   boolean hasPathTo(int v)
    Iterable<DirectedEdge> pathTo(int v)

In this class, we will use `edgeTo[]` and `distTo[]` to record SP.
    
### Edge relaxation

Edge relaxation is one of the basic operations in SP algorithms: to relax an edge `v->w` means to test whether the best known way from `s` to `v` us to fo from `s` to `v`, then take the edge from `v` to `w`, and , if so, update our data structures. 

In fact, the code below is more exlanatory.

```java
private void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] > distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
    }
}
```

### Vertex relaxation

Similarly, the code is also self-explanatory.

```java
private void relax(EdgeWeightedDigraph G, int v) {
    for (DirectedEdge e: G.adj(v)) {
         int w = e.to();
         if (distTo[w] > distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
        }
    }
}
```

## Theoretical basis

### Optimality conditions

**Shortest-paths optimality conditions**. Let `G` be an edge-weighted digraph, with `s` a source vertex in `G` and `distTo[]` a vertex-indexed array of path lengths in `G` such that, for all `v` reachable from `s`, the value of `distTo[v]` is the length of some path from `s` to `v` with `distTo[v]` equal to infinity for all `v` not reachable from `s`. These values are the lengths of shortest paths if and if they satisfy `distTo[w] <= distTo[v] + e.weight()` for each edge from `v` to `w` (or, in other words, no edge from `v` to `w` is eligible).

Now we prove this proposition.

1. **It is necessary**. Suppose there is an edge `e` from `v` to `w` such that `distTo[w] > distTo[v] + e.weight()`, then `e` would give a path from `s` to `w` (through `v`) of length less than `distTo[w]`, a contradiction.
2. **It is sufficient**. Suppose that `w` is reachable from `s` and that `s = v0->v1->v2...vk = w` is a shortest path from `s` to `w`, of weight `L`. If the optimality conditions hold, then:
    
    distTo[v<sub>k</sub>] <= distTo[v<sub>k-1</sub>] + e<sub>k</sub>.weight()
    distTo[v<sub>k-1</sub>] <= distTo[v<sub>k-2</sub>] + e<sub>k-1</sub>.weight()
    ...
    distTo[v<sub>2</sub>] <= distTo[v<sub>1</sub>] + e<sub>2</sub>.weight()
    distTo[v<sub>1</sub>] <= distTo[s] + e<sub>1</sub>.weight()
    
    Collapsing these inequalities and eliminating `distTo[s] = 0.0`, we have:
    
    distTo[w] = distTo[v<sub>k</sub>] <= e<sub>1</sub>.weight() + ... + e<sub>k</sub>.weight() = L
    
    On the other hand, `distTo[w]` must not be smaller than `L`:
    
    L <= distTo[w] <= L
    
    Then `distTo[w] == L`,  completing the proof.
    
### Generic algorithm

With the proposition above, it is easy to test the certification: however an algorithm computes `distTo[]`, we can check whether it contains shortest-path lengths in a single pass through the edges of the graph, checking whether the optimality conditions are satisfied. 

It also leads to a generic SP algorithm than en compasses all of the shortest-paths algorithms that we consider.

**Generic shortest-paths algorithm**. Initialize `distTo[s]` to `0` and all other `distTo[]` values to infinity, and proceed as follows: *Relax any edge in G, continuing until no edges is eligible*. For all vertices `w` reachable from `s`, the value of `distTo[w]` after this computation is the length of a shortest path from `s` to `w`.

Please note that the generic algorithm does not specify in which order the edges to be relaxed. It only provide a general description of SP algorithms. A SP algorithm needs to prove that it relaxes edged until no edge is eligible.

## Dijkstra's algorithm

Dijkstra's algorithm is similar to Prim's algorithm, which is used for finding the MST of an edge-weighted undirected graph. We begin by initializing `distTo[s]` to `0` and all other `distTo[]` entries to positive infinity, then we relax and add to the tree a non-tree vertex with the lowest `distTo[]` value, continuing until all vertices are on the tree or no non-tree vertex has a finite `distTo[]` value.

To prove the correctness, we may only need to prove that the Dijkstra's algorithm would achieve the optimality conditions. 

Note:
- Once a vertex is added into the tree, say `v`, `distTo[v]` would never change. This is because weights of edges are nonnegative and we process the currently lowest `distTo[]` value at each step.
- Say now `w` is not in the tree and `v` is any vertex in the tree the has a directed edge to `w`. Every edge `v->w` is relaxed exactly once by vertex relaxation function `relax(EdgeWeightedDigraph G, int v)` (Please note that every time when `w` is relaxed by a vertex, this vertex must be in the tree and its distance to the source would never change). Since `distTo[v]` would not change, after the algorithm complete, the optimality conditions would apparently hold, completing proof.

You may think this algorithm in another way: **it is in fact analogous to BFS in digraphs**. Starting with the source, and selecting the next closest vertex. However, in digraph, edges have equal weight values, thus it is feasible to get the next closest vertex just with a queue rather than a priority queue.

```java
public class DijkstraSP {

    private DirectedEdge[] edgeTo;
    private double[] distTo;
    private PriorityQueue<Integer> pq;

    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        this.edgeTo = new DirectedEdge[G.V()];
        this.distTo = new double[G.V()];
        pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                if(distTo[o1] < distTo[o2]) return -1;
                else if(distTo[o1] > distTo[o2]) return 1;
                else return 0;
            }
        });

        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0;

        pq.offer(s);
        while(pq.size() > 0) {
            relax(G, pq.poll());
        }

    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e: G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;

                if (pq.contains(w)) pq.remove(w);
                // in fact this checking is not necessary
                pq.offer(w);
            }
        }
    }

    public double distTo(int v) {
        return distTo[v];
    }

    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()])
            path.push(e);
        return path;
    }

}
```

Dijkstra's algorithm uses extra space proportional to `V` and time proportional to `ElogV`.

Variants to this algorithm are able to solve some problems below:

- **Single-source shortest paths in undirected graphs**. Given an edge-weighted undirected graph and a source vertex `s`, support queries of the form *Is there a path from `s` to a given vertex `v`*? If so, find a shortest such path.

    The solution is immediate once we treat the undirected graphs as directed graphs, which is in fact trivial.
    
- **Source-sink shortest paths**. Given an edge-weighted digraph, a source vertex `s`, and a target vertex `t`, find the shortest path from `s` tp `t`.

    Use Dijkstra's algorithm but terminate the search as soon as `t` coms off the priority queue.
    
- **All-pairs shortest paths**. Given an edge-weighted digraph, support queries of the form *Given a source vertex `s` and a target vertex `t`, is there a path from `s` to `t`? If so, find a shortest such path*.

    Solution is trivial as follows:
    
```java
public class DijikstraAllPairsSP {

    private DijkstraSP[] all;

    public DijikstraAllPairsSP(EdgeWeightedDigraph G) {
        all = new DijkstraSP[G.V()];
        for (int v = 0; v < G.V(); v++) {
            all[v] = new DijkstraSP(G, v);
        }
    }

    public Iterable<DirectedEdge> path(int s, int t) {
        return all[s].pathTo(t);
    }

    public double distTo(int s, int t) {
        return all[s].distTo(t);
    }

}
```
Please note that Dijkstra's algorithm assumes the values of edges are always nonnegative.

## Acyclic edge-weighted digraphs

In  many case, the digraphs we process are acyclic. In this case, there is an algorithm which is more efficient than the Dijkstra's algorithm, and it also works from negative values of edges' weights.

It is simpler than Dijkstra's algorithm, and it may solve the single-source problem in linear time. We initilize `distTo[s]` to `0` and all other `distTo[]` values to infinity, **then relax the vertices, one by one, taking the vertices in topological order**.

Why this is correct? It is not hard to reason. Every edge `v->w` is relaxed exactly once, when `v` is relaxed. When this algorithm completes, the optimality would always hold: `distTo[w] <= distTo[v] + e.weight()`. This is because `distTo[v]` would not change, as in the topological order, no edge pointing to `v` will be processed after `v` is relaxed (or, all vertices that are parent vertices of `w` have already been relaxed). The time bound is immediate: topological sort takes time proportional to `E+V` and the second relaxation pass completes the job by relaxing each edge once, again in time proportional to `E+V`.

```java
public class AcyclicSP {

    private DirectedEdge[] edgeTo;
    private double[] distTo;

    public AcyclicSP(EdgeWeightedDigraph G, int s) {
        edgeTo = new DirectedEdge[G.V()];
        distTo = new double[G.V()];

        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0.0;

        Topological top = new Topological(G);

        for (int v: top.order()) {
            relax(G, v);
        }
    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e: G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
            }
        }
    }

    public double distTo(int v) {
        return distTo[v];
    }

    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()])
            path.push(e);
        return path;
    }
}
```

Please note, in the code above, we use `Topological top = new Topological(G)` where G is `EdgeWeightedDigraph`. However, in our code of class `Topological`, no constructor would take such a class. Of Course, it is not hard to modify it. In the IDEA code base, I slightly change the code to exclusively get the topological order of an edge-weighted digraph with a helper function. Please refer to that code for a comprehensive review.

One interesting about this algorithm is: **if the source is `s`, all vertices that are in front of `s` in the topological order are not reachable from `s`**. Even these vertices and their edges are removed from the digraph, the SP results would remain unchanged. But also note that we cannot make sure that any vertex that is behind `s` in the topological sort is reachable from `s`.

The prerequisite of this algorithm is that **this digraph must be acyclic!** It also indicates that the absence of cycles considerably simplifies a problem.

**There is no requirement that the values of edges' weights be nonnegative.**

### Longest paths

Consider this problem:

**Single-source longest paths in edge-weighted DAGs**. Given an edge0weighted DAG (with negative weights allowed) and a source vertex `s`, support queries of the form: is there a directed path from `s` to a given vertex `v`? If so, find a *longest* such path.

This is based on the fact that this algorithm does not require weight values be nonnegative. So, we may create a copy of the given edge-weighted DAG that is identical to the original, except that all edge weights are negated. Then the shortest path in this copy is the longest path in the original. A straight-forward way is to negate the `e.weight()` in `relax()`, as follows:

```java
public class AcyclicLP {

    private double[] distTo;
    private DirectedEdge[] edgeTo;

    public AcyclicLP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];

        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0.0;

        getTopologicalSort(G);

        for (int v: topological) {
            relax(G, v);
        }
    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e: G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] - e.weight()) {
                distTo[w] = distTo[v] - e.weight();
                edgeTo[w] = e;
            }
        }
    }
    
    public double distTo(int v) {
        return -distTo[v];
    }
}
```

### Parallel job scheduling

Consider this problem:

**Parallel precedence-constrained scheduling**. Given a set of jobs of specified duration to be complete, with precedence constrains that specify that certain job have to be completed before certain other jobs are begun, how can we schedule the jobs on identical processors (as many as needed) such that they are all completed in the minimum amount of time while still respecting the constraints?

Here we study the **critical path method** to solve this problem. It demonstrate that this problem is in fact equivalent to a longest-paths problem in an edge-weighted DAG.

For every possible processor and their processing path, the longest processing path that determines the total processing time is called **critical path**.

How does critical path work? Create an edge-weighted DAG with a source `s`, a sink `t`, and two vertices fro each job (a *start* vertex and an *end* vertex). For each job, add an edge from its start vertex to its end vertex with weight equal to its duration. For each precedence constraint `v->w`, add a zero-weight edge from the end vertex corresponding to `v` to the beginning vertex corresponding to `w`. Also add zero-weight edges from the source to each job's start vertex and from each job's end vertex to the sink. Now, schedule each job at the time given by the length of its longest path from the source. 

```java
public class CPM {

    AcyclicLP lp;
    int s; // start vertex
    int t; // end vertex

    public CPM(Job[] jobs) {
        int N = jobs.length; // the number of all jobs
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*N + 2);

        s = 2*N;
        t = 2*N + 1;
        for (int i = 0; i < N; i++) {
            // visit every job

            double duration = jobs[i].duration;

            // edge from start vertex to end vertex with weight of duration
            G.addEdge(new DirectedEdge(i, i+N, duration));

            // edge from s to every start vertex
            G.addEdge(new DirectedEdge(s, i, 0.0));

            // edge from every end vertex to t
            G.addEdge(new DirectedEdge(i+N, t, 0.0));

            // add edge determined by precedence constraints
            for (int j: jobs[i].precedence) {
                G.addEdge(new DirectedEdge(i+N, j, 0.0));
            }

        }
        lp = new AcyclicLP(G, s); // find lp from s to t
    }

    public double startTime(int jobID) {
        return lp.distTo(jobID);
    }

    public double longestTime() {
        return lp.distTo(t);
    }

    public static void main(String[] args) {
        Job[] jobs = new Job[10];
        jobs[0] = new Job(0, 41, 1, 7, 9);
        jobs[1] = new Job(1, 51, 2);
        jobs[2] = new Job(2, 50);
        jobs[3] = new Job(3, 36);
        jobs[4] = new Job(4, 38);
        jobs[5] = new Job(5, 45);
        jobs[6] = new Job(6, 21, 3, 8);
        jobs[7] = new Job(7, 32, 3, 8);
        jobs[8] = new Job(8, 32, 2);
        jobs[9] = new Job(9, 29, 4, 6);

        CPM cpm = new CPM(jobs);

        System.out.println("Start time:");
        for (int i = 0; i < 10; i++) {
            System.out.println(i + ": " + cpm.startTime(i));
        }
        System.out.println("Finish time: " + cpm.longestTime());
    }
}

class Job {
    int id;
    double duration;
    Bag<Integer> precedence;

    public Job(int id, double duration, int ... data) {
        this.id = id;
        this.duration = duration;
        this.precedence = new Bag<>();

        for (int i = 0; i < data.length; i++) {
            this.precedence.add(data[i]);
        }
    }
}
```

The code above is different from the code in the textbook. We here write a class for jobs and a complete class `CPM`, supporting queries when a job should begin and the time all jobs are done.

Why the critical path method would solve the parallel precedence-constrained problem? This is because: all the start and finish times implied by longest paths are feasible--every job starts after the finish of all the jobs where it appears as a successor in a precedence constraint, because the start time is the length of the longest path from the source to it.

At the same time, the finish time is always minimal (reasoning is trivial).

### Parallel job scheduling with relative deadlines

See Page 666-667 for details.

## SPs in general edge-weighted digraphs

We provide some algorithms to solve SP problem in edge-weighted digraphs that allow cycles and negative weights of edges.

### Negative cycls

A **negative cycle** in an edge-weighted digraph is a directed cycle whose total weight is negative.

When we consider digraphs that have could have negative edge weights, the concept of a shortest path is meaningless if there is a negative cycle in the digraph, as we can spin around that cycle to generate arbitrary short paths.

Thus, **here comes an important proposition**: there exists a shortest path from `s` to `v` in an edge-weighted digraph if and only if there exists at least one directed path from `s` to `v` and no vertex on any directed path from `s` to `v` is on a negative cycle.

Please note that, in the proposition above, there requires that **any** vertex in **any** directed path is not in a negative cycle.

Thus, an SP algorithm should:

- Assign a shortest-path weight of +infinity to vertices that are not reachable from the source
- Assign a shortest-path weight of -infinity to vertices that has a vertex that is on a negative cycle
- Compute the shortest-path weight for all other vertices

Now, we focus on two problems:

**Negative cycle detection**. Does a given edge-weighted digraph have a negative cycle? If it does, find one such cycle.

**Single-source shortest paths when negative cycles are not reachable**. Given an edge-weighted digraph and a source `s` with no negative cycles reachable from `s`, support queries of the form *Is there a directed path from `s` to a given target vertex `v`*? If so, find a shortest such path.

### Bellman-Ford algorithm

The following method solves the single-source shortest-paths problem from a given source `s` for an edge-weighted digraph with `V` vertices and no negative cycles reachable from `s`: Initialize `distTo[s]` to `0` and all other `distTo[]` values to infinity. Then, considering the digraph's edges in any order, relax all edges. Make `V` such passes.

It is easy to prove its correctness by induction. See Page 671 for more detail.

Please note this method is general and it does not specify the order in which the edges are relaxed.

#### Queue-based Bellman-Ford

In fact, the general Bellman-Ford algorithm is not so efficient, as it is not necessary to relax every edge in every pass. The only edges that could lead to a change in `distTo[]` are those leaving a vertex whose `distTo[]` value changed in the previous pass. We may use a queue to achieve that purpose.

To understand the algorithm and the general one, please refer to the notes in the textbook between Page 672 and page 673. The code is also, at least to some degree, is self-explanatory.

#### Negative cycles detection

How to detect negative cycles? The solution is much easier when we have finished `V` passes. In fact, the digraph has a negative cycle reachable from the source if and only if the queue is nonempty after the Vth pass through all the edges. Moreover, the subgraph of edges in our `edgeTo[]` array much contain a negative cycle. Accordingly, to implement, we built an edge-weighted digraph from the edges in `edgeTo[]` and look for a cycle in that digraph.

#### Code in one class
Below is a complete implementation of Bellman-Ford algorithm.

Please note that class `EdgeWeigtedDirectedCycle` is very similar to `DirectedCycle`. They both use `onStack[]` to detect cycles in a digraph.

```java
public class BellmanFordSP {

    private double[] distTo;
    private DirectedEdge[] edgeTo;
    private boolean[] onQ;
    private Queue<Integer> queue;
    private int cost;
    private Iterable<DirectedEdge> cycle;

    public BellmanFordSP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];
        onQ = new boolean[G.V()];
        queue = new Queue<>();
        for (int v = 0; v < G.V(); v++) {
            distTo[v] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0.0;

        queue.enqueue(s);
        onQ[s] = true;
        while (!queue.isEmpty() && !hasNegativeCycle()) {
            int v = queue.dequeue();
            onQ[v] = false;
            relax(G, v);
        }
    }

    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e: G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (!onQ[w]) {
                    queue.enqueue(w);
                    onQ[w] = true;
                }
            }
            if (cost++ % G.V() == 0) {
                findNegativeCycle();
            }
        }
    }

    public double distTo(int v) {
        return distTo[v];
    }

    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<DirectedEdge> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<DirectedEdge> path = new Stack<>();
        for (DirectedEdge e = edgeTo[v]; e != null; e = edgeTo[e.from()])
            path.push(e);
        return path;
    }

    private void findNegativeCycle() {
        int V = this.edgeTo.length;
        EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V);
        for (int v = 0; v < V; v++) {
            if (edgeTo[v] != null) spt.addEdge(edgeTo[v]);
        }

        EdgeWeightedDirectedCycle cf = new EdgeWeightedDirectedCycle(spt);
        cycle = cf.cycle();
    }

    private boolean hasNegativeCycle() {
        return cycle != null;
    }

    private Iterable<DirectedEdge> negativeCycle() {
        return cycle;
    }

}
```

#### Arbitrage

It is a small application of Bellman-Ford algorithm and negative cycle detection. Refer to Page 679 for more details.

