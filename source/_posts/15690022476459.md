# Design Pattern Discussion

## Strategy Pattern

The strategy pattern is helpful in defining various algorithms with a single interface. In the abstract class or interface, the algorithm is not implemented, and each subclasses should implement it on its own. In addition, the client may choose different algorithms according to its needs. 

### Strength

1. Each algorithm is in fact not tightly coupled with the context. It is very convenient to implement more variants of this algorithm and modify any algorithm, as it would not cause impact on the context or the client code. In our project, we may easily implement more types of verifiers that have no impact on the existing verifiers.
2. A single instance of one algorithm would be used multiple times. In strategy pattern, client class may provide a constructor that takes the algorithm class as an argument, such as:

    ```java
    class AscendingSort() implements SortMethod {
        @Override
        public void sort() {
            // Do something here...
        }   
    }
    
    class ClientClass {
        
        public ClientClass(SortMethod method, int[] array) {
            // Do something here...
        }
    }
    ```
    In this example, the instance of `AscendingSort` could be used by other clients and it indeed saves some memory space. Similarly, an instance of verifier can also be used by other clients without creating new.
    
1. It would avoid using a lot of `if...else` or `switch` statements, as this pattern is in fact a good way to select a desired verifier. 

### Weakness

1. When trying to use the verifiers, the client needs to know how each verifier is different from others then select the one which is the best for its situation. 
2. Overhead is large if the strategies are really simple, as you need some extra classes or interfaces. For some verifiers (like the basic verifier), the implementation could be simple, and using strategy pattern may induce some redundant code.

## Template Pattern

In template pattern, the main operation is templated and contains many small operations, and some of the small operations are variants. The subclasses cannot override the template function and need to implement the variants of small operations.

### Strength

1. Template patterns can achieve code reuse. We may reuse the invariant parts of the algorithm and do not need to bother implementing them again. In out case, all sudoku verifiers would share a method `basicCheck` which only checks whether a solution grid is a basic solution (e.g., a normal sudoku problem) to the original problem.
2. We can strictly refine the operation for each subclass with the template function. The template function is always `final` and cannot be overridden by its subclasses. In our project, we can define the operation in template function into two steps: `basicCheck` and `extraCheck`.

### Weakness

1. Flexibility is in fact limited as the subclasses cannot override the template function; it could only decide the implementation of the variant part of the algorithm. Once we define the operation into two steps (`basicCheck` and `extraCheck`), the operation is then fixed, and we could only implement different variants of `extraCheck`.
2. Making modification to the system based on the template pattern may appear hard. For example, if we change the operations in the template function, all other subclasses may need to reconsider the implementation of the variants parts of the algorithm. If we want to change the way of checking the validity of a solution, we may also need to change the implementation of overridden functions in subclasses.

## Which is better?

Based on the pros and cons of each pattern, I think the strategy pattern would be better for our project:

1. It is highly possible that we have to add new verifiers in the future, and they may have totally different implementation. Using strategy pattern would have little impact on other verifier implementation we have currently.
2. It is too dangerous in template pattern to define the operation into two steps (`basicCheck` and `extraCheck`). Probably a new verifier do not need the `basicCheck` method and have a totally new way to check the solution.

## Extend to Numbrix 

Now we want to extend the current solution to a new puzzle type: numberix. 

### Strength

1. We may still use inheritance and current structure for this new verifier and adding this new verifier will not have impact on other verifiers.
2. The numbrix grid has similar format to sudoku grid, which means we could use the exist grid class to represent numbrix grid (though we need to make some modification).

### Weakness

1. We currently only have a `SudokuGrid` class to represent the grid. This class would automatically check the validity of the grid when the constructor is called. Apparently, we cannot use it for numbrix grid.
2. Currently we only have an abstract sudoku verifier class for all sudoku verifiers, and that is not enough. We may need more a more general interface for abstract sudoku verifiers and abstract numbrix sudoku verifiers.

### Modification

In order to support the numbrix grid puzzle, I made the following modification:

1. Create an abstract class `AbstractGrid`, which is the super class of all different kinds of grid classes. Currently, it has two subclasses: `NumberixGrid` and `SudokuGrid`. Each subclass has it own way to verify the validity of the grid.
2. **I choose the strategy pattern for this new feature.** This is because the strategy pattern has better flexibility and may accommodate different implementation of the algorithm.
3. I created an interface called `GridVerifierInt` which should be implemented by all verifier classes. Two abstract classes (`AbstractNumberixVerifierStrategy` and `AbstractSudokuVerifierStrategy`) are created, and they also implements the interface. In each of the abstract class, some shared functions are implemented internally, which act as helper functions for their subclasses.