# One interesting question

895 Maximum Frequency Stack

Implement `FreqStack`, a class which simulates the operation of a stack-like data structure.

`FreqStack` has two functions:

- `push(int x)`, which pushes an integer `x` onto the stack.
- `pop()`, which removes and returns the most frequent element in the stack.If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.

Example:

    Input: ["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],
    [[],[5],[7],[5],[7],[4],[5],[],[],[],[]]
    Output: [null,null,null,null,null,null,null,5,7,5,4]
    Explanation:
    After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:
    
    pop() -> returns 5, as 5 is the most frequent.
    The stack becomes [5,7,5,7,4].
    
    pop() -> returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.
    The stack becomes [5,7,5,4].
    
    pop() -> returns 5.
    The stack becomes [5,7,4].
    
    pop() -> returns 4.
    The stack becomes [5,7].
    
    
这个题目挺有意思。你会发现两个数据结构相当于保存了整个的`push`记录，那所谓的`pop`也就只是删除最近的记录而已。

```java
class FreqStack {
    // the basic idea is to maintain a stack for each number
    // if there are 3 "1"s, you may find one in stack for 1, for 2 and for 3
    // we always pop a number from the stack with highest number
    // use one mao to record the number of one element
    // you may refer to your notes if you still cannot understand
    
    LinkedList<Stack<Integer>> listStack;
    Map<Integer, Integer> map;
    
    public FreqStack() {
        listStack = new LinkedList<>();
        map = new HashMap<>();
    }
    
    public void push(int x) {
        map.put(x, map.getOrDefault(x, 0)+1);
        
        int freq = map.get(x);
        if (freq-1 >= listStack.size()) listStack.add(new Stack<>());
        
        listStack.get(freq-1).push(x);
    }
    
    public int pop() {
        // always pop from the last one
        Stack<Integer> stack = listStack.get(listStack.size()-1);
        int res = stack.pop();
        if (stack.size() == 0) listStack.pollLast();
        
        map.put(res, map.get(res)-1);
        return res;
    }
}
```