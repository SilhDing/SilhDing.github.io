## 3. 链表实现
#### 首先我们实现Node类

```python
class Node(object):
    def __init__(self, data, next = None):
        self.data = data
        self.next = next
```


```python
# 示例：创造一个链表
head = None

for count in range(1, 6):
    head = Node(count, head)
    
while head:
    print(head.data)
    head = head.next
```

    5
    4
    3
    2
    1


#### 初始化一个链表


```python
# 接下来我们来看链表的各种操作。首先先初始化一个链表: 5 -> 4 -> 3 -> 2 -> 1
head = None

for count in range(1, 6):
    head = Node(count, head)
```

#### 遍历


```python
# 1. 遍历
def traverse(head):
    probe = head
    while probe:
        print("data of linkedlist: ", probe.data)
        probe = probe.next

traverse(head)
```

    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


#### 搜索


```python
# 2. 搜索
def search(head, targetNum):
    probe = head
    while probe and targetNum != probe.data:
        probe = probe.next
    if probe:
        print("Target has been found!")
    else:
        print("No such target found!")
        
search(head, 3)
search(head, 10)
```

    Target has been found!
    No such target found!


#### 按照index访问某个节点


```python
# 3. 访问链表的某节点 index
def access(head, index):
    probe = head
    while probe and index > 0:
        probe = probe.next
        index -= 1
    if probe:
        return probe.data
    else:
        return "out of index"

print(access(head, 2))
print(access(head, 5))
```

    3
    out of index


#### 替换（通过内容或者索引）


```python
# 4. 替换
def replace_by_data(head, targetItem, newItem):
    # 第一种替换的方法：先找到目标项再替换
    probe = head
    while probe != None and targetItem != probe.data:
        probe = probe.next
    if probe != None:
        probe.data = newItem
        return True
    else:
        return False
    
def replace_by_index(head, index, newItem):
    probe = head
    while index > 0:
        probe = probe.next
        index -= 1
    probe.data = newItem
    
replace_by_data(head, 3, 30)
traverse(head)
print('\n')
replace_by_index(head, 2, 3)
traverse(head)
```

    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  30
    data of linkedlist:  2
    data of linkedlist:  1
    
    
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


#### 在开始时插入一个节点


```python
# 5. 在开始时插入

def insert_at_start(newItem, head):
    return Node(newItem, head)

head = insert_at_start(6, head)
traverse(head)
```

    data of linkedlist:  6
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


请注意，这个函数返回的是新链表的`head`。

#### 在结尾插入


```python
# 6. 在结尾插入
def insert_at_end(newItem, head):
    newNode = Node(newItem)
    if head is None:
        head = newNode
    else:
        probe = head
        while probe.next:
            probe = probe.next
        probe.next = newNode

insert_at_end(0, head)
traverse(head)
```

    data of linkedlist:  6
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1
    data of linkedlist:  0


#### 在开始处删除


```python
# 7. 在开始处删除
def remove_at_start(head):
    removedItem =  head.data
    head = head.next
    return removedItem, head

removed, head = remove_at_start(head)
print(removed)
traverse(head)
```

    6
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1
    data of linkedlist:  0


请注意，我们假设这个链表至少有一个节点。

请注意，新的`head`一定要做作为返回对象才行，否则无效。返回的`removedItem`是被删除节点的值。

另一方面，为什么还要返回这个`head`呢？因为`head`已经被重新定义了（`Node`本身可以看成是不可变量）。

#### 在末尾删除


```python
# 8. 在末尾删除
def remove_at_end(head):
    removedItem = head.data
    if not head.next:
        head = None
    else:
        probe = head
        while probe.next.next:
            probe = probe.next
        removedItem = probe.next.data
        probe.next = None
    return removedItem, head

removed, head = remove_at_end(head)
print(removed)
traverse(head)
```

    0
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


#### 在任何位置插入


```python
# 9. 在任何位置插入（从第i个位置插入）
def insert_at_index(head, index, newItem):
    if head is None or index <= 0: # 如果head本身是None，或者index为非正数
        head = Node(newItem, head)
    else:
        probe = head
        while index > 1 and probe.next != None:
            probe = probe.next
            index -= 1
        probe.next = Node(newItem, probe.next)
    return head

insert_at_index(head, 2, 100)
traverse(head)
```

    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  100
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


注意，上面的例子中，虽然大部分的情况下我们不会对`head`赋予新的Node，但是考虑到个别的情况，还是需要return一个`head`

#### 在任何地方删除


```python
# 10. 在任何地方删除
def remove_at_index(head, index):
    if index <= 0 or head.next is None:
        removedItem = head.data
        head = head.next
        return removedItem, head
    else: 
        probe = head
        while index > 1 and probe.next != None:
            probe = probe.next
            index -= 1
        removedItem = probe.next.data
        probe.next = probe.next.next
        return removedItem, head

removedItem, head = remove_at_index(head, 2)
print(removedItem)
traverse(head)
```

    100
    data of linkedlist:  5
    data of linkedlist:  4
    data of linkedlist:  3
    data of linkedlist:  2
    data of linkedlist:  1


请注意，实际上，和数组相比，**链表的优势并不在于时间性能，而在于空间性能。**但是，同时也会有一个额外的内存代价，因为指针也需要内存来存储。

### 链表的变体
#### 带有一个哑头结点的循环链表结构 dummy header node
在这个实现中，至少总是有一个节点（哑节点）。这个节点是不包含数据的。在空的链接表中，`head`指针指向了哑结点，也就是本身：

    head = Node(None, None)
    head.next = head
    
如果链表非空，那哑结点会指向第一个结点，最后一个结点会指向哑结点，这样就形成了一个循环结构。在单链表中，我们对开始插入和中间插入是分开探讨的，这是因为`head`有个时候需要重置。但在这个实现中，就方便的多。


```python
# 在第i个位置插入新的节点
def insert_at_index_dummy_header_node(head, index, newItem):
    probe = head
    while index > 0 and probe.next != head:
        probe = probe.next
        index -= 1
    probe.next = Node(newItem, probe.next)
```

#### 双链表结构
每个节点会有`previous`和`next`两个指针，同时，还有一个`tail`直接指向最后一个节点。首先实现一个双链表数据结构


```python
class TwoWayNode(object):
    
    
    def __init__(self, data, previous = None, next = None):
        Node.__init__(self, data,next)
        self.previous = previous
```

下面是一个测试程序。请注意，这是一个倒序的打印。


```python
head = TwoWayNode(1)
tail = head

for data in range(2, 6):
    tail.next = TwoWayNode(data, tail)
    tail = tail.next
    
probe = tail 
while probe != None:
    print(probe.data)
    probe = probe.previous
```

    5
    4
    3
    2
    1



