## Case Study: bucket sort

In some cases when we need sorting, we do not need a complete sort. Bucket sorting would help a lot.

### 220 Contains Duplicates III

Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.

Example:

    Input: nums = [1,5,9,1,5,9], k = 2, t = 3
    Output: false
    
At first, we look at a one-pass solution. For each number `num` in `nums`, we only have to look for numbers in the range of `[num-k, num+k]`. Thus it is intuitive to use `TreeMap`.

```java
public boolean containsNearbyAlmostDuplicate2(int[] nums, int k, int t) {
    // one pass on all nums
    // for each num, find [num-k, num+k] range using binary search
    TreeSet<Long> set = new TreeSet<>();
    for (int i = 0; i < nums.length; i++) {
        long num = nums[i];
        Long max = set.floor(num + t);
        Long min = set.ceiling(num - t);
        
        if ((max != null && max >= num) || (min != null && min <= num)) {
            return true;
        }
        
        set.add((long)num);
        if (i >= k) set.remove((long)nums[i-k]);
    }
    return false;
}
```

Another idea is to add all numbers to some buckets so that for `num` and its bucket number `b`, if `b` already exists, or `b+1` or `b-1` is present, we then know we have such a subarray.

Now the key is to determine the size of each bucket.

```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    // this solution is better
    // we use buckets to store all numbers
    // the bucket size if always t+1, so if the bucket exist, return true
    // if we find bucket -+ 1, then also possible to return true
    if (k <= 0 || t < 0) return false;
    Map<Long, Long> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        long cur = (long)nums[i] - Integer.MIN_VALUE;
        long bucket = cur/((long)t + 1);  // make sure the bucket size is t + 1
        
        if (map.containsKey(bucket)) return true; // numbers in a bucket must meet requirement
        if (map.containsKey(bucket - 1) && cur - map.get(bucket - 1) <= t) return true;
        if (map.containsKey(bucket + 1) && map.get(bucket + 1) - cur <= t) return true;
        
        map.put(bucket, cur);
        
        // get rid of the furthest one
        if (i >= k) map.remove(((long)nums[i-k] - Integer.MIN_VALUE)/((long)t + 1));
    }
    
    return false;
    
}
```