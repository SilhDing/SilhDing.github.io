# XOR Example

This is a very interesting problem with XOR.

### 137 Single Number II

Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

The Single Number I problem is much easier and you may start with that for better understanding.

This is somewhat hard to deal with, though we have very short solution. **In fact, it is like storing the number of '1's every time. Since each of the 32 bits follow the same rules, we just need to consider 1 bit.** Thus, the conversion should be:

00->01->10->00 when we get '1'; if '0', the state is not changed.

There are three states, so we need two bits.


    ab      new     ab
    00      0       00
    01      0       01
    10      0       10
    00      1       01
    01      1       10
    10      1       00
    
It is then easy to get:

**For `a`:**

old a | old b | new number | new a
------------ | ------------- |--------- | ----
0 | 0 | 0 | 0
0 | 1 | 0 | 0
1 | 0 | 0 | 1
0 | 0 | 1 | 0
0 | 1 | 1 | 1
1 | 0 | 1 | 0

Thus it is easy to get: `a = a&~b&~x | ~a&b&x`.

**For `b`:**

old a | old b | new number | new b
------------ | ------------- |--------- | ----
0 | 0 | 0 | 0
0 | 1 | 0 | 1
1 | 0 | 0 | 0
0 | 0 | 1 | 1
0 | 1 | 1 | 0
1 | 0 | 1 | 0

Thus, `b = ~a&b&~x | ~a&~b&x` 