# `VodServer` Design

by: Yihang Ding (yihangd)

## Usage

### Run the Project

To compile the project, simply run `make` in the project root directory. If you want to remove all `.class` files, simply run `make clean` under that directory.

To run the project, simply run the command below:

```sh
$ java edu.cmu.ece.VodServer [PORT_NUMBER] [MAX_THREAD](optional)
```

Note that **you must specify the port number** otherwise the server would not work. The second argument, which is optional, specifies maximum number of threads of the server (more details later).

### Test the Server

You may initialize one connection with browser to the server and check what you get back, with the URL:

    http://[IP_ADDRESS]:[PORT]/[FILE_PATH]

The `FILE_PATH` in the URL always corresponds to the file on the server with the path `[PROJECT_ROOT_PATH]/content/[FILE_PATH]`.

**The server currently only supports `GET` request** and would only return 3 types of response: 

- `200 OK` (if a file is completely fetched)
- `206 Partial content` (if parts of the file are fetched) 
- `404 Not Found` (cannot find the file on server). 

The server only supports the following file types:

- Text file: `.txt`, `.css`, `.htm`, `.html`;
- Image file: `.gif`, `jpg`, `.jpeg`, `.png`;
- Video file: `.mp4`, `.webm`, `.ogg`;
- Application file: `.js`

**Other types of file would be specified as `application/octet-stream`** in the headers of response, and it is possible you cannot open them on the browser.

## Implementation

### Architecture

The server is implemented mainly by three classes: `VodServer`, `Request` and `Response`. The `VodServer` would initialize a `ServerSocket` and listen on the port for incoming requests. For each request, it would be processed as follows:

- The request would be captured by the `ServerSocket` who is listening on the server port;
- A new instance of `Request` would be initialized, which is responsible for parsing the request headers and getting some important request information, such as URI, range of contents requests;
- A new instance of `Response` would be initialized, which is responsible for generating headers of response, reading the requested file on server file system, and iteratively writing the file content to the client if the file indeed exists;
- After serving the request, if `Keep-Alive` is enabled, come back to listen to input stream for new possible requests; otherwise shut down the output stream.

**A simple cache is implemented here** to avoid too much open files. The cache would simply save the most recently accessed small file (< 15000 Bytes) in memory. Cache invalidation or consistency is not considered here (we assume files on server are not modified when the server is running). 



### Concurrency

The server is able to concurrently handle multiple requests, which is achieved by the multi-threaded design. When a new request comes in and is captured by the server, main process would create a new thread that processes the request (parse the request and send response). 

To better manage threads and avoid too much running threads in the system, a fixed-number thread pool is used here via `ThreadService` provided by Java. The maximum number of threads is set as `4000` currently. **You may have to change this value depending on your hardware supporting**. For example, if your machine that runs the server only has 8 GB memory, then out-of-memory (OOM) issue is possible to appear when testing the server with a high concurrency level. You may have to manually specify a lower number of threads as a argument of command when startiing the server:

```sh
$ java edu.cmu.ece.VodServer [PORT_NUMBER] [MAX_THREAD](optional)
```

#### Test Concurrency

The code is deployed on an Andrew Unix machine and an apache bench test is running on an AWS EC2 `t2.2xlarge` Ubuntu instance (maximum open files: `65535`). It is found the server could support 2000-2500 concurrent requests (getting a 10 Kb file) while ensuring 95% of them are served within 500ms (Note the conclusion depends on the network conditions). Test command is listed below:

```sh
ab -c 5000 -n 5000 http://[IP]:[PORT]/[FILE_PATH]
```

#### Test Tips

As we mentioned before, **the concurrency capability of the server strongly depends on the hardware supporting of the server.** Thus, it is common to encounter some problems when trying to test with a high concurrency level. Here are some suggestions for your OS and hardware:

1. Try to increase your **maximum number of open files**. You may use `ulimit -n [limit]` to change the value (super user permission is needed);
2. Try to use machine with **larger memory**. Generally 32 GB or more memory would be enough for test with concurrency level 5000.

Try with the following tips if you encounter some issues with ab testï¼š

1. **OOM Exception**. This is due to you are running too many threads than expected. In this case, try to specify the maximum number of thread (default value is 4000) when you start the server, e.g., `java edu.cmu.ece.VodServer 10001 1000` (specified as 1000). Try to include `-k` in ab test as well in order to use the keep-alive feature.
2. **Too many open files**. This is because the open file numbers exceeds the limit of the operating system. You could try to increase the limit manually. But if you cannot modify it as you do not have the root user permission, then try to decrease the concurrency level and include `-k` in ab test, e.g,

    ```sh
    ab -k -n 5000 -c 1000 http://127.0.0.1:10001/file.txt
    ```
It would use less sockets and each socket may contain multiple requests.