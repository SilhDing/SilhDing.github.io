<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Yihang (Ian) Ding">


    <meta name="subtitle" content="Glad you reach here.">




<title>Tag: algorithm | Yihang&#39;s Blog</title>



    <link rel="icon" href="/favicon.png">


<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,700|Noto+Serif+KR:300,700|Source+Code+Pro:400,400i,700,700i&display=swap" rel="stylesheet">



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
            <a href="/">楽しんでね。| Yihang&#39;s Nest</a>
            </div>

            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">楽しんでね。| Yihang&#39;s Nest</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">✐  Post</a>
                
                    <a class="menu-item" href="/category">➭  Category</a>
                
                    <a class="menu-item" href="/tag">✰  Tag</a>
                
                    <a class="menu-item" href="/about">❐  Résumé</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>

        <div class="main">
            

    
<div class="container">
    <div class="post-wrap tags">
        <h2 class="post-title"> ⍟ | Tags | algorithm</h2>
    </div>
    <div class="post-wrap archive">
    
    
        

        
            <h1>2020</h1>
        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/04/18/string-algorithm/">Algorithms Case Study: String</a>
            <span class="archive-item-date">Apr 18, 2020</span>
            <!-- <span style=> <p>In this post, we want to study and summarize some well-known algorithms for Strings.</p>
<h2 id="String-Sorts"><a href="#String-Sorts" class="headerlink" title="String Sorts"></a>String Sorts</h2><h3 id="LSD"><a href="#LSD" class="headerlink" title="LSD"></a>LSD</h3><p>If we want to sort some items and each item is associated with a key (or ID). We could use <em>key-indexed</em> counting to sort, which is very efficient. This method also indicates that we could follow the same idea to sort <strong>fixed-length</strong> strings, which is called <strong><em>least-significant-digit first (LSD)</em></strong> sort.</p>
<p>The basic idea is to conduct key-indexed counting for w times, where w is the length of each string.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LSD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// W is the length of each string in a</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = W - <span class="number">1</span>; d &gt;= <span class="number">0</span>; d--) &#123;</span><br><span class="line">            <span class="comment">// Sort by key-indexed counting on dth char.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// Computer frequency counts.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                count[a[i].charAt(d) + <span class="number">1</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Transform counts to indices.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">                count[r+<span class="number">1</span>] += count[r];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Distribute.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Copy back.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                a[i] = aux[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a  = &#123;<span class="string">"43FRFN"</span>, <span class="string">"423FFE"</span>, <span class="string">"D439JN"</span>, <span class="string">"10NE2E"</span>,</span><br><span class="line">                        <span class="string">"DDERFR"</span>, <span class="string">"340FEW"</span>, <span class="string">"104FDS"</span>, <span class="string">"R4053N"</span>&#125;;</span><br><span class="line">        LSD.sort(a, <span class="number">6</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time complexity: <code>O(W(N + R))</code>, where <code>N</code> is the number of all string to be sorted, <code>R</code> is the radix (number of characters in alphabet) and <code>W</code> is the width of each string.</p>
<p>Space complexity: <code>O(N + R)</code>, as we use two additional arrays.</p>
<p>Remember that there are some requirements when applying this method:</p>
<ol>
<li>Each string has the same length (certainly we can modify this method to accommodate this case, but we have other algorithms that work well for this scenario);</li>
<li>We know the radix of the alphabet of these strings (in this case, 256).</li>
</ol>
<h3 id="MSD"><a href="#MSD" class="headerlink" title="MSD"></a>MSD</h3><p>LSD algorithm listed above only works for fix-length strings. Here we want to implement an algorithm that works for a general purpose: <em>most-significant-digit-first (MSD)</em>.</p>
<p>We still follow the basic idea of key-indexed counting to complete this algorithm. Now, as the algorithm’s name indicates, we will start sorting based on the most significant digits. So, if we have sorted them based on the first digit, what should we do next? <strong>We can group (or split) these strings and sort in each group based on other digits,</strong> which requires a recursive algorithm.</p>
<p>Remember, this algorithm does not require all strings with same length. What should we do if, in a group, there are string which are shorter than others and we have reached the end of these short strings during key-indexed counting? Okay, we know that shorter strings here should be sorted first, so here is the solution:</p>
<p>Implement a new <code>toChar()</code> method that can convert from an indexed string character to an array index that returns -1 if the specified character position is pass the end of the string. Then, we just add 1 to each returned value, so get a nonnegative <code>int</code> that we can use to index <code>count[]</code>. It means we have <code>R+1</code> possible character values at each string position:</p>
<ul>
<li><code>0</code> to signify the end of the string;</li>
<li><code>1</code> for the first alphabet character;</li>
<li><code>2</code> for the second alphabet character;</li>
</ul>
<p>With all these practices above, now it is easy to write down the real code.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MSD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;  <span class="comment">// radix</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">0</span>;  <span class="comment">// cutoff for small subarrays</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] aux; <span class="comment">// auxiliary array for distribution</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> String[N];</span><br><span class="line">        sort(a, <span class="number">0</span>, N-<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Cut-off if the number of string is too small</span></span><br><span class="line">        <span class="keyword">if</span> (lo + M &gt;= hi) &#123;</span><br><span class="line">            Insertion.sort(a, lo, hi, d);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// Compute frequency counts.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            count[charAt(a[i], d) + <span class="number">2</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transform counts to indices.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R +<span class="number">1</span>; i++) &#123;</span><br><span class="line">            count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Distribute.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            aux[count[charAt(a[i], d) + <span class="number">1</span>]++] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy back.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="comment">// Consider why i - lo here: because we only sort hi- lo + 1 strings, starting with index 0 in aux</span></span><br><span class="line">            a[i] = aux[i - lo];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Recursive call: process to the next d for each split</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">            sort(a, lo + count[r], lo + count[r+<span class="number">1</span>] - <span class="number">1</span>, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; s.length())</span><br><span class="line">            <span class="keyword">return</span> s.charAt(index);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = &#123;<span class="string">"she"</span>, <span class="string">"sells"</span>, <span class="string">"seashells"</span>, <span class="string">"by"</span>, <span class="string">"the"</span>, <span class="string">"sea"</span>,</span><br><span class="line">                        <span class="string">"shore"</span>, <span class="string">"the"</span>, <span class="string">"shells"</span>, <span class="string">"she"</span>, <span class="string">"sells"</span>, <span class="string">"are"</span>, <span class="string">"surely"</span>, <span class="string">"seashells"</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        String[] b = &#123;<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaa"</span>&#125;;</span><br><span class="line">        sort(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that we add a “cutoff-for-small-subarrays” before the sort really begins. why do we need this?</p>
<p>As we can see, the method quickly divides the array to be sorted into small subarrays. But this is also a double-edged sword: we are certain to have to handle huge numbers of tiny subarrays, so we had better be sure that we handle them efficiently. Each sort involves initializing the 258 (if <code>R = 256</code>) entries of the <code>count[]</code> array to <code>0</code> and transforming them all to indices. Accordingly, the switch to insertion sort for small subarrays is a must for MSD string sort (in the code I simply use a <code>Insertion.sort()</code> for this part).</p>
<p>Please also note another pitfall of MSD sort algorithm: it can be relatively slow for subarrays containing large numbers of equal keys. <strong><em>The worst case for MSD string sorting is when all key are equal</em></strong>: the algorithm cannot make smaller subarrays after each iteration (d). In this case, out program will have to examine every character in all input strings, and the running time is linear in the number of characters in the data (like LSD string sort).</p>
<p>In many cases, we should treat the input strings are randomly generated. In this case, MSD string sort examines just enough characters to distinguish among the keys, and the running time is sub-linear in the number of characters in the data.</p>
<h3 id="Three-way-string-quicksort"><a href="#Three-way-string-quicksort" class="headerlink" title="Three-way string quicksort"></a>Three-way string quicksort</h3><p>This algorithm borrows the idea from quick sort.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3string</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">        <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = charAt(a[lo], d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = charAt(a[i], d);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t &lt; v) exch(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v) exch(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span> i ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>, d);</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) sort(a, lt, gt, d + <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charAt</span><span class="params">(String s, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; s.length())</span><br><span class="line">            <span class="keyword">return</span> s.charAt(index);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(String[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        String tmp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] a = &#123;<span class="string">"she"</span>, <span class="string">"sells"</span>, <span class="string">"seashells"</span>, <span class="string">"by"</span>, <span class="string">"the"</span>, <span class="string">"sea"</span>,</span><br><span class="line">                <span class="string">"shore"</span>, <span class="string">"the"</span>, <span class="string">"shells"</span>, <span class="string">"she"</span>, <span class="string">"sells"</span>, <span class="string">"are"</span>, <span class="string">"surely"</span>, <span class="string">"seashells"</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This algorithm will always partition the array into three subarrays, which is different from MSD as MSD might generate many subarrays and many of them might be small or even empty subarrays. It can adapt well to handling equal keys, keys with long common prefixes. <strong>It will not use extra space, just like quick sort</strong>.</p>
<p>An interesting fact will be found when you try to compare this algorithm with standard quicksort. Indeed, one way to think 2-way string quick sort is <strong><em>as a way for standard quicksort to keep track of leading characters that are known to be equal</em></strong>. Note: no algorithm can beat 3-way string quicksort by more than a constant factor.</p>
<h2 id="Tries"><a href="#Tries" class="headerlink" title="Tries"></a>Tries</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieSTNew</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object val;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> Node[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When finding the node, we use recursion rather than iteration.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node node = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> (Value) node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return value associated with key in the subtrie rooted at x.</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Remember, right now we are at the node corresponding to char at index d-1</span></span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">return</span> get(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value value)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, value, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value value, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) x = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">// Remember, right now we are at the node corresponding to char at index d-1</span></span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123;</span><br><span class="line">            x.val = value;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = put(x.next[c], key, value, d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		TrieSTNew&lt;Integer&gt; trie = <span class="keyword">new</span> TrieSTNew&lt;&gt;();</span><br><span class="line">		trie.put(<span class="string">"dede"</span>, <span class="number">0</span>);</span><br><span class="line">		trie.put(<span class="string">"de"</span>, <span class="number">0</span>);</span><br><span class="line">		trie.put(<span class="string">"deeffe"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String str: trie.keys()) &#123;</span><br><span class="line">			System.out.print( str+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(trie.root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Collecting-keys"><a href="#Collecting-keys" class="headerlink" title="Collecting keys"></a>Collecting keys</h3><p>Now, we are going to implement some methods for collecting keys. The above code contains some basic operations including <code>get</code> and <code>put</code>. Now we will continue to implement some method.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keysWithPrefix(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysWithPrefix</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    collect(<span class="keyword">this</span>.get(root, pre, <span class="number">0</span>), pre, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, Queue&lt;String&gt; q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Starting with Node x, find all keys</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) q.add(pre);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c++)</span><br><span class="line">        collect(x.next[c], pre + c, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Wildcard-match"><a href="#Wildcard-match" class="headerlink" title="Wildcard match"></a>Wildcard match</h3><p>Wildcard match: to implement <code>keysThatMatch()</code> method.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">keysThatMatch</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    collect(root, <span class="string">""</span>, pat, queue);</span><br><span class="line">    <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(Node x, String pre, String pat, Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> len = pre.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == pat.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) queue.add(pre);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> next = pat.charAt(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == next || c == <span class="string">'.'</span>)</span><br><span class="line">            collect(x.next[c], pre + c, pat, queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Longest-prefix"><a href="#Longest-prefix" class="headerlink" title="Longest prefix"></a>Longest prefix</h3><p>Now we also want to method <code>longestPrefixOf(String s)</code> to find the longest string which is a prefix of a given string. The principle is quite similar: go down the trie with the given string; once we find a node with a non-null value, we just update the length.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPrefixOf</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = search(root, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> s.substring(<span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Node x, String s, <span class="keyword">int</span> d, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) length = d;</span><br><span class="line">    <span class="keyword">if</span> (d == s.length()) <span class="keyword">return</span> length;</span><br><span class="line">    <span class="keyword">char</span> c = s.charAt(d);</span><br><span class="line">    <span class="keyword">return</span> search(x.next[c], s, d + <span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h3><p>What if we want to delete a key? Apparently, the first step is to find the node corresponding to the input string and then set the value to <code>null</code>. However, we need to remove many nodes all the way down. This can be easily implemented with the recursive method.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    root = delete(root, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">delete</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d == key.length()) &#123;</span><br><span class="line">        <span class="comment">// Find the node representing the key</span></span><br><span class="line">        x.val = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Keep going down and find the node.</span></span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        x.next[c] = delete(x.next[c], key, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.val != <span class="keyword">null</span>) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="number">0</span>; c &lt; R; c ++) &#123;</span><br><span class="line">        <span class="comment">// Check if x have a non-null link</span></span><br><span class="line">        <span class="keyword">if</span> (x.next[c] != <span class="keyword">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>It is easy to prove the time complexity of this algorithm. What about space?</p>
<p>The number of links in a trie us between <code>RN</code> and <code>RNw</code>, where w is the average key length.</p>
<h2 id="TSTs"><a href="#TSTs" class="headerlink" title="TSTs"></a>TSTs</h2><p>Ternary search tries (TSTs) are used to avoid the excessive space cost associated with R-way tries. In a TST, each node has a character, three links, and a value.The three links corresponds to keys whose current characters are less than, equal, or greater than the node’s character.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSTNew</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        Node left, mid, right;</span><br><span class="line">        Value value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Node node = get(root, key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Note: value could be null</span></span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">get</span><span class="params">(Node x, String key, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) &#123;</span><br><span class="line">            <span class="comment">// Go to the left side.</span></span><br><span class="line">            <span class="keyword">return</span> get(x.left, key, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) &#123;</span><br><span class="line">            <span class="comment">// Go to the right side.</span></span><br><span class="line">            <span class="keyword">return</span> get(x.right, key, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Have not reached the end of key, need to go down.</span></span><br><span class="line">            <span class="keyword">return</span> get(x.mid, key, d + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Have reached the end of the key.</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Value val)</span> </span>&#123;</span><br><span class="line">        root = put(root, key, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, String key, Value val, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = key.charAt(d);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x = <span class="keyword">new</span> Node();</span><br><span class="line">            x.c = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &lt; x.c) &#123;</span><br><span class="line">            <span class="comment">// Go to the left side.</span></span><br><span class="line">            x.left = put(x.left, key, val, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; x.c) &#123;</span><br><span class="line">            <span class="comment">// Go to the rigth side.</span></span><br><span class="line">            x.right = put(x.right, key, val, d);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &lt; key.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Have not reached the end of the key.</span></span><br><span class="line">            x.mid = put(x.mid, key, val, d + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Have reached the end of the key.</span></span><br><span class="line">            x.value = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The number of links in a TST build from N string keys of average length <code>w</code> is between <code>3N</code> and <code>3Nw</code>.</p>
<h2 id="Substring-Search"><a href="#Substring-Search" class="headerlink" title="Substring Search"></a>Substring Search</h2><h3 id="Brute-force"><a href="#Brute-force" class="headerlink" title="Brute-force"></a>Brute-force</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is the brute-force substring search</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (txt.charAt(i + j) != pat.charAt(j))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(search(<span class="string">"ABRA"</span>, <span class="string">"ABACADABRAC"</span>));</span><br><span class="line">        System.out.println(search(<span class="string">"ABRA"</span>, <span class="string">"ABACADABRBC"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time complexity: <code>O(MN)</code>. Below is an alternative solution.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search2</span><span class="params">(String pat, String txt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M = pat.length();</span><br><span class="line">    <span class="keyword">int</span> N = txt.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txt.charAt(i) == pat.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= j;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h3><p>Here I will introduce two versions of KMP algorithms.</p>
<h4 id="2D-Version-with-DFA"><a href="#2D-Version-with-DFA" class="headerlink" title="2D Version with DFA"></a>2D Version with DFA</h4><p>As we mentioned in the brute-force substring match algorithm (the alternate one), if we find a mismatch at some point, <code>j</code> has to set to be <code>0</code> and <code>i</code> will also decremented. This is the main reason that the running time of that algorithm is high.</p>
<p>Is there a way which avoids decrementing the value of ‘j’. This is what KMP algorithm tries to achieve. The basic idea behind the algorithm discovered by Knuth, Morris, and Pratt is this: whenever we detect a mismatch, <em>we already know some of the characters in the text</em>, since they matched the pattern characters prior to the mismatch.</p>
<p>In KMP substring search, we never back up the text pointer <code>i</code>, and we use an array <code>dfa[][]</code> to record how far to back up the pattern pointer <code>j</code> when a mismatch is detected. For every character <code>c</code>, <code>dfa[c][j]</code> is the pattern position to compare with next text position after comparing <code>c</code> with <code>pat.charAt(j)</code>. During the search, <strong><code>dfa[txt.charAt(i)][j]</code> is the pattern position to compare with <code>txt.charAt(i)</code> with <code>pat.charAt(j)</code></strong>. Thus, <code>dfa[pat.charAt(j)][j]</code> is always <code>j+1</code>.</p>
<p>Once we have computed DFA, we then can easily search the match with DFA. You may ask, why we have to call it “DFA”?</p>
<p>In fact, “DFA” represents <em>deterministic finite-state automation</em>. For example, for a pattern <code>A B A B A C</code>, the DFA will be (we will later study how can we construct DFA):</p>
<pre><code>   A B C D E F
j  0 1 2 3 4 5
   -----------
A |1 1 3 1 5 1
B |0 2 0 4 0 4
C |0 0 0 0 0 6</code></pre><p>Please note that here we assume there are only three characters (A, B, and C) in the alphabet. Below is the graphical representation of this DFA.</p>
<p><img src="dfa_graph.jpg" alt="dfa_graph"></p>
<p>We then could easily use this to finish the matching process. The input text string is “B C B A A B A C A A B A B A C A A”:</p>
<p><img src="dfa_process.jpg" alt="dfa_process"></p>
<p>Below is the code corresponding to the process showed in the picture.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dfa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> construct the DFA array    </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length(), M = <span class="keyword">this</span>.pat.length();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">            j = dfa[txt.charAt(i)][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Up to now, you must feel the logic is natural and comfortable. Now, we have to know how can we construct DFA array with a given pattern string, which is much trickier and interesting.</p>
<p>When we have a mismatch at <code>pat.charAt(j)</code>, our interest is in knowing in what state the DFA <em>would be</em> if we were to back up the next index and rescan the text characters that we just saw after shifting to the right one position (remember, <code>i</code> is always incremented by <code>1</code> after a match or mismatch).</p>
<p>What should the DFA do with the next character? <strong><em>Exactly what it would have done if we had backed up</em></strong>, except if it finds a match with <code>pat.charAt(j)</code>, when it should go to state <code>j+1</code>. Certainly, this makes sense and is straightforward.</p>
<p>So, the question here is, what is the back up state X? before this question, we must know what exactly happens (or, say, what we should do) when backing up to state X. Here are two question to discussed about:</p>
<blockquote>
<p>Q: What we actually do after backing up to state <code>X</code>?</p>
</blockquote>
<p>If we back up to state X after a mismatch, keep <code>i</code> not changed, and set <code>j</code> to X. The definition of X should guarantee that <strong>all chars from index 0 to <code>j - 1</code> (i.e., <code>X - 1</code>) are matched with chars prior to <code>i</code> in the text string</strong>. We now, we just need to compare the char of index <code>j</code> (<code>X</code>) in the pattern string and the char of index <code>i</code> in the text string, this may proceed to a nigger state or a level state. Because our DFA is partially completed already, and <code>X &lt; j</code>, so we can use the DFA now! which is: <code>dfa[c][X]</code>, where <code>c</code> is the current text char at index <code>i</code>. And then, according to the definition of DFA, we get a new position for <code>j</code> (the result of <code>dfa[c][X]</code>), and <code>i</code> is incremented by 1.</p>
<p><strong><em>Thus, we can copy the entry values in state <code>X</code> to state <code>j</code>, except when we see a match: <code>dfa[pat.charAt(j)][j] = j + 1</code>.</em></strong></p>
<p>I know this is kind of confusing, so let’s look into 2 example. In both these examples, we use pattern string <code>A B A B A C</code>.</p>
<p><strong>~ Example 1</strong></p>
<p>Say we have completed the first column of DFA (the first column of this DFA is in fact the complete DFA for pattern string <code>A</code>), and we are building the second column. As mentioned earlier, we should back up (exception there is a match, and we will handle this case specially) to state <code>X</code>. <code>X</code> for the second column (<code>j = 1</code>) is <code>0</code> (we will explain why <code>X</code> is this value later).</p>
<pre><code>             (i)
txt string: A A C ...
pat string: A B A ...
             (j)</code></pre><p>We can see that when state is <code>1</code> (<code>j = 1</code>) we have a mismatch. As we said previously, we need to remain the value of <code>i</code>, and set <code>j</code> to <code>0</code>.</p>
<pre><code>             (i)
txt string: A A C...
pat string:   A B A...
             (j)
             (X)</code></pre><p>We have backed up the <code>X</code>, and we have not finished our job. We could only make sure that all chars from index <code>0</code> to <code>X - 1</code> is pattern string are matched (of course, it is none in this example), but how about char on index <code>X</code> (<code>i</code> for text string)? We cannot make sure it is also match.</p>
<p>In fact, because we have finished the first column of DFA, and <code>j</code> is <code>0</code> now, and you may also notice that <strong><em>we are actually doing a match</em></strong>! All of these indicate that we can use the partially completed DFA to determine a new state, which is given by <code>dfa[&#39;A&#39;][X]</code>. The first <code>A</code> indicates the char on index <code>i</code> in text string. If the text string is <code>A B ...</code>, then use <code>dfa[&#39;B&#39;][X]</code>. As we are building the second column of DFA, we might need a loop: <code>dfa[][j] = dfa[][X]</code> (note <code>j</code> here is the original <code>y</code>).</p>
<p>Continue this example. <code>dfa[&#39;A&#39;][X]</code>, which is also <code>dfa[&#39;A&#39;][0]</code> will return <code>1</code>. Thus, we set <code>j</code> to <code>1</code> and increment <code>i</code> by 1.</p>
<pre><code>               (i)
txt string: A A C...
pat string:   A B A...
               (j)</code></pre><p><strong>~ Example 2</strong></p>
<p>You may notice that the example 1 does not show that <strong>all chars from index 0 to <code>X - 1</code> are matched with chars prior to <code>i</code> in the text string</strong>. No worry, we can give you another example.</p>
<p>Suppose now we have a mismatch at index <code>j = 3</code>, and <code>X</code> is <code>1</code>. For example, it happens when the text string is <code>A B A C ...</code></p>
<pre><code>                 (i)
txt string: A B A C A...
pat string: A B A B A...
                 (j)</code></pre><p>As we discussed previously, we need to remain the value of <code>i</code>, and set <code>j</code> to <code>X</code>, which is <code>1</code>.</p>
<pre><code>                 (i)
txt string: A B A C A ...
pat string:     A B A B A ...
                 (j)
                 (X)</code></pre><p>We can see all chars from index <code>0</code> to <code>X - 1</code>, in fact, <code>A</code>, match with txt string. So, we only need to care about the chars after <code>X</code>, and we can just use value of <code>dfa[C][X]</code> as the DFA is partially built. The value given by it is <code>0</code>.</p>
<pre><code>                   (i)
txt string: A B A C A ...
pat string:         A B A B A ...
                   (j)</code></pre><p>I believe these two examples can help you understand the process that we build the DFA array. The key to understand the process is to be aware that state <code>X</code> <em>can make sure all chars prior to index <code>X</code> in pattern string have will be matched if we set <code>j</code> to <code>X</code> and do not change <code>i</code></em>.</p>
<p>There is another way to understand <code>X</code>, and it will help you understand the next question.</p>
<p>For a given string, we define its <strong><em>prefix set</em></strong> as the set of all its prefix (exclude the string itself) and <strong><em>suffix set</em></strong> as the set of all its suffix (exclude the string itself). <strong><code>X</code> will be the length of the longest string in the intersection set of the string’s prefix and suffix set</strong>. For example, for string <code>ABA</code>, longest string is <code>A</code>, and <code>X</code> is <code>1</code>; for <code>ABAB</code>, <code>X</code> will be <code>2</code>.</p>
<p>We have image the you are match two same strings, while sliding one to the left and another one to right. Once the overlapping matches, we get the <code>X</code> value. Take <code>ABAB</code> as an example:</p>
<pre><code>← A B A B
      A B A B →</code></pre><p>It should be easy to derive this representation once you have understand the two examples above.</p>
<p>In fact, this is also the way to compute the value of <code>X</code>. However, we don’t want to use this naive way, and here comes our second question.</p>
<blockquote>
<p>Q: How can we compute the value of <code>X</code>?</p>
</blockquote>
<p>At first, let’s talk about what is the initial value of <code>X</code> when we just start to build the DFA array.</p>
<ul>
<li>If we mismatch at state <code>0</code>, of course we should go back to state <code>0</code> (<code>j = 0</code>). This is totally understandable;</li>
<li>If we mismatch at state <code>1</code>, we could only back up to <code>0</code> as well as we cannot stay the same state.</li>
</ul>
<p>What if we mismatch at other positions? The method is, every time when we have finished one column of DFA, <strong>we need to update the value of <code>X</code></strong>.</p>
<p>Say we now have finished the first three columns of the DFA array and are building the 4th column. The prefix with length of 3 is <code>ABA</code>, and the <code>X</code> value during the construction of 4th column is <code>1</code>:</p>
<pre><code>← A B A
      A B A →
       (X)</code></pre><p>Apparently, value of <code>X</code> is the length that we can self-matched, as showed above. Say now we also have finished the 4th column, and the prefix length should be <code>4</code>. Then, it is necessary to update the value of <code>X</code>:</p>
<pre><code>   (new char added)
        ↓
← A B A B
      A B A B →
       (X)  ↑
          (new char added)</code></pre><p>A critical observation is, to determine the new value of <code>X</code> (or, say, the new length of self-matching), <strong><em>we only need to match the newly added char with the char on index of previous <code>X</code></em></strong>: <code>dfs[pat.charAt(j)][X]</code>!</p>
<p>We can use DFA to do this still because <code>X</code> is smaller than <code>j</code> and the DFA is partially completed!</p>
<p>You will find some interesting facts about <code>X</code>. For example, if <code>X</code> is incremented after one update, it could only be incremented by <code>1</code>; <code>X</code> might also be lower after one update (e.g., if the newly added char is <code>c</code> rather than <code>B</code>, <code>X</code> will become <code>0</code>).</p>
<p>Okay, take a deep breath! We have gone through everything about KMP now, and I believe (100%) that you are confident in writing the code by yourself.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dfa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</span><br><span class="line">        dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, X = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c ++) &#123;</span><br><span class="line">                dfa[c][j] = dfa[c][X];</span><br><span class="line">            &#125;</span><br><span class="line">            dfa[pat.charAt(j)][j] = j + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update X</span></span><br><span class="line">            X = dfa[pat.charAt(j)][X];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length(), M = <span class="keyword">this</span>.pat.length();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</span><br><span class="line">            j = dfa[txt.charAt(i)][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1D-Version-with-PMT"><a href="#1D-Version-with-PMT" class="headerlink" title="1D Version with PMT"></a>1D Version with PMT</h4><p>If you are a Chinese reader, you can also refer to <a href="https://www.zhihu.com/question/21923021/answer/281346746" target="_blank" rel="noopener">this post</a> for a new version which only uses a 1-D array. I will translate it into English later.</p>
<p>One hint I would give you is: though these two versions seem to differ a lot, they still share something (which plays a big role in KMP algorithm) in common. <strong><em>You will find that the the “PMT” mentioned in this version is exactly the restart state <code>X</code> is the 2D version!</em></strong></p>
<h4 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h4><p>For the second version, the time complexity is <code>O(M + N)</code> (<code>O(M)</code> for computing DFA and <code>O(N)</code> for search); if we do not ignore the alphabet size <code>R</code>, then it should be <code>O(RM + N)</code>.</p>
<h3 id="Boyer-Moore-Algorithm"><a href="#Boyer-Moore-Algorithm" class="headerlink" title="Boyer-Moore Algorithm"></a>Boyer-Moore Algorithm</h3><p>AS you can see, KMP algorithm is a method based on <em>left-to-right</em> compare. Here we want to introduce a new algorithm based on the <em>right-to-left</em> compare.</p>
<p>In this algorithm, we still have two pointers, <code>i</code> and <code>j</code>, for text string and pattern string respectively. Index<br><code>i</code> always points to the char in the text string that should be compared with the first char of the pattern string, <code>j</code> initially points to the last char of the pattern string and will be decremented if <code>pat.charAt(j) == txt.charAt(i+j)</code>.</p>
<p>In addition, we also implement an array <code>right[]</code> that gives fir each character in the alphabet, the index of its <em>rightmost occurrence</em> in the pattern (or <code>-1</code> if the character is not in the pattern). For example, if the string is <code>N E E D L E</code>:</p>
<pre><code> A  B  C  D  E ... L   M  N ...
-1 -1 -1  3  5 ... 4  -1  0 ...</code></pre><p>If there is a mismatch between <code>pat.charAt(j)</code> and <code>txt.charAt(i+j)</code>, we will have one of the following three cases:</p>
<ol>
<li>If the character causing the mismatch is not found in the pattern, we can slide the pattern <code>j+1</code> positions to the right;</li>
<li>If the character <code>c</code> causing the mismatch is found in the pattern ,we use the <code>right[]</code> array to line up the pattern with the text string so that character will match its rightmost occurrence in the pattern. To do so, we increment <code>i</code> by <code>j</code> minus <code>right[c]</code>.</li>
<li>If the computation would not increase <code>i</code>, i.e., not helping, we simply increment <code>i</code> by <code>1</code>, just like what we do in the brute-force algorithm.</li>
</ol>
<p>Now, the code below should be understandable and straightforward.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyerMoore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] right;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoyerMoore</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">        right = <span class="keyword">new</span> <span class="keyword">int</span>[R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span> ; c &lt; R; c++) &#123;</span><br><span class="line">            right[c] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            right[pat.charAt(j)] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="keyword">int</span> M = pat.length();</span><br><span class="line">        <span class="keyword">int</span> skip;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - M; i += skip) &#123;</span><br><span class="line">            skip = <span class="number">0</span>;  <span class="comment">// the increment for i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = M - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="comment">// compare pat.charAt(i) and txt.charAt(i+j)</span></span><br><span class="line">                <span class="keyword">if</span> (pat.charAt(j) != txt.charAt(i+j)) &#123;</span><br><span class="line">                    skip = j - right[txt.charAt(i+j)];</span><br><span class="line">                    <span class="comment">// if value of `right` is -1, then skip = j + 1, which is the second case</span></span><br><span class="line">                    <span class="keyword">if</span> (skip &lt; <span class="number">1</span>) skip = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skip == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Please note, this algorithm requires <em>backup in the input string</em>, i.e., we need to read previous chars again during the process. It enables us to exploit some features of right-to-left compares. In some applications where backup is not allowed, KMP would be a better candidate.</p>
<h3 id="Rabin-Karp-Algorithm"><a href="#Rabin-Karp-Algorithm" class="headerlink" title="Rabin-Karp Algorithm"></a>Rabin-Karp Algorithm</h3><p>Unlike the two algorithms above, this algorithm will use hashing. In fact, each string of length <code>M</code> corresponds to an <code>M</code>-digit base-<code>R</code> number, which means we can totally treat a string as a number. We could also implement a has function to convert an <code>M</code>-digit base-<code>R</code> number to an <code>int</code> value between 0 and <code>Q-1</code>, with the help of modular hashing.</p>
<p> A naive solution is based on the brute-force substring matching: we could simply compute the hash value for every possible substring with length <code>M</code> of the text string, and compare it with the hash value of pattern string. However, it is not efficient and shows no improvement over brute-force solution.</p>
<p>The Rabin-Karp algorithm shows an efficient way to get the new hash value after we move <code>i</code> to the right position<br>by 1. It is easy to derive this logic with some simple maths work:</p>
<p>Using the notation $t_i$ for <code>txt.charAt(i)</code>, the number corresponding to the <code>M</code>-character substring of text string that starts at position <code>i</code> is</p>
<p>$$x_i = t_iR^{M-1} + t_{i+1}R^{M} + … + t_{i+M-1}R^0$$</p>
<p>and we can assume that we know the value of $h(x_i)=x_i$ mod Q. It is also easy to get that</p>
<p>$$x_{i+1} = (x_i - t_iR^{M-1})R+t_{i+M}$$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> patHash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> Q;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> RM;  <span class="comment">// R^(M - 1) % Q</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="keyword">this</span>.M = pat.length();</span><br><span class="line">        Q = <span class="number">997</span>; <span class="comment">// A prime number</span></span><br><span class="line">        RM = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            RM = (R * RM ) % Q;</span><br><span class="line">        &#125;</span><br><span class="line">        patHash = hash(pat, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M ; j++) &#123;</span><br><span class="line">            h = (R * h + key.charAt(j)) % Q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="keyword">long</span> txtHash = hash(txt, M); <span class="comment">// only get the hash value for the first M chars</span></span><br><span class="line">        <span class="keyword">if</span> (patHash == txtHash &amp;&amp; check(<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; i &lt; N; N++) &#123;</span><br><span class="line">            txtHash = (txtHash + Q - RM * txt.charAt(i-M) % Q) % Q;  </span><br><span class="line">            <span class="comment">// Adding Q to make sure we can always get the positive value</span></span><br><span class="line">            txtHash = (txtHash * R + txt.charAt(i)) % Q;</span><br><span class="line">            <span class="keyword">if</span> (patHash == txtHash &amp;&amp; check(i - M + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You may notice that there is a function called <code>check()</code>. Why do we need this?</p>
<p>hashing is a good thing and we could exploit hashing for many applications, e.g., <code>HashMap</code> in Java. However, one main problem of hashing is that we may see hash conflict sometimes. Of course, we have the same problem in this case, as two different strings will get the same hash value. In order to resolve this issue, we can simply add an additional check when we see a hash value match, but we do not want to do that as it requires backup in the text string. Instead, we can choose a bigger value for <code>Q</code> to make the probability of hash conflict very small.</p>
<p>This algorithm is an early and famous example of <em>Monte Carlo</em> algorithm that has a guaranteed completion time but fails to output a correct answer with a small probability. The alternative method of checking for a match could be slow (it might amount to the brute-force algorithm, with a small probability) but is guaranteed correct, which is known as a <em>Las Vegas</em> algorithm.</p>
<p>Rabin-Karp substring search is known as a <em>fingerprint</em> search because it uses a small amount of information to represent a pattern.</p>
<h2 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h2><p>Substring search appears in many applications in real world, but we also need regular expressions to describe patterns and use this pattern to recognize some input string. In this section, we will implement algorithms for recognizing strings with regex.</p>
<p>If you have experience with regex in some programming languages, you may notice that there are many complicated rules in regex, but here we will not do all of them. Instead, we will only focus on three basic operations:</p>
<ol>
<li>Concatenation: when we write <code>AB</code>, we are specifying the language <code>{AB}</code>that has one two-character string, formed by concatenating <code>A</code> and <code>B</code>;</li>
<li>Or: specified by <code>|</code>. E.g., <code>A|B</code> specified the language <code>{A, B}</code>;</li>
<li>Closure: close allows parts of the pattern to be repeated arbitrarily. We denote closure by placing a <code>*</code> after<br>the pattern to be repeated.</li>
</ol>
<p>By convention, we also use parentheses to override the default precedence rules. All patterns will be enclosed in parentheses as well.</p>
<h3 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h3><p>Recall the KMP algorithm for substring search where DFA is exploited. Here we will also exploit this idea, though we might do something different.</p>
<p>We will build a <strong><em>nondeterministic finite-state automata</em></strong> (NFA) for a given regex string. Unlike DFA, the automata shows nondeterminism due to the nature of regex, as we are faced with more than one way to try to match the pattern.</p>
<p>For pattern string <code>((A*B|AC)D)</code>, the NFA is showed below:</p>
<p><img src="nfa.svg" alt="nfa_eg"></p>
<p>The rules for an NFA is listed below:</p>
<ol>
<li>The NFA corresponding to an regex of length <em>M</em> has exactly one state per pattern chars, starts at state 0, and has a (virtual) accept state <em>M</em>;</li>
<li>States corresponding to character from the alphabet have an outgoing edge that goes to the state corresponding to the next character in the pattern (black edges in the diagram);</li>
<li>States corresponding to the meta-chars <code>(</code>,<code>)</code>,<code>|</code>,<code>*</code> have at least one outgoing black edge (red edges in the diagram).</li>
<li>No state has more than one outgoing black edge.</li>
</ol>
<p>What are the the rules when we match the input string?</p>
<ol>
<li>If the current state corresponding to a char in the alphabet and the current char in the text string matched the char, the automation can scan past the char in the text string and take the black transition to the next state;</li>
<li>the automation can follow any red edge to another state without scanning any text char.</li>
</ol>
<p>We can use the rules to scan and recognize the input text string. As there might be multiple outgoing red edges for a state, we need to find all possible path to check the input text string.</p>
<h3 id="Simulating-an-NFA"><a href="#Simulating-an-NFA" class="headerlink" title="Simulating an NFA"></a>Simulating an NFA</h3><p>NFA is in similar to a directed graph and simulating an NFA is similar to DFS. We create the initial states by starting state <code>0</code> and going all the way to states pointed by read edge. In the example above, the initial state should be <code>0 1 2 3 4 6</code>; if the first char in text string is <code>A</code>, then we update the state set to <code>2 3 4 7</code>. We should keep doing this until all chars from text string are exhausted, and finally we check if the accept state is in the state set.</p>
<p><strong>Note</strong>: when building digraph, we will not include the black edges into the graph.</p>
<p>We then can write the code out immediately with the idea. The code use <code>Digraph</code> and <code>DirectedDFS</code> class and you may refer to their implementation in <a href="#Appendix">Appendix</a>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] re;</span><br><span class="line">    <span class="keyword">private</span> Digraph G;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NFA</span><span class="params">(String regexp)</span> </span>&#123;</span><br><span class="line">        re = regexp.toCharArray();</span><br><span class="line">        M = regexp.length();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> construct the NFA</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recognizes</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; pc = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        DirectedDFS dfs = <span class="keyword">new</span> DirectedDFS(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; txt.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// Compute possible NFA states for txt[i+1]</span></span><br><span class="line">            Set&lt;Integer&gt; match = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: pc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &lt; M) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (re[v] == txt.charAt(i) || re[v] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                        match.add(v+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs = <span class="keyword">new</span> DirectedDFS(G, match);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: pc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == M) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Determining whether an N-character text string is recognized by the NFA corresponding to an M-character RE takes time proportional to <em>NM</em> in the worst case. However, we in fact need to know the number of edges in the directed graph. We will talk about it later.</p>
<h3 id="Building-an-NFA"><a href="#Building-an-NFA" class="headerlink" title="Building an NFA"></a>Building an NFA</h3><p>Now, the problem is how we can build an NFA given a pattern string. For different operations, we might need to exploit different rules.</p>
<p><strong><em>Concatenation</em></strong></p>
<p>This is the simplest one. We just mentioned that we do not include black edge into the graph, so we can just simply ignore the char if the char is in the alphabet.</p>
<p><strong><em>Parentheses</em></strong></p>
<p>We just push the RE index of each left parentheses on the stack, and pop the left one out of the stack if we see a right one. It could be tricker than you think, as we will also push the or operator <code>|</code> on the stack.</p>
<p><strong><em>Closure</em></strong></p>
<p>A closure (*) operator must occur either after a single character or after a right parenthesis. The picture below shows these two cases and what we should do regarding updating the graph.</p>
<p><img src="nfa_closure.svg" alt="nfa_closure"></p>
<p><strong><em>Or</em></strong></p>
<p>We only consider an RE of the form <code>(A|B)</code> where <code>A</code> and <code>B</code> are both REs. When we see <code>)</code>, we should find the index of <code>|</code> and <code>(</code> then add two edges to the graph, as showed in the picture below. Please note within a pair of parenthesis, there will only be one <code>|</code>; a form of RE like <code>(A|B|C)</code> is not supported here.</p>
<p><img src="nfa_or.svg" alt="nfa_or"></p>
<p>With all the rules above, we can implement the code for building an NFA.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] re;</span><br><span class="line">    <span class="keyword">private</span> Digraph G;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NFA</span><span class="params">(String regexp)</span> </span>&#123;</span><br><span class="line">        re = regexp.toCharArray();</span><br><span class="line">        M = regexp.length();</span><br><span class="line">        G = <span class="keyword">new</span> Digraph(M+<span class="number">1</span>);  <span class="comment">// Remember to include the accept state</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> lp = i;</span><br><span class="line">            <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'|'</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (re[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> or = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (re[or] == <span class="string">'|'</span>) &#123;</span><br><span class="line">                     lp = stack.pop();</span><br><span class="line">                     G.addEdge(lp, or+<span class="number">1</span>);</span><br><span class="line">                     G.addEdge(or, i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lp = or;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; M - <span class="number">1</span> &amp;&amp; re[i+<span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="comment">// lp could be i (current index), or a left parenthesis.</span></span><br><span class="line">                <span class="comment">// It in fact handles the two cases for closure.</span></span><br><span class="line">                G.addEdge(lp, i+<span class="number">1</span>);</span><br><span class="line">                G.addEdge(i+<span class="number">1</span>, lp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (re[i] == <span class="string">'('</span> || re[i] == <span class="string">'*'</span> || re[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                G.addEdge(i, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recognizes</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; pc = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        DirectedDFS dfs = <span class="keyword">new</span> DirectedDFS(G, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; txt.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// Compute possible NFA states for txt[i+1]</span></span><br><span class="line">            Set&lt;Integer&gt; match = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: pc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &lt; M) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (re[v] == txt.charAt(i) || re[v] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                        match.add(v+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs = <span class="keyword">new</span> DirectedDFS(G, match);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs.marked(v)) pc.add(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: pc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == M) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Building the NFA corresponding to an M-character RE takes time ad space proportional to M in the worst case, as for each of the RE character in the regular expression, we add at most three transitions and perhaps execute one or two stack operations.</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h2><h3 id="Directed-Graph-and-DFS"><a href="#Directed-Graph-and-DFS" class="headerlink" title="Directed Graph and DFS"></a>Directed Graph and DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span> <span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[])<span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        adj[v].add(w); <span class="comment">// v -&gt; w</span></span><br><span class="line">        <span class="keyword">this</span>.E ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Digraph <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Digraph R = <span class="keyword">new</span> Digraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w: adj(v)) &#123;</span><br><span class="line">                R.addEdge(w, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedDFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(Digraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedDFS</span><span class="params">(Digraph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s: sources) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[s]) dfs(G, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: G.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</span> -->
        </article>
    
        

        

        <article class="archive-item">
            <a class="archive-item-link" href="/2020/01/10/DFS-notes/">DFS总结2</a>
            <span class="archive-item-date">Jan 10, 2020</span>
            <!-- <span style=> <h2 id="DFS-大全2"><a href="#DFS-大全2" class="headerlink" title="DFS 大全2"></a>DFS 大全2</h2><p>在此写一个dfs的相关题目总结。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><font color=green><strong>Easy</strong></font><br><font color=orange><strong>Medium</strong></font><br><font color=red><strong>Hard</strong></font></p>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Notes</th>
<th>自评</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#694"><strong>694</strong></a> <font color=orange><strong>Medium</strong></font> Number of Distinct Islands</td>
<td>Typical DFS but could be tricky!</td>
<td><font color=orange><strong>Medium</strong></font> Very smart and think about it carefully.</td>
</tr>
<tr>
<td><a href="#126"><strong>126</strong></a> <font color=red><strong>Hard</strong></font> word ladder II</td>
<td>New BFS problems, the element in queue in a path!</td>
<td><font color=red><strong>Hard</strong></font> It is easy to find shortest path with BFS, but how about finding multiple paths?</td>
</tr>
<tr>
<td><a href="#351"><strong>351</strong></a> <font color=orange><strong>Medium</strong></font> Android Unlock Patterns</td>
<td>A very interesting problem but not so hard.</td>
<td><font color=red><strong>Medium</strong></font> Some solutions are symmetric so you do not have to do DFS on every entry.</td>
</tr>
<tr>
<td><a href="#139"><strong>139</strong></a> <font color=orange><strong>Medium</strong></font> Word Break</td>
<td>In fact it is a typical DFS problem with memo.</td>
<td><font color=orange><strong>Medium</strong></font> You have to deeply REMEMBER this solution.</td>
</tr>
<tr>
<td><a href="#140"><strong>140</strong></a> <font color=red><strong>Hard</strong></font> Word Break II</td>
<td>This is the follow-up from the last one.</td>
<td><font color=orange><strong>Medium</strong></font> This is still dfs+memo. You have to know how to use memo in this case!</td>
</tr>
<tr>
<td><a href="#505"><strong>505</strong></a> <font color=orange><strong>Medium</strong></font> The Maze II</td>
<td>You can do it with a standard DFS or BFS. But either solution may visit a node more than once. This is a typical shortest path solution, and either BFS or DFS is an instance of the generic solution to SP. The BFS solution would be modified into Dijkstra’s algorithm.</td>
<td><font color=orange><strong>Medium</strong></font> It is not a normally DFS/BFS solution as one node might be visited for more than once.</td>
</tr>
</tbody></table>
<h3 id="694-Number-of-Distinct-Islands"><a href="#694-Number-of-Distinct-Islands" class="headerlink" title="694 Number of Distinct Islands"></a><a id="694">694 Number of Distinct Islands</a></h3><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.</p>
<p><strong>Example</strong>:</p>
<pre><code>11011
10000
00001
11011</code></pre><p>The output is 2.</p>
<p>这个题目不难，典型的dfs，先看一个解法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we could still use dfs to solve this problem</span></span><br><span class="line">        <span class="comment">// we may record the "direction" of dfs to identify the shape of an island</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">// origin</span></span><br><span class="line">                dfs(i, j, grid, sb, <span class="string">'o'</span>); <span class="comment">// origin</span></span><br><span class="line">                set.add(sb.toString());</span><br><span class="line">                System.out.println(sb);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid, StringBuilder sb, <span class="keyword">char</span> direction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        sb.append(direction);</span><br><span class="line"></span><br><span class="line">        dfs(i-<span class="number">1</span>, j, grid, sb, <span class="string">'u'</span>);</span><br><span class="line">        dfs(i+<span class="number">1</span>, j, grid, sb, <span class="string">'d'</span>);</span><br><span class="line">        dfs(i, j-<span class="number">1</span>, grid, sb, <span class="string">'l'</span>);</span><br><span class="line">        dfs(i, j+<span class="number">1</span>, grid, sb, <span class="string">'r'</span>);</span><br><span class="line"></span><br><span class="line">        sb.append(<span class="string">'b'</span>); <span class="comment">// This is amazing!!!!!</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要在dfs做完之后加一个”b”呢？假如没有的话，请考虑一下这种情况：</p>
<pre><code>1 1 0
0 1 1
0 0 0
1 1 1
0 1 0</code></pre><p>这次做完两个大的dfs之后，会发现两个字符串均为<code>ordr</code>，也就是说这种方法还是无法区分某些不同的island。在后面在一个<code>b</code>等于mark了一个dfs的结束，这样，两个island要完全相同，才能保证这两个对应的字符串是一样的。</p>
<h3 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title=" 126 Word Ladder II "></a><a id="126"> 126 Word Ladder II </a></h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:</p>
<ul>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li>
</ul>
<p>In BFS, it is easy to find the shortest path, but how can you find all possible shortest paths?</p>
<p>There are several points you need to pay attention to:</p>
<ul>
<li>How can you save the paths? One good way is to use the path as the element of the queue;</li>
<li>How can you make sure that some nodes could be visited twice? The solution is here is really interesting: <strong>we only mark the nodes as visited only after we have done this level</strong>. This can ensure two different paths can both visit this node if they reach it at the same level. It also make sure this node is not visited by the higher level;</li>
<li><code>minLevel</code> is used to avoid unnecessary BFS.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> minLevel = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</span><br><span class="line">        <span class="comment">// just like finding all possible paths?</span></span><br><span class="line">        <span class="comment">// maybe bfs?</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>[beginWord] = findNeighbor(beginWord, wordList);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; word: wordList) <span class="built_in">map</span>[word] = findNeighbor(word, wordList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// I think one problem with BFS is</span></span><br><span class="line">        <span class="comment">// how can you make sure that some elements can be visited more than once?</span></span><br><span class="line">        <span class="comment">//basic idea, we mark the node is visited only after the level is done</span></span><br><span class="line">        <span class="comment">// thus, two different paths which reaching a node at same level can both</span></span><br><span class="line">        <span class="comment">// visit this node</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;beginWord&#125;);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; str: wordList) wordSet.insert(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curPath = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curPath.size() &gt; level) &#123;</span><br><span class="line">                <span class="comment">// enter new level</span></span><br><span class="line">                <span class="keyword">if</span> (curPath.size() &gt; minLevel) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    level = curPath.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// add visited node</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">string</span> str: visited) wordSet.erase(str);</span><br><span class="line">                visited.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> lastWord = curPath.back();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i: <span class="built_in">map</span>[lastWord]) &#123;</span><br><span class="line">                <span class="built_in">string</span>&amp; newWord = wordList[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// is visited?</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.find(newWord) == wordSet.end()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                visited.insert(newWord);</span><br><span class="line">                <span class="comment">// prepare a new path</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = curPath;</span><br><span class="line">                path.push_back(newWord);</span><br><span class="line">                <span class="keyword">if</span> (newWord == endWord) &#123;</span><br><span class="line">                    res.push_back(path);</span><br><span class="line">                    minLevel = level;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    q.push(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNeighbor(<span class="built_in">string</span>&amp; word, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="comment">// given a word, find neighbor</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; s = words[i];</span><br><span class="line">            <span class="keyword">if</span> (s.size() != word.size()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size() ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] != word[j]) diff ++;</span><br><span class="line">                <span class="keyword">if</span> (diff &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (diff == <span class="number">1</span>) vec.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Share another java solution: we may firstly use BFS solution to get the distance of all nodes, and then use DFS to get the results.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bfs + dfs</span></span><br><span class="line">    <span class="comment">// bfs is responsible for find nodes and distance by level traversal</span></span><br><span class="line">    <span class="comment">// dfs is to find all results</span></span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Set&lt;String&gt;&gt; neighbors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bfs(beginWord, endWord, set, distance, neighbors);</span><br><span class="line">        <span class="comment">// System.out.println(neighbors);</span></span><br><span class="line">        <span class="comment">// System.out.println(distance);</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, distance, neighbors, list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String startWord, String endWord, Set&lt;String&gt; allWords, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Map&lt;String, Set&lt;String&gt;&gt; neighbors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assume we have put start word in the start set</span></span><br><span class="line">        distance.put(startWord, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(startWord);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">boolean</span> shouldEnd = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                String cur = queue.poll();</span><br><span class="line">                List&lt;String&gt; nexts = getNeighbors(cur, allWords);</span><br><span class="line">                neighbors.put(cur, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                <span class="keyword">for</span> (String next: nexts) &#123;</span><br><span class="line">                    neighbors.get(cur).add(next);</span><br><span class="line">                    <span class="keyword">if</span> (!distance.containsKey(next)) &#123;</span><br><span class="line">                        distance.put(next, level + <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (next.equals(endWord)) &#123;</span><br><span class="line">                            shouldEnd = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            queue.offer(next);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldEnd) <span class="keyword">break</span>;</span><br><span class="line">            level ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String startWord, String endWord, Map&lt;String, Integer&gt; distance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Map&lt;String, Set&lt;String&gt;&gt; neighbors, List&lt;String&gt; curList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startWord.equals(endWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(curList));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; nexts = neighbors.get(startWord);</span><br><span class="line">        <span class="keyword">if</span> (nexts == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (String next: nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance.get(next) != distance.get(startWord) +  <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            curList.add(next);</span><br><span class="line">            dfs(next, endWord, distance, neighbors, curList);</span><br><span class="line">            curList.remove(curList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">                chs[i] = ch;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = old_ch;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="315-Android-Unlock-Patterns"><a href="#315-Android-Unlock-Patterns" class="headerlink" title=" 315 Android Unlock Patterns "></a><a id="315"> 315 Android Unlock Patterns </a></h3><p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.</p>
<p>This is a very interesting problem, and guess what, it must come form Google! So this problem is not hard to solve. As for the work flow and logic, you can use DFS and back-tracing; the hard part is to find all possible next integer for a specific integer. But it is still trivial, as there is only 9 grid in total. Also note that we do not have to do dfs for every entry in the 2D array as the array is symmetric.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// OMG this question in sl interesting!</span></span><br><span class="line">        <span class="comment">// the basic work flow: recursion (backtracing)</span></span><br><span class="line">        <span class="comment">// how can you determine if two number can be connected?</span></span><br><span class="line">        <span class="keyword">boolean</span> visited[][] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; 3; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         dfs(i, j, m, n, visited);</span></span><br><span class="line">        <span class="comment">//         // System.out.println();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="number">4</span> * dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, visited);</span><br><span class="line">        ans += <span class="number">4</span> * dfs(<span class="number">0</span>, <span class="number">1</span>, m, n, visited);</span><br><span class="line">        ans += dfs(<span class="number">1</span>, <span class="number">1</span>, m, n, visited);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (i &lt; 0 || i&gt;= 3 || j &lt; 0 || j &gt;= 3) return ;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> new_min = Math.max(<span class="number">0</span>, min - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> new_max = max - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (new_min == <span class="number">0</span>) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (new_max == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span>[] middle = getMiddle(i, j, x, y);</span><br><span class="line">                <span class="keyword">if</span> (middle == <span class="keyword">null</span> || visited[middle[<span class="number">0</span>]][middle[<span class="number">1</span>]]) &#123;</span><br><span class="line">                    res += dfs(x, y, new_min, new_max, visited);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] getMiddle(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = x0 + y0 + x1 + y1;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> diffx = Math.abs(x0-x1), diffy = Math.abs(y0-y1);</span><br><span class="line">        <span class="keyword">if</span> (diffx == <span class="number">1</span> &amp;&amp; diffy == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;(x1+x0)/<span class="number">2</span>, (y0+y1)/<span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title=" 139 Word Break "></a><a id="139"> 139 Word Break </a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>This is a typical DFS + memo problem. It is not hard to write down, but it is very basic.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// the recursion situation is like O(n!)</span></span><br><span class="line">        <span class="comment">// use dp</span></span><br><span class="line">        <span class="comment">// Time complexity: O(s.length() * wordDict.size()) in worst case</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; <span class="comment">// dp[i] =&gt; substring(i)</span></span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> visit(s, <span class="number">0</span>, wordDict, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">visit</span><span class="params">(String s, <span class="keyword">int</span> index, List&lt;String&gt; words, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[index] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[index] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if dp[index] == -1 -&gt; not visited</span></span><br><span class="line">        <span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(word, index)) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex = index + word.length();</span><br><span class="line">                <span class="keyword">if</span> (visit(s, nextIndex, words, dp)) dp[index] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[index] == -<span class="number">1</span>) dp[index] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In fact, we do need to make it too complicated. A simple pass through DP is enough.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dp[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (set.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The code is self-explanatory.</p>
<h3 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title=" 140 Word Break II "></a><a id="140"> 140 Word Break II </a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>In this case, the common solution is still DFS. But how can you save the results? Use the map.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> visit(s, wordDict, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">visit</span><span class="params">(String s, List&lt;String&gt; wordDict, Map&lt;String, List&lt;String&gt;&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) <span class="keyword">return</span> map.get(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str: wordDict) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(str)) &#123;</span><br><span class="line"></span><br><span class="line">                List&lt;String&gt; tmp = visit(s.substring(str.length()), wordDict, map);</span><br><span class="line">                <span class="keyword">for</span> (String suffix: tmp) &#123;</span><br><span class="line">                    list.add(str + (suffix.length() &gt; <span class="number">0</span>? <span class="string">" "</span>: <span class="string">""</span>) + suffix);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(s, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="505-The-Maze-II"><a href="#505-The-Maze-II" class="headerlink" title=" 505 The Maze II "></a><a id="505"> 505 The Maze II </a></h3><p>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>This is a typical shortest path problem. For this problem, we have a generic solution:</p>
<p>Define “relax” an edge in the following code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e: G.adj(v)) &#123;</span><br><span class="line">         <span class="keyword">int</span> w = e.to(); <span class="comment">// w is another vertex connected by e</span></span><br><span class="line">         <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">            distTo[w] = distTo[v] + e.weight();</span><br><span class="line">            edgeTo[w] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Then we have a generic solution for shortest path: Initialize <code>distTo[s]</code> (<code>s</code> is the source/start of the graph) to 0 and all other <code>distTo[]</code> values to infinity, and proceed as follows: Relax any edge in this graph, continuing until no edges is eligible. For all vertices <code>w</code> reachable from <code>s</code>, the value of <code>distTo[w]</code> after this computation is the length of a shortest path from <code>s</code> to <code>w</code>.</p>
<p>We now have two solutions, DFS and BFS.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] m;</span><br><span class="line">    <span class="keyword">int</span>[] s;</span><br><span class="line">    <span class="keyword">int</span>[] d;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dfs + memo</span></span><br><span class="line">        m = maze;</span><br><span class="line">        s = start;</span><br><span class="line">        d = destination;</span><br><span class="line">        <span class="keyword">int</span> row = m.length, col = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        dp[s[<span class="number">0</span>]][s[<span class="number">1</span>]] = <span class="number">1</span>; <span class="comment">// 0 is unvisited</span></span><br><span class="line">        dfs(s[<span class="number">0</span>], s[<span class="number">1</span>], dp);</span><br><span class="line">        <span class="keyword">return</span> dp[d[<span class="number">0</span>]][d[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we start from the start end, and visit all possible nodes in the current call</span></span><br><span class="line">        <span class="comment">// then update the dp matrix. We always choose the min distance</span></span><br><span class="line">        <span class="keyword">if</span> (i == d[<span class="number">0</span>] &amp;&amp; j == d[<span class="number">1</span>]) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span>[] dirs = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diffx = dirs[p], diffy = dirs[p+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> x = i, y = j;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x + diffx &gt;= <span class="number">0</span> &amp;&amp; x + diffx &lt; m.length &amp;&amp; y + diffy &gt;= <span class="number">0</span> &amp;&amp; y + diffy &lt; m[<span class="number">0</span>].length</span><br><span class="line">                   &amp;&amp; m[x+diffx][y+diffy] == <span class="number">0</span>) &#123;</span><br><span class="line">                x += diffx; y += diffy;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> newLength = dp[i][j] + len;</span><br><span class="line">            <span class="keyword">if</span> (dp[x][y] &gt; <span class="number">0</span> &amp;&amp; newLength &gt;= dp[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            dp[x][y] = newLength;</span><br><span class="line">            dfs(x, y, dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] maze, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] destination)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we use the bfs to try!</span></span><br><span class="line">        <span class="comment">// If a node is updated, then put it in the queue again</span></span><br><span class="line">        <span class="comment">// This soluton could be modified to Dijkstra's algorithm!</span></span><br><span class="line">        <span class="comment">// we still have to use a distance matrix 2D</span></span><br><span class="line">        <span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[maze.length][maze[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d: distance) Arrays.fill(d, Integer.MAX_VALUE);</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start[<span class="number">0</span>], start[<span class="number">1</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = cur[<span class="number">0</span>], j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span>[] dirs = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">int</span> diffx = dirs[p], diffy = dirs[p+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x = i, y = j;</span><br><span class="line">                <span class="keyword">int</span> len = cur[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">while</span> (x + diffx &gt;= <span class="number">0</span> &amp;&amp; x + diffx &lt; maze.length &amp;&amp; y + diffy &gt;= <span class="number">0</span> &amp;&amp; y + diffy &lt; maze[<span class="number">0</span>].length</span><br><span class="line">                       &amp;&amp; maze[x+diffx][y+diffy] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x += diffx; y += diffy;</span><br><span class="line">                    len ++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This is a way to reduce extra operation</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (distance[x][y] != <span class="number">0</span> &amp;&amp; distance[x][y] &gt; len) &#123;</span><br><span class="line">                    distance[x][y] = len;</span><br><span class="line">                    <span class="keyword">if</span> (x != destination[<span class="number">0</span>] || y != destination[<span class="number">1</span>]) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y, len&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = distance[destination[<span class="number">0</span>]][destination[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE? -<span class="number">1</span>: res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Either solution is an instance of the generic solution to SP problem. BFS could be modified into Dijkstra’s algorithm then.</p>
</span> -->
        </article>
    
    

</div>

</div>


        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Yihang (Ian) Ding | Powered by <i><a href="https://hexo.io" target="_blank">Hexo</a></i> & <i><a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></i></span>
    </div>
</footer>

    </div>
</body>
</html>
